<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[低功耗蓝牙]]></title>
    <url>%2Fpassages%2F2022-09-18-%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99%2F</url>
    <content type="text"><![CDATA[低功耗蓝牙知识梳理 低功耗蓝牙 视频教程 基础概念 经典蓝牙模块(BT) 低功耗蓝牙模块(BLE) 低功耗蓝牙模块的优势 gap 主机和从机 蓝牙广 gatt profile service characteristic uuid 组成 内存的访问方式 io的访问方式 冯诺依曼结构与哈佛结构 寄存器 低功耗蓝牙视频教程低功耗蓝牙BLE相关概念及用法-哔哩哔哩 基础概念经典蓝牙模块(BT) 泛指支持蓝牙协议在4.0以下的模块，一般用于数据量比较大的传输，如：语音、音乐等较高数据量传输。经典蓝牙模块可再细分为：传统蓝牙模块和高速蓝牙模块。传统蓝牙模块在2004年推出，主要代表是支持蓝牙2.1协议的模块，在智能手机爆发的时期得到广泛支持。高速蓝牙模块在2009年推出，速率提高到约24Mbps，是传统蓝牙模块的八倍，可以轻松用于录像机至高清电视、PC至PMP、UMPC至打印机之间的资料传输。 低功耗蓝牙模块(BLE) 指支持蓝牙协议4.0或更高的模块，也称为BLE模块，最大的特点是成本和功耗的降低，应用于实时性要求比较高的产品中，比如：智能家居类(蓝牙锁、蓝牙灯)、传感设备的数据发送(血压计、温度传感器)、消费类电子(电子烟、遥控玩具)等。低功耗蓝牙（BLE）连接都是建立在 GATT (Generic Attribute Profile) 协议之上。GATT 是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范，这些很短的数据段被称为属性（Attribute）。 低功耗蓝牙模块的优势 BLE蓝牙模块功耗更低、供电时间长:因为低功耗蓝牙技术已经发展到日常平均功耗可以做到10mA以下了，如此低功耗蓝牙应用在智能产品中，用体积很小的电池供电就能坚持工作一两年甚至更久，相对其它无线技术和经典蓝牙的功耗，这正是智能产品愿意且中意的通信技术。 低功耗蓝牙模块连接速度快:低功耗蓝牙技术采用非常快速的连接方式，连接时间间隔可变，这个间隔根据具体应用可以设置为几毫秒到几秒不等，几乎瞬间就能与智能手机相连，极大缩短等待的时间。 低功耗蓝牙模块使用免执照频段:因为低功耗蓝牙技术是一种免费的电磁频段，低功耗蓝牙运行的2.4GHz的频段，正是完全免费的一个电磁频段，其它例如WiFi、电磁炉等都是使用的2.4GHz的频段，就是因为这个频段不用向无线电管理部门交专门的授权费用。 低功耗蓝牙模块操作简单，更适合智能产品:一款内嵌低功耗蓝牙模块的智能产品能直接连到手机上，相对于市面上其它通讯手段，例如433MHz、ZigBee来说，虽然这些通讯技术也很成熟、传输距离也不错，但是它们并没有在智能手机上有所体现，而蓝牙功能基本是智能手机的标配之一了，匹配操作起来根本无需其它终端设备，由此来说智能产品选择蓝牙技术的原因就是终端市场的认可。 gap GAP是Generic Access Profile的缩写，中文译为通用访问配置文件，主机和从机就是它定义的。GAP不仅定义了蓝牙通信的角色，还控制着它们的广播和连接方式。GAP使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与设备进行交互。某些设备可以配置成只发送广播而不支持连接，比如一些Beacon设备。 主机和从机 主机和从机是相对的概念，又可以称为主设备/中心/中心设备（Central）和从设备/外设/外围设备（Peripheral）等等。举个简单的例子，我们在使用手机搜索、连接和控制家里的BLE设备的时候，我们的手机就是主机，设备就是从机。一个主机可以同时连接多个从机，一个从机同一时间只能被一个主机连接。 蓝牙广 信道，指通信的通道，是信号传输的媒介，信道按照传输媒介可以分为有线信道与无线信道两类：有线信道-明线、电缆、光纤等；无线信道-利用电磁波在自由空间传播来传输信号，如短波电离层反射信道、微波中继信道、卫星信道等。对于无线电波而言，它从发送端到接收端，其间并没有一个有形的连接，但是我们为了形象地描述发送端与接收端之间的工作，想象两者之间有一个看不见的道路衔接，即信道。 低功耗蓝牙工作在2.4GHz频段，频率范围为 2402MHz–2480MHz，每2MHz一个信道，共40个信道，其中为3个广播信道，剩余的37为个数据信道。为了防止互相干扰，37、38、39这3个广播信道的频率隔的比较远。 gatt GATT是Generic Attribute Profile的缩写，中文译为通用属性配置。我们使用BLE的时候，主机和从机建立的连接通常称为GATT连接。GATT也给BLE设备定义了角色，GATT Server和GATT Client。通常情况下，主机就是Client，从机就是Server。这是一个C/S架构，主机向从机请求服务。GATT中还有两个尤其重要的概念，Service和Characteristic，一个Service包含多个Characteristic。BLE主从设备之间通信多数情况下就是对特定Service里的特定的Characteristic进行读写操作。每个Service和Characteristic都有一个唯一的UUID与之对应。在开发BLE应用和智能硬件时，两端的开发者需要协商好对应的UUID。 profile profile可以理解为一种规范，一个标准的通信协议，它存在于从机中。蓝牙组织规定了一些标准的profile，例如HID OVER GATT ，防丢器 ，心率计等。每个profile中会包含多个service，每个service代表从机的一种能力(功能)。 service service可以理解为一个服务，在ble从机中，通过有多个服务，例如电量信息服务、系统信息服务等，每个service中又包含多个characteristic特征值。每个具体的characteristic特征值才是ble通信的主题。比如当前的电量是80%，所以会通过电量的characteristic特征值存在从机的profile里，这样主机就可以通过这个characteristic来读取80%这个数据 characteristic characteristic特征值，ble主从机的通信均是通过characteristic来实现，可以理解为一个标签，通过这个标签可以获取或者写入想要的内容。 uuid UUID，统一识别码，我们刚才提到的service和characteristic，都需要一个唯一的uuid来标识 总结一下，每个从机都会有一个叫做profile的东西存在，他们都是由一些service组成，然后每个service又包含了多个characteristic，主机和从机之间的通信，均是通过characteristic来实现。 组成 硬件：微处理器存储器（寄存器、内存、外存）I/O接口、输入输出设备等等 软件：嵌入式操作系统BSP——board support package板级支持包应用软件 内存的访问方式 内存通过CPU的地址总线来寻址定位，然后通过CPU数据总线来读写。 CPU的地址总线的位数是CPU设计时确定的，因此一款CPU所能寻址的范围是一定的，而内存是需要占用CPU的寻址空间的。 内存与CPU的这种总线式连接方式是一种直接连接，优点是效率高访问快，缺点是资源有限，扩展性差。 io的访问方式 IO指的是与CPU连接的各种外设。 CPU访问各种外设有2种方式：一种是类似于访问内存的方式，即把外设的寄存器当作一个内存地址来读写，从而以访问内存相同的方式来操作外设，叫IO与内存统一编址方式；另一种是使用专用的CPU指令来访问某种特定外设，叫IO与内存独立编址。 冯诺依曼结构与哈佛结构 程序和数据都放在内存中，且不彼此分离的结构称为冯诺依曼结构。譬如Intel的CPU均采用冯诺依曼结构。冯诺依曼结构中程序和数据不区分的放在一起，因此安全和稳定性是个问题，好处是处理起来简单。 程序和数据分开独立放在不同的内存块中，彼此完全分离的结构称为哈佛结构。譬如大部分的单片机（MCS51、ARM9等）均采用哈佛结构。哈佛结构中程序（一般放在ROM、flash中）和数据（一般放在RAM中）独立分开存放，因此好处是安全和稳定性高，缺点是软件处理复杂一些（需要统一规划链接地址等） 寄存器 SoC中有2类寄存器：通用寄存器和SFR 1.通用寄存器（ARM中有37个）是CPU的组成部分，CPU的很多活动都需要通用寄存器的支持和参与。2.SFR（special function register，特殊功能寄存器）不在CPU中，而存在于CPU的外设中，我们通过访问外设的SFR来编程操控这个外设，这就是硬件编程控制的方法。 CPU可以像访问内存一样访问寄存器 寄存器是CPU的硬件设计者制定的，目的是留作外设被编程控制的“活动开关” 正如汇编指令集是CPU的编程接口API一样，寄存器是外设硬件的软件编程接口API。使用软件编程控制某一硬件，其实就是编程读写该硬件的寄存器。 寄存器中每个bit位都有特定含义，因此编程操作时需要位操作。 单个寄存器的位宽一般和CPU的位宽一样，以实现最佳访问效率 3.编程访问寄存器的方法 1234567//汇编ldr r1, =0xE0200280str r0, [r1]mov r0, #0//C语言int *p = (int *)0x30008000;*p = 16;]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[嵌入式知识梳理]]></title>
    <url>%2Fpassages%2F2020-04-30-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[较为全面梳理嵌入式知识 嵌入式 嵌入式概念 ARM公司 指令集架构、arm内核、芯片型号 开发板组成 寄存器 内部寄存器 运行模式 异常向量表 外部寄存器 独立编址&amp;统一编址 看门狗 存储器 存储器概念 RAM SRAM（Static RAM，静态随机存取存储器） DRAM（Dynamic RAM，动态随机存取存储器） SDRAM（Synchronous DRAM，同步动态随机存取存储器） DDR SDRAM（Double Data Rate二倍速率同步动态随机存取存储器） DDRII /DDR2(Double Data Rate 2，第二代同步双倍速率动态随机存取存储器) DDR3(Double Data Rate 3，第三代同步双倍速率动态随机存取存储器) DDR4(Double Data Rate 4，第四代同步双倍速率动态随机存取存储器) IRAM（internal RAM，内部随机存取存储器） ROM(READ Only Memory，只读存储器) MASK ROM（掩模型只读存储器） PROM（Programmable ROM，可编程只读存储器） EPROM（Erasable Programmable，可擦可编程只读存储器） EEPROM（Electrically Erasable Programmable，电可擦可编程只读存储器） Flash Memory（快闪存储器） NOR Flash（Not OR Flash） NAND Flash（Not AND Flash） IROM（internal ROM，内部只读存储器） 不同系统的存储器配置 ARM汇编 机器指令、伪指令、宏指令 ARM汇编指令 MOV STR LDR 跳转指令 B BL Thumb指令 5G 嵌入式嵌入式概念嵌入式即嵌入式系统，IEEE（美国电气和电子工程师协会）对其定义是用于控制、监视或者辅助操作机器和设备的装置，是一种专用的计算机系统。国内普遍认同的嵌入式系统定义是以应用为中心，以计算机技术为基础，软硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗等严格要求的专用计算机系统；从应用对象上加以定义来说，嵌入式系统是软件和硬件的综合体，还可以涵盖机械等附属装置。 嵌入式系统作为装置或设备的一部分，它是一个控制程序存储在ROM中的嵌入式处理器控制板。事实上，所有带有数字接口的设备，如手表、微波炉、录像机、汽车等，都使用嵌入式系统，有些嵌入式系统还包含操作系统，但大多数嵌入式系统都是由单个程序实现整个控制逻辑。 嵌入式这个概念很广泛，可裁剪定制的电路都可称之为嵌入式。就算是你现在用的电脑，如果把摄像头，音频之类的去掉，按照你的要求定制个电脑，其实也可以叫嵌入式。在这种设备上运行的软件就叫嵌入式软件。 ARM公司ARM全称为Advanced RISC Machine（机翻：先进的RISC机器），关键就在于RISC这个简写上面。当时的主流是复杂指令集运算(Complex Instruction Set Computing，CISC)，英特尔公司就是采用复杂指令集的方式来制作CPU。好处是使用较少指令就能执行任务，能够完成许多复杂的功能，速度更快。坏处是20%的指令被使用频率是80%，80%的指令被使用的频率是20%。而且当时的复杂指令集的功耗比精简指令集高。 ARM公司当时采用精简指令集运算(Reduced Instruction Set Computing，RISC)据说是因为没钱，因为设计复杂指令集需要比较高的技术和人才，同时他们也没能力像英特尔一样自己生产芯片，所以当时就是设计指令集和芯片方案，到后来因为精简指令集的优势显现，所以ARM公式越做越好。好处是每条指令使用频率都差不多，每条指令长度一样（复杂指令集可以不一样长度），容易进行优化（优化得好可能比复杂指令集还快）；功耗低（具体原因大家可以百度）。坏处是因为都是精简指令，许多功能需要工程师自己写代码实现（可能对ARM是好处，不用自己写指令），同样的功能，精简指令集需要的指令比复杂指令集需要的指令多。 英特尔在电脑领域的地位很高，因为对于电脑来说，功耗和性能，其实是性能比较重要。而ARM公司能够活下来的原因是嵌入式，嵌入式设备追求的恰好是低功耗，低成本。所以这就是为什么一说到嵌入式，都不得不说到ARM的原因。但是到了今天，情况也有变化，比如ARM也有高功耗的芯片设计方案，英特尔也有低功耗的电池省电方案。 指令集架构、arm内核、芯片型号嵌入式有两个架构，一个是指令集架构（可以理解为不同指令集架构的指令不一样），另一个是内核（可以理解为芯片的设计方案）。通常指令集架构和内核有对应关系。下图第一列为指令集架构，第二列为内核。 片上系统(System-on-a-Chip，Soc)就是尽可能将多的东西集成到一个芯片里面，比如说存储器，好处就是体积小功耗低。实际上今天很多被叫成CPU的芯片其实是Soc芯片，但是并不影响交流，只要知道哪颗芯片就行，就像手机有的CPU也算Soc，但是一般都记芯片的型号，不纠结是CPU芯片还是Soc芯片（如：高通骁龙820其实是Soc芯片，但是大家都习惯叫CPU）。 开发板组成嵌入式产品往往不是一家公司单独设计出来的，一方面大部分公司技术不到位，另一方面别人的东西比较成熟，成本低。这里我举个例子，随便网上找的粤嵌的嵌入式开发板（粤嵌打钱！） 更多内容可以查看下面链接指令集架构、arm内核、SoC、处理器、CPU、GPU等的关系 寄存器寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。寄存器是CPU的组成部分，因为在CPU内，所以CPU对其读写速度zd是最快的，不需要IO传输。但同时也决定了此类寄存器数量非常有限，有限到几乎每个存储都有自己的名字，而且有些还有多个名字（R15和PC指的是同一个寄存器）。 寄存器的作用主要是：可将寄存器内的数据进行算术及逻辑运算；存于寄存器内的地址可用来指向内存的某个位置，即间接寻址；可以用来读写数据到电脑的周边设备。 内部寄存器这里讲的内部寄存器为采用ARM7内核（芯片设计方案）的内部寄存器。不同内核的芯片可能内部寄存器有所不同。 ARM7微处理器内含37个32位内部寄存器（Cortex-A8微处理器有40个32位长的寄存器），其中31个为通用寄存器，6个为状态寄存器。 (1) R0～R12：均为32位通用寄存器，用于数据操作。绝大多数16位Thumb指令只能访问R0～R7，而32位Thumb-2指令可以访问所有寄存器。（平时就是用来装一下数据或者用来进行间接寻址，和学的汇编差不多，但是arm汇编和汇编有些差别，后面讲arm汇编会讲到） (2)R13（SP）堆栈指针：堆栈指针的最低两位永远是0，这意味着堆栈总是4字节对齐的。（堆栈，一般用来存放函数参数，从栈顶开始放起，放进之后SP减4） (3)R14（LR）程序连接寄存器：当呼叫一个子程序时，由R14存储返回地址。（当使用bl指令跳转的时候，本来将要执行的指令地址会自动放进lr寄存器，要跳转的子程序地址放进pc寄存器，然后程序就跳到pc寄存器指向的地址，然后当你想要返回的时候，就可以用mov pc,lr或mov r15,r14来返回） (4)R15（PC）程序计数器：指向当前的程序地址，如果修改它的值，就能改变程序的执行流。（其实就是相当于一个指针，指向下一条命令） (5)6个状态寄存器（1个CPSR、5个SPSR），用以标识CPU的工作状态及程序的运行状态，均为32位。 运行模式要了解CPSR、SPSR寄存器，需要知道运行模式，这两个寄存器就是要根据运行模式放状态进去的。ARM微处理器支持7种运行模式。 用户模式（User），快速中断模式（FIQ），普通中断模式（IRQ），管理模式（Svc），数据访问中止模式（Abort），未定义指令中止模式（Und），系统模式（Sys）。 在用户模式下，应用程序不能够访问一些受操作系统保护的系统资源，应用程序也不能直接进行处理器模式的切换。除用户模式之外的其他6种处理器模式称为特权模式。在这些模式下，程序可以访问所有的系统资源，也可以任意地进行处理器模式的切换。系统模式可以访问所有的系统资源，也可以直接进行处理器模式切换。除系统模式外，其他5种特权模式又称异常模式。主要是在外部中断或者程序执行非法操作时会触发。 在每一种处理器模式下有一组相应的寄存器，上图中，每个模式下面都写了寄存器的名字，除了用户模式和系统模式都只能访问17个寄存器之外，其他模式都可以访问18个寄存器（模式下面没写的就不能访问）。 ①用户模式和系统模式可以访问的寄存器一模一样。 ②R0-R7在所有模式都一样，用的都是同样的寄存器。 ③到了R8-R12，快速中断模式却格格不入，据说是切换模式的时候R1-R12的值都会被保存（备份）起来，而快速中断比外部中断快的一部分原因就是少保存5个寄存器的值。 ④请注意，虽然图上面写着R8_fiq，但是实际上每个模式下面都是清一色的R0-R15，每个模式下的R8都叫R8，只不过这里为了区分用不同名字。 ⑤R13（sp）、R14（lr）在异常模式下面都是用了新的寄存器，好处就是不用另外保存这两个寄存器的内容，直接变换模式。 ⑥R15（pc）指向要执行的代码，只要一个就行了。 ⑦CPSR和SPSR就是用来存放运行模式的状态的，CPSR放的是当前的运行模式的状态，当从用户模式切换到异常模式的时候，CPSR就要修改，但是改之前先把原来的值放进SPSR里面，到时候要切换回去的时候，就能根据SPSR返回。 更详细内容可以查看ppt：第2章-嵌入式微处理器（54-57） 异常向量表为什么ppt里面异常向量会和寄存器放在一起，其实也是有关联的，因为通常是异常产生导致了运行模式的切换（切换到异常模式），既然产生了异常，就要解决异常，解决的方法就放在异常向量表里。 当异常产生时，系统会自动找到相应的异常向量地址，地址里面并不是指令，而是另一个地址（类似指针，指向其他地址），通过取异常向量地址里面的地址去执行相应的指令（套娃警告），因为有的异常不可能只用一条指令就可以处理完（0x00000000-0x00000003四个字节共32位只能放一条32位指令或者一个32位地址）。而快速中断之所以放在最后，是因为后面可以直接就接上要执行的代码，根本不用跳转，所以快速中断的快速也体现在这个地方。 外部寄存器有内部寄存器，当然就有外部寄存器，不过一般外部寄存器也叫外设寄存器，外部寄存器虽然也用于存放数据，但是它保存的数据具有特殊的用途。每个外设都是通过读写其寄存器来控制的。 外设寄存器也称为I/O端口，通常包括：控制寄存器（对外部设备进行控制）、状态寄存器（反映了外部设备的工作状态或方式）和数据寄存器（CPU与外部设备交换数据）三大类。 和内部寄存器不一样的是，外设寄存器有地址，通常也是根据地址，给外设寄存器里面写值来控制外设。至于为什么内部寄存器直接写名字就行，而外部寄存器需要找地址，是因为外部寄存器太多了，一一“命名”会浪费空间，我们在ppt里面看到的那些花里胡哨的名称其实是厂家写在数据手册里面的，汇编代码直接写这些名称电脑是识别不了的，要查表才能清楚外部寄存器的功能和地址。 独立编址&amp;统一编址CPU的地址总线的位数在设计的时候就已经确定，所以CPU的最大寻址空间是一定的。而内存是占用了CPU的寻址空间的。而CPU不仅要访问内存，还要访问各种外设（IO），对外设的访问，通常有两种方式。 一种是类似于访问内存，把外设的寄存器，当做一个内存地址来访问，从而可以像访问内存一样去访问外设，这种方式即是内存与外设统一的编址方式，称作统一编址（也称为“I/O内存”方式）。另一种是使用专用的CPU指令来进行访问特定的外设，称作独立编址（也称为“I/O端口”方式）。 外设与内存统一的编址方式，优点是编程简单，因为可以像访问内存一样去访问外设。缺点是IO也占用CPU的寻址空间（因为部分寻址空间用来寻找外设寄存器了，所以内存不能太大）。而独立编址的方式，优点是不占用CPU的寻址空间，但是CPU的构造比较复杂(因为额外的CPU指令需要对CPU进行额外的设计处理)。 英特尔的处理器采用的就是独立编址，ARM一般是统一编址。 看门狗看门狗（watch dog timer）在Soc芯片上，看门狗定时器。现实中因为一些外部因素，电子设备经常会死机（比如极端炎热、极端寒冷、工业复杂场合）。在这种情况下我们希望设备自动复位而不需要人工干预（无人值守）。所以设计了看门狗用来完成这个工作。看门狗其实是我们SoC内部的一个定时器，定好时间之后看门狗定时器会去计时，时间到之前必须去重新置位，如果没有进行置位操作，系统就会被强制复位。系统在正常工作时，系统软件会自动置位，所以看门狗定时器不会将系统复位。但是系统一旦故障，系统软件就无法置位，然后下一个周期就会自动复位（常用来检测设备卡不卡）。而这个定时器可以用我们上面讲到的外部寄存器来控制是否来开启它。 存储器存储器概念存储器单元实际上是时序逻辑电路的一种。 按存储器的读写功能分类只读存储器(ROM)：存储的内容是固定不变的，只能读出而不能写入的半导体存储器。随机读写存储器(RAM)：既能读出又能写入的半导体存储器。 按存储方式分类随机存储器：任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关。顺序存储器：只能按某种顺序来存取，存取时间与存储单元的物理位置有关。 按在计算机系统中的作用分类主存储器（内存）：用于存放活动的程序和数据，其速度高、容量较小、每位价位高。辅助存储器（外存储器）：主要用于存放当前不活跃的程序和数据，其速度慢、容量大、每位价位低。缓冲存储器：主要在两个不同工作速度的部件起缓冲作用。 ——百度百科 RAMRAM(Random Access Memory，随机存取存储器)RAM的特点是：电脑开机时，操作系统和应用程序的所有正在运行的数据和程序都会放置其中，并且随时可以对存放在里面的数据进行修改和存取。它的工作需要由持续的电力提供，一旦系统断电，存放在里面的所有数据和程序都会自动清空掉，并且再也无法恢复。 根据组成元件的不同，RAM内存又分为十八种，本篇推文只选取常见的和嵌入式相关的介绍。 SRAM（Static RAM，静态随机存取存储器）静态，指的是内存里面的数据可以长驻其中而不需要随时进行存取。每6颗电子管组成一个位存储单元，因为没有电容器，因此不断电即可正常运作（不用刷新），因此它可以比一般的动态随机处理内存处理速度更快更稳定，往往用来做高速缓存。（别问，问就是贵） DRAM（Dynamic RAM，动态随机存取存储器）这是最普通的RAM，一个电子管与一个电容器组成一个位存储单元，DRAM将每个内存位作为一个电荷保存在位存储单元中，用电容的充放电来做储存动作，但因电容本身有漏电问题，因此必须每几微秒就要刷新一次（这就叫动态），否则数据会丢失。存取时间和放电时间一致，约为2 ~ 4ms。因为成本比较便宜，通常都用作计算机内的主存储器。 经过多年的发展，DRAM也有了许多船新的版本，同样也只介绍一部分。 SDRAM（Synchronous DRAM，同步动态随机存取存储器）这是一种与CPU实现外频Clock同步的内存模式，一般都采用168Pin的内存模组，工作电压为3.3V。所谓clock同步是指内存能够与CPU同步存取资料，这样可以取消等待周期，减少数据传输的延迟，因此可提升计算机的性能和效率。通常DRAM是有一个异步接口的，这样它可以随时响应控制输入的变化。而SDRAM有一个同步接口，在响应控制输入前会等待一个时钟信号，这样就能和计算机的系统总线同步。 接下来，也是套娃时间，SDRAM经过发展，也有了新技术。 DDR SDRAM（Double Data Rate二倍速率同步动态随机存取存储器）作为SDRAM的换代产品，它具有两大特点：其一，速度比SDRAM有一倍的提高（这就叫double，二倍速率）；其二，采用了DLL（Delay Locked Loop：延时锁定回路）提供一个数据滤波信号。这是目前内存市场上的主流模式。 DDRII /DDR2(Double Data Rate 2，第二代同步双倍速率动态随机存取存储器)由JEDEC(电子设备工程联合委员会)进行开发的新生代内存技术标准，它与上一代DDR内存技术标准最大的不同就是，虽然同是采用了在时钟的上升/下降延同时进行数据传输的基本方式，但DDR2内存却拥有两倍于上一代DDR内存预读取能力(即：4bit数据读预取)。换句话说，DDR2内存每个时钟能够以4倍外部总线的速度读/写数据，并且能够以内部控制总线4倍的速度运行。 DDR3(Double Data Rate 3，第三代同步双倍速率动态随机存取存储器)DDR3和DDR2一样没有增加工作频率，继续提升数据传输位宽变为8bit，为DDR2两倍，因此也在同样工作频率下达到更高带宽。 DDR4(Double Data Rate 4，第四代同步双倍速率动态随机存取存储器)DDR4相比DDR3最大的区别有三点：16bit预取机制（DDR3为8bit），同样内核频率下理论速度是DDR3的两倍；更可靠的传输规范，数据可靠性进一步提升；工作电压降为1.2V，更节能。 下面是另一个概念（JOJO，我不套娃啦），IRAM不是某种存储器，而且某些存储器的总称。 IRAM（internal RAM，内部随机存取存储器）看名字就知道，集成在一块芯片（CPU或者Soc）里面的RAM就叫IRAM，是一个电子产品技术。有集成DRAM的，也有集成SRAM的。嵌入式设备一般集成SRAM到芯片里面，因为SRAM成本高，往往嵌入式只会使用很小的容量，也就更容易集成到芯片里面。 速度快+通电直接使用（不用初始化）+成本高，鸡贼的设计师想出了鸡贼的方案（对于嵌入式开发板）。通电直接使用，代表一通电就能运行代码，而DRAM需要用代码来初始化。目前通电就能运行代码的就只有SRAM（RAM）和NOR Flash（ROM）。​但是一断电SRAM里面的代码就丢失，这个时候就要用到ROM的NOR Flash了，ROM断电不丢失，其中的NOR Flash通电就能使用，所以就先将NOR Flash通电，运行里面的代码，这个代码的效果是将外存的内容放到SRAM去运行，详细的情况在后面会讲到，这些器件的物理特性正是嵌入式启动如此复杂的原因。 ROM(READ Only Memory，只读存储器)ROM是线路最简单半导体电路，通过掩模工艺，一次性制造，在元件正常工作的情况下，其中的代码与数据将永久保存，并且不能够进行修改。一般应用于PC系统的程序码、主机板上的 BIOS (基本输入/输出系统Basic Input/Output System)等。它的读取速度比RAM慢很多。 根据组成元件的不同，ROM分为五种，下面都会列出来，但是最重要的是Flash，其他看看就行。 MASK ROM（掩模型只读存储器）制造商为了大量生产ROM内存，需要先制作一颗有原始数据的ROM或EPROM作为样本，然后再大量复制，这一样本就是MASK ROM，而烧录在MASK ROM中的资料永远无法做修改。它的成本比较低。 PROM（Programmable ROM，可编程只读存储器）这是一种可以用刻录机将资料写入的ROM内存，但只能写入一次，所以也被称为“一次可编程只读存储器”(One Time Progarmming ROM，OTP-ROM)。PROM在出厂时，存储的内容全为1，用户可以根据需要将其中的某些单元写入数据0(部分的PROM在出厂时数据全为0，则用户可以将其中的部分单元写入1)， 以实现对其“编程”的目的，这种是早期的产品，现在已经不可能使用了。 EPROM（Erasable Programmable，可擦可编程只读存储器）这是一种具有可擦除功能，擦除后即可进行再编程的ROM内存，写入前必须先把里面的内容用紫外线照射它的IC卡上的透明视窗的方式来清除掉，也就是通过紫外光的照射擦出原先的程序。这一类芯片比较容易识别，其封装中包含有“石英玻璃窗”，一个编程后的EPROM芯片的“石英玻璃窗”一般使用黑色不干胶纸盖住， 以防止遭到阳光直射。 EEPROM（Electrically Erasable Programmable，电可擦可编程只读存储器）功能与使用方式与EPROM一样，不同之处是清除数据的方式，它是以约20V的电压来进行清除的。另外它还可以用电信号进行数据写入。这类ROM内存多应用于即插即用（PnP）接口中。 Flash Memory（快闪存储器）这是一种可以直接在主机板上修改内容而不需要将IC（芯片）拔下的内存，当电源关掉后储存在里面的资料并不会流失掉，在写入资料时必须先将原本的资料清除掉，然后才能再写入新的资料（Flash擦除只能从1翻转到0，无法从0翻转到1。擦除过程就是将flash中的某一个扇区全写0xFFFFFFF，再写入数据。），缺点为写入资料的速度太慢。它结合了ROM和RAM的长处，不仅具备电子可擦出可编程（EEPROM）的性能，还不会断电丢失数据。在过去的20年里，嵌入式系统一直使用ROM（EPROM）作为它们的存储设备，然而近年来Flash全面代替了ROM（EPROM）在嵌入式系统中的地位。 大家发现没，虽然后来新的存储器都分别属于RAM和ROM这两种存储器，但是很明显有很多特性和最初的RAM、ROM已经不同了，好像违反了“设定”，我觉得这个其实有点像版本更新，有的地方继承了之前的属性，有的地方则进行了改良。所以我们看到书上的ROM是只读的，而我们的硬盘是ROM，那我们的硬盘怎么写进数据。看到上面的介绍，你的疑惑可能就得到了解决。然后，下面就是Flash的套娃了，同样，它也有很多种，这里只讲常见的或者与嵌入式相关的。 NOR Flash（Not OR Flash）NOR Flash是一种非易失闪存技术，是Intel在1988年创建，里面的单元是按照所谓或非的方式连起来的。NOR Flash 的特点是芯片内执行（XIP ，eXecute In Place），这样应用程序可以直接在Flash闪存内运行，不必再把代码读到系统RAM中，也可以替代SRAM。NOR 的传输效率很高，在1 ~ 4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响到它的性能。 NAND Flash（Not AND Flash）NAND Flash是也一种非易失闪存技术，1989年，东芝公司发表了NAND flash结构，强调降低每比特的成本（便宜），更高的性能，并且像磁盘一样可以通过接口轻松升级，里面的单元是按照所谓与非的方式连起来的，所用的线比NOR Flash少，但是性能不如NOR Flash。NAND Flash没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的Flash比较廉价。用户不能直接运行NAND Flash上的代码。NAND Flash是一种存储芯片，要使用它需要特殊的系统接口。 这些最早出现的、最原始的Flash颗粒组成芯片（NandFlash、NorFlash），芯片中只是对存储单元做了最基本的读写接口，要求开发板的SoC来提供Flash读写的控制器以和Flash进行读写时序。 缺陷：1、读写接口时序比较复杂。2、内部无坏块处理机制，需要SoC自己来管理Flash的坏块；3、各家厂家的Flash接口不一致，甚至同一个厂家的不同型号、系列的Flash接口都不一致，这就造成产品升级时很麻烦。 NandFlash分MLC（Multi Level Cell，多层单元）和SLC（Single Level Cell，单层单元）两种。SLC技术比较早，可靠性高，缺点是容量不大（贵，一般SLC Nand都是512MB以下）；MLC技术比较新，不成熟，可靠性差，优点是容量可以做很大很便宜，现在基本都在发展MLC技术。下面是NAND Flash的套娃。 iNAND &amp; OneNAND基于NAND（iNAND可以将内置的MLC FLASH模拟成为为SLC），SanDisk公司研发了iNAND存储芯片，可以简单的看成SD卡或MMC卡芯片化。优点：提高性能减少SOC的工作量，节约SOC资源；读写速度快；产品更可靠稳定iNAND内置掉电保护；降低系统成本等。 三星公司研发了OneNAND存储芯片，既实现NOR Flash的高速读取速度，又保留了Nand Flash的大容量数据存储的优点。OneNAND和Flex-OneNAND是融合存储器，将NAND内核，SRAM，纠错引擎和逻辑电路集成在具有NOR接口的单个​​芯片中。 下面为使用NAND Flash芯片的一些产品，外加了控制芯片、接口等，严格来说其实并不能归为NAND Flash。 SD卡（Secure Digital Memory Card）SD存储卡是一种基于半导体快闪记忆器的新一代记忆设备，由于它体积小、数据传输速度快、可热插拔等优良的特性，被广泛地于便携式装置上使用，例如数码相机、平板电脑和多媒体播放器等。SD卡是由松下电器、东芝和SanDisk联合推出。SD卡是将NAND Flash芯片叠加到一起，扩大容量，同时添加管理系统芯片。Nand Flash是不可以直接使用的,需要驱动程序，SD则自带驱动程序。通常数码相机用的那种大卡就是SD卡。SD卡是遵照SD规范来发布的。这些规范规定了SD卡的读写速度、读写接口时序、读写命令集、卡大小尺寸、引脚个数及定义。这样做的好处就是不同厂家的SD卡可以通用。 SD卡是基于MMC卡（Multi-Media Card，多媒体卡）发展的（MMC卡可以被SD读卡器读写，而SD卡不可以被MMC读卡器读写。），MMC卡是基于SM卡（Smart Media，智能媒体卡）发展的，有兴趣可以去百度。 Micro SD卡（Micro SD Card）Micro SD Card，原名Trans-flash Card（TF卡），2004年正式更名为Micro SD Card，由SanDisk（闪迪）公司发明，主要用于移动电话。是采用SanDisk（闪迪）的NAND MLC技术以及控制器技术。通常手机用的那种小卡就是Micro SD卡。 eMMC(embedded multi media card)eMMC为MMC协会所订立的、主要是针对手机或平板电脑等产品的内嵌式存储器标准规格。eMMC的一个明显优势是在封装中集成了一个控制器，它提供标准接口并管理内存，使得是手机厂商就能专注于产品开发的其他部分，并缩短向市场推出产品的时间，eMMC=NAND flash+controller+standard interface。 SSD（Solid State Disk或Solid State Drive）固态硬盘的存储介质分为两种，一种是采用闪存（FLASH芯片）作为存储介质，另外一种是采用DRAM作为存储介质。 基于闪存类：基于闪存的固态硬盘（IDEFLASH DISK、Serial ATA Flash Disk）：采用Flash芯片作为存储介质，这也是通常所说的SSD。它的外观可以被制作成多种模样，例如：笔记本硬盘、微硬盘、存储卡、U盘等样式。这种SSD固态硬盘最大的优点就是可以移动，而且数据保护不受电源控制，能适应于各种环境，适合于个人用户使用。 SSD除了使用Flash存储介质之外，还有主控芯片，内部包含存储算法、数据传输算法等等，也有不同的接口。由于固态硬盘技术与传统硬盘技术不同，所以产生了不少新兴的存储器厂商。厂商只需购买NAND存储器，再配合适当的控制芯片，就可以制造固态硬盘了。新一代的固态硬盘普遍采用SATA-2接口、SATA-3接口、SAS接口、MSATA接口、PCI-E接口、NGFF接口、CFast接口、SFF-8639接口和M.2 NVME/SATA协议。 内部由Nand的存储颗粒构成（iNand、MoviNand、SSD），再集成了块设备管理单元，综合了SD卡为代表的各种卡的优势和原始的NandFlash芯片的优势：有统一的接口标准（包括引脚定义、物理封装、接口时序）；与原始的Nand一样，以芯片的方式来发布而不是以卡的方式；内部内置了Flash管理模块，提供了诸如坏块管理等功能，让Nand的管理容易了起来。 基于DRAM类：采用DRAM作为存储介质，应用范围较窄。它仿效传统硬盘的设计，可被绝大部分操作系统的文件系统工具进行卷设置和管理，并提供工业标准的PCI和FC接口用于连接主机或者服务器。应用方式可分为SSD硬盘和SSD硬盘阵列两种。它是一种高性能的存储器，而且使用寿命很长，美中不足的是需要独立电源来保护数据安全。DRAM固态硬盘属于比较非主流的设备。 至于HHD（机械硬盘）和SSD（固态硬盘）走的路线不一样，感兴趣的可以看这个链接的视频： 硬盘的发展史，你都了解吗？ IROM（internal ROM，内部只读存储器）集成到Soc里面的ROM都叫IROM，嵌入式设备一般集成NorFlash到芯片里面。 鸡贼的设计师这个时候又跳出来了，NOR Flash可以直接运行代码，那是不是可以直接用NOR Flash来初始化DRAM？ 是的，其实一般的单片机和电脑都是用NOR Flash来初始化其他内存和硬盘的，至于初始化是什么，其实就是初始化一下堆栈、寄存器，开启时钟，嵌入式还要开启看门狗。​因为成本高，NOR Flash很小，不能装下操作系统，所以NOR Flash的代码负责把硬盘的代码放到内存里面，然后内存再运行。 嵌入式系统的做法不同，因为之前第一篇推文就写过，嵌入式的开发板芯片、核心板、底板可能是不同厂商设计的。设计芯片的厂商就单单设计一个芯片，里面就IRAM和IROM可以放，如果只有IROM是不好的。 因为NOR Flash有一个缺点，前面讲过的，读写时间长。擦除NOR器件时是以64～128KB的块进行的，执行一个写入/擦除操作的时间为5s，与此相反，擦除NAND器件是以8～32KB的块进行的，执行相同的操作最多只需要4ms。因为嵌入式经常跑一些比较小的程序，不一定要启动操作系统。代码比较小，直接放进NOR Flash运行比较方便，也不用启动DRAM。但是因为放进NOR Flash的速度实在是太慢了，所以用一个IRAM（SRAM）来实现这个功能。 开机后，NOR Flash启动IRAM启动看门狗之类的初始化，然后NOR Flash将外存相应的代码2放进SRAM，这个外存可以是NAND，也可以是SD卡，或者直接用usb端口/串口端口下载数据到SRAM，不用NOR Flash找（电脑传输数据），这个就是代码1的功能，代码1放在NOR Flash里面，也在NOR Flash里面运行。如果是比较小的代码，通常用usb端口或者串口端口来下载（当时粤嵌实验下载代码用的就是串口端口），直接下载到IRAM，然后运行，但是断电之后就会丢失数据（所以每次实验都要重新下载代码）。 如果是启动操作系统的话一般NOR Flash启动IRAM，IRAM启动NAND和DRAM，然后DRAM运行操作系统。代码1在NOR Flash里面，也在NOR Flash里面执行；代码2在NAND Flash里面，但是被NOR Flash放到SRAM里面执行；操作系统在NAND Flash里面，被SRAM放到DRAM里面执行。 注意：为什么要放来放去，一个是代码只能在NOR Flash、IRAM、DRAM里面运行，NOR Flash太慢了，DRAM第二阶段初始前不能使用。另一个是代码只能放在NOR Flash（启动代码1）和NAND Flash（启动代码2、操作系统）里面，等到要用的时候就从这两个拿出来给SRAM和DRAM运行。 NAND Flash不能运行代码，IRAM是断电丢失数据，所以只能从NAND Flash搬代码到IRAM去运行，然后初始化DRAM，这个时候DRAM就能运行代码，于是IRAM又将NAND的操作系统搬过去，然后DRAM运行代码，就能启动操作系统。 至于为什么第一副图IRAM没有去NAND Flash取代码，是因为嵌入式开发板有好几种启动模式，当你拨动一个开关的时候，如果是usb模式（代码1负责识别），IRAM就不会去NAND Flash找代码；如果是SD卡/emmc模式，IRAM就会去找SD卡或者NAND。 不同系统的存储器配置现在的电脑：很小容量的BIOS（NOR Flash）+ 很大容量的硬盘（SSD或者HDD）+ 大容量的DRAM（DDR3或者DDR4）。 一般的单片机：很小容量的NOR Flash + 很小容量的SRAM。 嵌入式系统：SoC内置IRAM（SRAM） + SoC内置IROM（NOR Flash）+外接的大容量Nand Flash + 外接大容量DRAM（DDR2） 。 更多内容可以查看下面链接存储器分类及定义5种传统+3种新型存储器大剖析：我国能否打破巨头垄断？ ARM汇编机器指令、伪指令、宏指令机器指令被处理器直接执行，伪指令和宏指令不能。机器指令包括ARM指令集和Thumb指令集（经常简称指令）； 伪指令是在源程序汇编期间，由汇编编译器处理。其作用是为汇编程序完成准备工作; 宏指令在程序中用于调用宏，宏是一段独立的程序代码；在程序汇编时，对宏调用进行展开，用宏体代替宏指令。 ARM指令和ARM伪指令之间的本质区别是：ARM指令有一一对应的机器码。ARM汇编器在汇编ARM指令时，每条ARM指令都有一条对应的机器码，这是固定的对应关系。 ARM伪指令没有一一对应的机器码。ARM汇编器在编译一条伪指令时，会使用一条或几条ARM指令的机器码来实现一条ARM伪指令的功能，在不同的上下文环境中，同样一条ARM伪指令汇编后得到的机器指令是不同的（机械指令编译成二进制文件是一样的，但放在不同位置的同样的伪指令编译出来的二进制代码是有可能不同的）。 ARM汇编指令ARM汇编指令很多，但是真正常用的不是很多。比较有用的是MOV、B、BL、LDR、STR mov r1, #0x53000000 ;立即数寻址方式mov r2, #0x0str r2, [r1] MOVMOV掌握几个寻址方式就可以了，而且ARM的立即数寻址方式，立即数要求以“#”作前缀，对于十六进制的数，还要求在#后面加上0x或者&amp;。 STRSTR是比较重要的指令了，跟它对应的是LDR。ARM指令集是加载/存储型的，也就是说它只处理在寄存器中的数据。那么对于系统存储器的访问就经常用到STR和LDR了。STR是把寄存器上的数据传输到指定地址的存储器（内存）上。格式： STR(条件) 源寄存器，&lt;存储器地址&gt;比如 STR R0, [R1] ，意思是R0-&gt; [R1]，它把源寄存器写在前面，跟MOV、LDR相反。 LDRLDR就是把数据从存储器传输到寄存器上。而且有个伪指令也是LDR。 ldr r2,#0x55aa ;LDR指令ldr r2,=0x55aa ;LDR伪指令 作为伪指令的时候，LDR的格式如下：LDR 寄存器，=数字常量/Label 它的作用是把一个32位的地址或者常量调入寄存器。大家可能会问，LDR指令也可以吧？应该是这样的。不过，LDR是伪指令，编译时编译器会处理它。规则如下：如果该数字常量在MOV指令范围内，汇编器会把这个指令作为MOV（变成MOV指令）。如果不在MOV范围中，汇编器把该常量放在程序后面，用LDR来读取（变成LDR指令），PC和该常量的偏移量不能超过4KB。 伪指令LDR{cond} register, ={expr|label-expr}expr为32位常量。编译器根据expr的取值情况来处理这条伪指令：1、当expr表示的地址没有超过mov或mvn指令中地址的取值范围时，编译器用合适的mov指令或mvn指令代替该LDR伪指令。2、当expr表示的地址超过了mov或mvn指令中地址的取值范围时，编译器将该常数放在缓冲区中，同时用一条基于PC的LDR指令读取该常数。 通过上面两种可以得出伪指令LDR和ARM指令LDR的区别，具体使用时，可以不用考虑二者的区别，由编译器决定的，你只要清楚它的功能就行。 跳转指令ARM有两种跳转方式。（1）mov pc &lt;跳转地址&gt;这种向程序计数器PC直接写跳转地址，能在4GB连续空间内任意跳转。（2）通过 B BL BLX BX 可以完成在当前指令向前或者向后32MB的地址空间的跳转（为什么是32MB呢？寄存器是32位的，此时的值是24位有符号数，所以32MB）。 BB是最简单的跳转指令。要注意的是，跳转指令的实际值不是绝对地址，而是相对地址——是相对当前PC值的一个偏移量，它的值由汇编器计算得出。 BLBL非常常用。它在跳转之前会用寄存器LR(R14)中保存PC的当前内容。BL的经典用法如下： bl NEXT ; 跳转到NEXT……NEXT: ;代码……mov pc, lr ;从子程序返回 Thumb指令ARM体系结构还支持16位的Thumb指令集。Thumb指令集是ARM指令集的子集，它保留了32位代码优势的同时还大大节 省了存储空间。由于Thumb指令集的长度只有16位，所以它的指令比较多。它和ARM各有自己的应用场合。对于系统性能有较高要求，应使用32位存储系 统和ARM指令集；对于系统成本和功耗有较高要求，应使用16位存储系统和ARM指令集。 更多内容可以查看下面链接ARM汇编指令集汇总 5G其实说实话，我对5G没什么了解，只知道G是generation，5G就是第5代通讯的意思，然后5G大致有三个发展方向，一个是速度快，第二个是延迟短，第三是广泛连接。 分别体现在eMBB（Enhanced Mobile Broadband，增强移动宽带）、uRLLC（Ultra-reliable and Low Latency Communications，超高可靠与低时延通信）、mMTC（大规模物联网）三个技术层面上。 eMBB发展的好处显而易见，能够快速传输数据，和中国9亿网民息息相关。 uRLLC发展的好处是什么？还有人会不会在想网速快就延迟短？其实，网速慢不代表延迟一定高，网速快不代表延迟低。具体原理不展开了，大家可以去百度一下。延迟短，就意味着能够接近实时。华为有个广告就是两个半架的钢琴：两个地方，每个地方半架钢琴，两个人一起演奏，声音传输到屏幕上几乎没有延迟。这个技术还可以用来进行远程医疗等。 mMTC发展的目标很明确了，就是物联网，广泛的连接，使得智能家居、甚至智能城市发展更加迅速。 想要了解更多，比如中国5G在面向消费者（5G手机）、运营商（基站设备）、网络架构等方面可以查看下面这两篇文章。 5G啊5G，你是不是只比4G多一G？中国5G的真正实力，终于有人说明白了！]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[x210开发板]]></title>
    <url>%2Fpassages%2F2020-02-05-x210%E5%BC%80%E5%8F%91%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[x210开发板 x210开发板arm裸机实验 基本概念 支持的外部存储器 x210使用的启动方式 刷机 sd卡刷机 usb刷机 开发板实验准备 sd卡下载 usb下载 实验01-led灯 基本概念 gpio 反汇编工具objdump 编程过程 实验项目 led灯-01-全亮 led灯-02-优化代码 led灯-03-部分点亮 led灯-04-闪烁 led灯-05-跑马灯 实验02-启动代码 基本概念 看门狗 c语言 设置栈 icache 重定位 sdram 时钟系统 实验项目 启动代码-01-watch dog timer 启动代码-02-设置栈 启动代码-03-icache 启动代码-04-重定位 启动代码-05-初始化sdram 启动代码-06-设置时钟 实验03-串口通信 基本概念 通信发展史 串口通信 编程过程 实验项目 串口通信-01-设置串口 串口通信-02-修改比特率 串口通信-03-移植printf 实验04-中断 基本概念 按键中断 轮询方式 中断体系 中断寄存器 编程过程 实验项目 中断-01-按键轮询 中断-02-移植printf 中断-03-按键中断 实验05-定时器 基本概念 定时器 pwm定时器 看门狗定时器 实时时钟rtc 实验项目 定时器-01-蜂鸣器 定时器-02-看门狗中断 定时器-03-看门狗复位 定时器-04-rtc定时器 实验06-sd卡启动 基本概念 sd卡的编程接口 s5pv210的sd卡启动详解 x210开发板的软开关按键问题 实验项目 sd卡启动-01-分散加载 实验07-nand nand基本概念 nandflash接口 nandflash控制器 inand基本概念 sd卡-inand操作 sd-inand代码分析 实验08-i2c 基本概念 i2c通信-芯片间通信 i2c通信时序 s5pv210的i2c控制器 x210板载gsensor介绍 I2C总线的通信流程 实验09-adc 基本概念 模拟量和数字量 adc主要相关概念 s5pv210的adc控制器 ad转换的编程 实验10-lcd显示器 基本概念 lcd的接口技术 lcd显示图像 lcd的六个主要时序参数 lcd显示的主要相关概念 s5pv210的lcd控制器 实验项目 lcd显示器-01-控制器初始化 lcd显示器-02-显示像素 lcd显示器-03-画线 lcd显示器-04-显示字符 lcd显示器-05-画图 lcd显示器-06-未完成事项 实验11-触摸屏 基本概念 输入类设备简介 电阻式触摸屏的原理 s5pv210的电阻触摸屏控制器 电容触摸屏的原理 ft5x06电容触摸IC简介 实验12-shell 基本概念 程序或操作系统的用户接口 实验项目 shell-01-输入回显 shell-02-移植 shell-03-标准命令集 shell-04-添加命令 shell-05-其他命令 shell-06-开机倒计时 shell-07-环境变量 x210开发板arm裸机实验 基本概念 镜像（Mirroring）一种文件存储形式，是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。可以把许多文件做成一个镜像文件，与GHOST等程序放在一个盘里用GHOST等软件打开后，又恢复成许多文件， 固件（firmware）所谓固件，就是文件，固化在存储介质上的文件，而文件，其实就是数据。嵌入式开发中，尤其是Linux开发，常见的方式是，从开发板上启动，会允许Uboot，然后Uboot去加载kernel内核，常用的kernel是uImage，然后Linux运行后，去加载根文件系统rootfs，常用的yaffs2文件系统。…………………………………………..前后系统运行所需要的文件，总的来说，就是这三个：Uboot，比如u-boot.binKernel，比如uImageRootfs，比如yaffs2.rootfs.arm而大家一直说的固件，在系统是Linux系统的情况下，常常就是指的是这些文件。 烧写所谓烧写，就是写数据，把文件（固件/数据）写到存储介质（Nand Flash, Nor Flash等）上。而对于烧写这个词，说法很多，常见的有：烧写=烧录=flash=编程=program=programming…………………………………………..更新固件，其实也指的是将新的固件烧写进去，即所谓更新固件，更新系统。 USB device:从硬件角度看就是一个带有usb client控制器的设备；从软件角度看，就是一个挂在usb总线上的一个普通意义上的设备，只不过它们的驱动是基于host驱动之上的。…………………………………………..USB host:USB主设备，可以从另外一个USB device中取得数据，包括USB host控制器3.0USB host协议。与USB device或USB slave相对应。…………………………………………..USB client:从硬件角度看就是指USB client 控制器，从软件角度看，就是指USB client协议，与USB host协议相对应。…………………………………………..USB OTG:On The Go，正在进行中的意思，也就是可以直接传输，就是可以从一个机器直接传到另一个机器中。…………………………………………..USB HUB：USB扩展/集线器，一种可以将一个USB接口扩展为多个（通常为4个），并可以使这些接口同时使用的装置。 NIC，Network Interface Card，网络接口卡，即网卡。 支持的外部存储器 X210有2个版本，Nand版和iNand版，分别使用Nand Flash和iNand为外部存储器。S5PV210共支持4个SD/MMC通道，其中通道0和2用作启动。X210开发板中SD/MMC0通道用于连接板载MMC，因此外部启动时只能使用SD/MMC2通道（注意通道3不能启动，通道0、1被隐藏）。见《S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf》中P6 x210使用的启动方式 外接的大容量Nand + 外接大容量DRAM + SoC内置SRAM。210内部有iROM和iRAM，因此启动时分两个阶段：内部启动阶段和外部启动阶段。对于内部启动阶段各种S5PV210的开发板都是相同的，对于外部启动阶段，不同开发板会有不同。以下是内部启动（iRom）带动外部启动（Nand、DRAM）。 s5pv210启动 210内置了一块96KB大小的SRAM（叫iRAM），同时还有一块内置的64KB大小的NorFlash（叫iROM）。210的启动过程大致是： 第一步：CPU上电后先从内部IROM中读取预先设置的代码（BL0），执行。这一段IROM代码首先做了一些基本的初始化（CPU时钟、关看门狗···）（这一段IROM代码是三星出厂前设置的，三星也不知道我们板子上将来接的是什么样的DRAM，因此这一段IROM是不能负责初始化外接的DRAM的，因此这一段代码只能初始化SoC内部的东西）；然后这一段代码会判断我们选择的启动模式（我们通过硬件跳线可以更改板子的启动模式），然后从相应的外部存储器去读取第一部分启动代码（BL1，大小为16KB）到内部SRAM。 第二步：从IRAM去运行刚上一步读取来的BL1（16KB），然后执行。BL1负责初始化NandFlash，然后将BL2读取到IRAM（剩余的80KB）然后运行 第三步：从IRAM运行BL2，BL2初始化DRAM，然后将OS读取到DRAM中，然后启动OS，启动过程结束。 ………………………………………….. 当我们自己写代码运行时，一般用usb下载到IRAM，这个时候IRAM有多大，我们就能运行多大的代码（96KB）；第二个方法是下载到sd卡，由NorFlash把里面的代码放到IRAM里面，但是NorFlash只选择前16KB的代码放进IRAM，因此需要注意代码文件的大小。 思路 因为启动代码的大小是不定的，有些公司可能96kb就够了，有些公司可能1MB都不够。三星的解决方案是：把启动代码分为2半（BL1和BL2），这两部分协同工作来完成启动。 BL0代码含义 关看门狗 初始化指令cache 初始化栈 初始化堆 初始化块设备复制函数device copy function 设置SoC时钟系统 复制BL1到内部IRAM（16KB） 检查BL1的校验和 跳转到BL1去执行 BL1代码含义 初始化NandFlash 将BL2读取到IRAM BL2代码含义 初始化DRAM 将OS读取到DRAM中 刷机嵌入式开发，很多用的是Linux系统，也有用WinCE和其他系统,Linux系统中，多数为bootloader+ kernel + rootfs的模式。其中，所用的bootloader，多为uboot。负责初始化硬件和设置好软件环境，然后加载kernel，运行kernel，kernel运行后，再去加载rootfs，之后就是你所看到的运行的Linux了。 在开发过程中，上述对应的文件每个系统都有差异，比如U-boot.bin，uImage，rootfs等，需要从PC上下载到Uboot的SDRAM，即内存中，然后再用对应命令或工具，将数据写入到某存储介质中。有时候也需要在发布产品之后，在系统运行的情况下，动态升级整个系统的固件的。 刷机需要将对应的文件，烧写到存储介质上，此时，有两种方法：一种是一步到位的方式，即直接通过某工具将文件写入到存储介质上。另外一种是两步到位的方式，先通过某种方式把文件下载到Uboot中，再通过Uboot中的命令，去把数据写入到存储介质上。…………………………………………..x210开发板启动有SD/MMC卡启动和USB启动和Uart启动（异步串行接口），通过OM pin选择启动介质，当OM pin（0-5）为101100时为SD/MMC卡启动，当OM pin（0-5）为101101为USB启动。 sd卡刷机 在Uboot中，把下载到内存中的固件，写入到存储介质（iNand）上 破坏iNand的uboot 将iNand卡的uboot分区清除（填写0）： ①将OM pin(0-5)拨为101100，0为gnd，1为vcc（vcc靠近核心板一侧），用usb转串口线连接电脑usb和开发板串口（默认Uart2,在两个接口之中远离核心板的为Uart2，另一个为Uart0），安装usb转串口驱动将usb模拟为串口（并且usb转串口线里面有芯片将usb协议转换成串口协议）。或者将串口线连接电脑串口和开发板串口，这样不需要驱动。 ②安装secureCRT（监视软件，按照说明破解），连接开发板串口的作用是将电脑作为控制台，为此需要软件。设置secureCRT，协议：Serial，接口，波特率：115200，数据流控制：全不选。3秒内按回车进入控制台。 ③在开发板的安卓环境下破坏iNand的uboot，在secureCRT，在linux和android系统下输入下面linux的dd命令，重启后显示错误即破坏成功。dd是Linux/UNIX下的一个非常有用的命令，作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 //将大小为512字节（bs=512）的0（if=/dev/zero）写到iNand（of=/dev/block/mmcblk0）里面的1个扇区（count=1），该扇区为第1个扇区（seek=1），因为启动时IROM还是会先从iNand中读取前16KB，然后计算校验和。这时候因为有1个扇区被擦掉了，所以校验和不通过，所以启动失败（会从SD2去执行2nd启动）。 注意：破坏板载iNand的bootloader后，不插外部SD卡，启动时串口得到：SD checksum Error 1234567891011busybox dd if=/dev/zero of=/dev/block/mmcblk0 bs=512 seek=1 count=1 conv=syncsync//可以使用脚本，命名write2sd,内容:#!/bin/shsudo dd iflag=dsync oflag=dsync if=210.bin of=/dev/sdb seek=1//或者在secureCRT，uboot底下使用movi命令清除扇区（写内存地址的数据进某个分区）movi write x xx（x为分区，xx为内存地址，在secureCRT输入help movi可查询命令）movi write u-boot 0x30000000 在windows下给sd卡写uboot ①格式化sd卡 ②使用x210_Fusing_Tool.exe烧写安卓/linux的uboot.bin 在linux下给sd卡写uboot（虚拟机） ①格式化sd卡，用读卡器插入电脑，在虚拟机-可连接设备选择连接u盘设备，在命令行中输入：ls /dev/sd*查看，和之前对比，得知SD卡在linux中的设备编号，一般是/dev/sdb。 ②制作SD启动卡，在linux终端输入cd /mnt/hgfs/share/uboot_sd_fusing进入文件夹和./nand_fusing.sh /dev/sdb将uboot刷进sd卡里。 利用uboot写固件到iNand ①插sd卡到开发板的SD2卡槽（靠近核心板的为SD2，远离的为SD3卡槽），启动开发板在自动启动前（3秒内）在secureCRT按回车停止自动启动安卓。 ②用usb-otg线连接电脑的usb和开发板的usb otg接口。 ③在secureCRT输入fastboot命令进入fastboot，如果分区数不为7，输入fdisk -c 0来分区。 ④在设备管理器更新驱动程序来安装fastboot驱动x210_android_driver（安装后显示为安卓设备：Android Bootloader Interface，win10需要禁用数字签名 ………………………………………….. win10禁用驱动签名方法）（永久禁用可以在提示符后面输入bcdedit.exe /set nointegritychecks on后回车，开启数字签名的话bcdedit.exe /set nointegritychecks off回车） ………………………………………….. ⑤windows下fastboot软件使用：windows控制台输入e:和cd E:\临时\3-嵌入式\实验\01刷机\4.fastboot\4.fastboot软件进入fastboot文件夹执行fastboot命令来烧录系统到iNand。 123456789101112131415161718192021222324252627282930313233343536常用路径fastboot devices 命令用来查看当前连接的设备。（我们开发板看到的是：SMDKC110-01）fastboot flash x xx 命令用来烧录(flash)的，x为分区，xx为相对路径fastboot reboot 命令用来重启系统fastboot -w 清除分区数据x210v3烧录安卓fastboot flash bootloader android4.0.4/uboot_inand.bin 烧ubootfastboot flash kernel android4.0.4/zImage-android 烧linux kernelfastboot flash system android4.0.4/x210.img 烧android romuboot的参数设置：set bootcmd &apos;movi read kernel 30008000; bootm 烧录linux+QT4.8fastboot flash bootloader linux+QT4.8/uboot_inand.bin 烧ubootfastboot flash kernel linux+QT4.8/zImage-qt 烧linux kernelfastboot flash system linux+QT4.8/rootfs_qt4.ext3 烧rootfsx210v3s分别在windows命令行执行以下命令烧录安卓fastboot flash bootloader android4.0/uboot.bin 烧ubootfastboot flash kernel android4.0/zImage-android 烧linux kernelfastboot flash system android4.0/x210.img 烧android romuboot的参数设置：set bootcmd &apos;movi read kernel 30008000; bootm 30008000&apos;（默认就是这个，不用设置也行）烧录linux+QTfastboot flash bootloader linuxQT/uboot.bin 烧ubootfastboot flash kernel linuxQT/zImage-qt 烧linux kernelfastboot flash system linuxQT/rootfs_qt4.ext3 烧rootfsuboot的参数不用特意设置（因为我们刷了专为linux+QT定制的uboot，这个uboot中估计已经预制好了所有的启动参数）烧录android2.3fastboot flash bootloader android2.3/uboot.bin 烧ubootfastboot flash kernel android2.3/zImage 烧linux kernelfastboot flash system android2.3/x210.img 烧android rom注意：android2.3中使用了串口0（Urat0，靠近核心板），所以启动后要把串口插到串口0中，不然串口没有任何启动信息出来。android2.3中屏幕上的logo是在左上角（刷机成功的标志） usb刷机 dnw工具下载 ①OM pin(5)打到VCC，OM pin(0-5)为101101，0为gnd，1为vcc（vcc靠近核心板一侧） ②用usb-otg线连接电脑的usb和开发板的usb otg接口。因为X210开发板使用了软开关，但是代码没有启动操作系统，所以 没去处理开关机，要一直按power键，抬起即关机，需要一直按着power键开机。在设备管理器更新驱动程序来安装dnw驱动（最好将驱动放在英文目录下，成功即显示为通用串行总线控制器，dnw软件顶部usb显示为ok）。 ………………………………………….. win10禁用驱动签名方法（永久禁用可以在提示符后面输入bcdedit.exe /set nointegritychecks on后回车，开启数字签名的话bcdedit.exe /set nointegritychecks off回车）因为驱动不包含驱动数字签名，windows会禁止安装。 ………………………………………….. ③打开dnw.exe（v0.60版本为x210专用），在dnw软件的菜单Configuration-option中设置serial port的波特率：115200，接口：com x（x为当前开发板串口连接电脑的com接口号）和usb port的download address：0xd0020010（0xd0020000-0xd002000f的16个字节用来放校验信息，但是usb不需要校验，所以从0xd0020010开始放启动代码）。 ④下载代码，点击dnw软件的菜单usb port-transmit-transmit，下载x210_usb.bin到0xd0020010（地址为SRAM，作用是初始化DRAM），然后下载uboot.bin到0x23e00000（地址为DRAM），以上过程和sd刷卡不同，不是下载uboot到sd卡，而是直接下载到DRAM执行，重启之后DRAM的数据会被清除，uboot.bin大小为384kb,SRAM只有96kb，而下载到iNand需要使用fastboot下载。 ⑤下载uboot.bin之前打开secureCRT，下载uboot.bin之后马上按回车进入开发板的fastboot。 ⑥在secureCRT输入fdisk -c 0来给iNand分区，不然等会fastboot选择分区的时候识别不了。输入fastboot查看分区，7个分区即成功分区。 ⑦在windows命令行使用fastboot命令刷机，具体参考sd卡刷机。 开发板实验准备 分析启动过程可知；210启动后先执行内部iROM中的BL0，BL0执行完后会根据OMpin的配置选择一个外部设备来启动（有很多，我们实际使用的有2个：usb启动和SD卡启动）。在usb启动时内部BL0读取到BL1后不做校验，直接从BL1的实质内部0xd0020010开始执行，因此usb启动的景象led.bin不需要头信息，因此我们从usb启动时直接将镜像下载到0xd0020010去执行即可；从SD启动时，BL0会首先读取sd卡得到完整的镜像（例如led.bin加上16字节的校验头），然后BL0会自己根据你的实际镜像（例如led.bin）来计算一个校验和(checksum)，然后和你完整镜像的头部中的checksum来比对。如果对应则执行BL1，如果不对应则启动失败（会转入执行2st启动，即SD2启动。如果这里已经是2st启动了则启动失败）。…………………………………………..注意，默认 andorid2.3,linux,WINCE 都使用 uart0 作为调试串口，只有 android4.0 使用 uart2 作为调试串口。 sd卡下载 将OM pin(0-5)拨为101100 破坏iNand的uboot 在windows下给sd卡写uboot（x210_Fusing_Tool.exe） 在linux下给sd卡写uboot（虚拟机）（在linux终端输入cd /mnt/hgfs/share/uboot_sd_fusing进入文件夹和./nand_fusing.sh(未定) /dev/sdb将210.bin刷进sd卡里。） mkv210_image.c的作用：为BL1添加校验头。我们编译链接时只得到了led.bin，这个210.bin的得到和交叉编译工具链是完全无关的。由led.bin得到210.bin的过程是三星的S5PV210所特有的，因此需要我们自己去完成，为此我们写了mkv210_image.c来完成。…………………………………………整个程序工作流分析：整个程序中首先申请一个16KB大小的buffer并且填充为0，要检验用户传参，在需要校验的内存区域中，所有内存中的内容按照字节为单位来进行相加，形成校验和，然后把所有内容按照各自的位置填充进去，最终把填充好的buffer写入到一个文件就形成了我们想要的镜像。 使用make led.bin指令添加校验头,使用make clean清理文件。 usb下载 dnw工具下载 ①OM pin(5)打到VCC，OM pin(0-5)为101101，0为gnd，1为vcc（vcc靠近核心板一侧） ②用usb-otg线连接电脑的usb和开发板的usb otg接口。因为X210开发板使用了软开关，但是代码没有启动操作系统，所以 没去处理开关机，要一直按power键，抬起即关机，需要一直按着power键开机。在设备管理器更新驱动程序来安装dnw驱动（成功显示为通用串行总线控制器，dnw软件顶部usb显示为ok）。 ③打开dnw.exe（v0.60版本为x210专用），在dnw软件的菜单Configuration-option中设置serial port的波特率：115200，接口：com x（x为当前开发板串口连接电脑的com接口号）和usb port的download address：0xd0020010（0xd0020000-0xd002000f的16个字节用来放校验信息，但是usb不需要校验，所以从0xd0020010开始放启动代码）。 ④下载代码，在dnw软件的菜单usb port-transmit-transmit,选择镜像文件x210_usb.bin，地址是0xd0020010;选择镜像文件uboot.bin，刷机地址是0x23e00000，下载好之后，uboot就自动启动，此时3秒内要按回车，然后输入fdisk -c 0去重新分区，然后再输入fastboot。 ⑤windows下使用fastboot命令刷机，windows控制台输入e:和cd E:\临时\3-嵌入式\实验\01刷机\4.fastboot\4.fastboot软件进入fastboot文件夹执行fastboot命令来烧录系统到iNand。。 123456789101112131415161718192021222324252627282930313233343536常用路径fastboot devices 命令用来查看当前连接的设备。（我们开发板看到的是：SMDKC110-01）fastboot flash x xx 命令用来烧录(flash)的，x为分区，xx为相对路径（可以使用&amp;&amp;将命令一起执行）fastboot reboot 命令用来重启系统fastboot -w 清除分区数据x210v3烧录安卓fastboot flash bootloader android4.0.4/uboot_inand.bin 烧ubootfastboot flash kernel android4.0.4/zImage-android 烧linux kernelfastboot flash system android4.0.4/x210.img 烧android romuboot的参数设置：set bootcmd &apos;movi read kernel 30008000; bootm 烧录linux+QT4.8fastboot flash bootloader linux+QT4.8/uboot_inand.bin 烧ubootfastboot flash kernel linux+QT4.8/zImage-qt 烧linux kernelfastboot flash system linux+QT4.8/rootfs_qt4.ext3 烧rootfsx210v3s烧录android4.0fastboot flash bootloader android4.0/uboot.bin 烧ubootfastboot flash kernel android4.0/zImage-android 烧linux kernelfastboot flash system android4.0/x210.img 烧android romuboot的参数设置：set bootcmd &apos;movi read kernel 30008000; bootm 30008000&apos;（默认就是这个，不用设置也行）烧录linux+QTfastboot flash bootloader linuxQT/uboot.bin 烧ubootfastboot flash kernel linuxQT/zImage-qt 烧linux kernelfastboot flash system linuxQT/rootfs_qt4.ext3 烧rootfsuboot的参数不用特意设置（因为我们刷了专为linux+QT定制的uboot，这个uboot中估计已经预制好了所有的启动参数）烧录android2.3fastboot flash bootloader android2.3/uboot.bin 烧ubootfastboot flash kernel android2.3/zImage 烧linux kernelfastboot flash system android2.3/x210.img 烧android rom注意：android2.3中使用了串口0（Urat0，靠近核心板），所以启动后要把串口插到串口0中，不然串口没有任何启动信息出来。android2.3中屏幕上的logo是在左上角（刷机成功的标志） 实验01-led灯基本概念物理特性：LED有2个接线点，一个是LED的正极，一个是LED的负极。LED这个硬件的功能就是点亮或者不亮，物理上想要点亮一颗LED只需要给他的正负极上加正电压（形成正向电压差）即可，要熄灭一颗LED只需要去掉电压即可。 GPIO是arm常见的一类引脚，有多个端口组（GPA0、GPJ0），每个端口组有若干个寄存器，通过改变寄存器的值来控制引脚，寄存器不同位数（大小）可能不同，通常用若干位组合来实现某项功能的不同表现（比如说GPJ0CON寄存器的1-4位用来控制GPJ0_3引脚），改变寄存器的值需要知道寄存器的地址。具体的内容可以查找数据手册文件S5PV210_UM_REV1.1。 开发板上一共有5颗LED。其中D26的接法是：正极接5V，负极接地，只要上电就会常亮，这颗LED是电源指示灯。剩下4颗LED的接法是：正极接3.3V，负极接了SoC上的一个引脚（GPIO），具体详细接法是： D22：GPJ0_3D23：GPJ0_4D24：GPJ0_5D25：PWMTOUT1(GPD0_1) 因为正极已经定了（3.3V），而负极接在了SoC的引脚上，可以通过SoC中编程来控制负极的电压值，即通过程序控制负极输出低电平（0V），这样在正负极上就有了压差，LED即可点亮。 gpio general purpose input output 通用输入输出GPIO就是芯片的引脚（芯片上的引脚有些不是GPIO，只有一部分是），作为GPIO的这类引脚，他的功能和特点是可以被编程控制它的工作模式，也可以编程控制他的电压高低等。如果设计电路时把LED接在非GPIO上就不可能点亮。 GPIO相关的寄存器LED通过GPIO来间接控制，要操作这些GPIO，必须通过设置他们的寄存器，来驱动LED点亮，①GPJ0CON寄存器中GPIO配置为output模式，②GPJ0DAT寄存器应的位设置为0。GPJ0相关的寄存器有以下： GPJ0相关的寄存器 全称 功能 GPJ0CON GPJ0 control GPJ0控制寄存器，用来配置各引脚的工作模式 GPJ0DAT GPJ0 data 当引脚配置为input/output模式时，寄存器的相应位和引脚的电平高低相对应 GPJ0PUD GPJ0 pull up down 控制引脚内部弱上拉、下拉 GPJ0DRV GPJ0 driver 配置GPIO引脚的驱动能力 GPJ0CONPDN GPJ0 control power down 低功耗模式下的控制寄存器 GPJ0PUDPDN GPJ0 pull up down power down 低功耗模式下的上下拉寄存器 GPxCON、GPxDAT寄存器分析 GPJ0端口一共有8个引脚：GPJ0_0 ～ GPJ0_7， GPJ0CON寄存器中设置8个引脚的工作模式（32/8=4，每个引脚可以分到4位，譬如GPJ0_0对应的bit位为bit0 ~ bit3，GPJ0_3对应的位为bit12 ~ bit15。工作方法是：给相应的寄存器位写入相应的值，该引脚硬件就会按照相应的模式去工作。譬如给bit12～bit15写入0b0001，GPJ0_3引脚就成为输出模式了） GPxDAT寄存器根据GPJ0CON寄存器的设置，若GPJ0CON为input模式，即将输入的电平存进GPxDAT寄存器里面（低电平为0，高电平为1）；若GPJ0CON为output模式，即将GPxDAT寄存器里面设置的数据设置为引脚的电平。 反汇编工具objdump objdump是gcc工具链中的反汇编工具，作用是由编译链接好的elf格式的可执行程序反过来得到汇编源代码，指令示例：arm-linux-objdump -D led.elf &gt; led_elf.dis -D表示反汇编;&gt;左边的是elf的可执行程序;&gt;右边的是反汇编生成的反汇编程序。 反汇编的用途： 逆向破解。 调试程序时，反汇编代码可以帮助我们理解程序，尤其是在理解链接脚本、链接地址等概念时。 把C语言源代码编译链接生成的可执行程序反汇编后得到对应的汇编代码，可以帮助我们理解C语言和汇编语言之间的对应关系。 反汇编文件的格式 （汇编 assembly 反汇编 disassembly） 标号地址、标号名字、指令地址、指令机器码、指令机器码反汇编到的指令 扩展：ARM汇编中用地址池方式来实现非法立即数 指令地址 下载烧录执行的bin文件，内部其实是一条一条的指令机器码。这些指令每一条都有一个指令地址，这个地址是连接的时候ld给指定的（ld根据我们写的链接脚本来指定） 分析链接脚本(linker script) 每一个链接过程都由链接脚本（一般以lds作为文件的后缀名）控制，链接脚本主要用于规定如何把输入文件内的section放入输出文件内, 并控制输出文件内各部分在程序地址空间内的布局。…………………………………………..反汇编的时候得到的指令地址是链接器考虑了链接脚本之后得到的地址，而我们写代码时通过指定连接脚本来让链接器给我们链接合适的地址。但是有时候我们写的链接脚本有误（或者我们不知道这个链接脚本会怎么样），这时候可以通过看反汇编文件来分析这个链接脚本的效果，看是不是我们想要的，如果不是可以改了再看。 编程过程①编写汇编代码来设置各寄存器，文件后缀为S（assembly汇编）。 汇编程序的后缀名.s和.S是区分大小写的，若是一小写的.s作为后缀那么则表示该汇编程序只包含汇编代码，编译器就不会进行预编译操作。若是以大写的.S作为后缀则表示该汇编代码中包含预编译代码，希望编译器进行预编译操作。 ②使用交叉编译工具链将汇编代码文件变为中间代码文件，文件后缀为o（object目标）；使用交叉编译工具链将中间代码文件变为可执行文件，文件后缀.elf（Executable Linkable Format）；使用交叉编译工具链将可执行文件变为镜像文件（二进制文件），文件后缀为bin（binary二进制）；使用交叉编译工具链将可执行文件变为反汇编代码文件，文件后缀为dis（disassembly反汇编）。 ③编写C语言代码来复制镜像文件并在文件开头加上校验头，文件后缀为c。 ④使用linux的gcc命令来编译+运行C语言代码文件，得到可执行文件+bin文件。 ⑤使用Makefile文件可将②、④步骤一起执行，无文件后缀，使用时只需make+指令即可，文件内容如下： 123456789101112131415led.bin: led.o arm-linux-ld -Ttext 0x0 -o led.elf $^ #arm-linux-ld是一个链接程序工具，其作用主要是将汇编过的多个二进制文件进行链接，成为一个可执行的二进制文件（elf格式）;-Ttext 0x0 作用是设置初始地址。 arm-linux-objcopy -O binary led.elf led.bin #arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中.此选项可以进行格式的转换.在实际编程的,用的最多的就是将ELF格式的可执行文件转换为二进制文件。 arm-linux-objdump -D led.elf &gt; led_elf.dis #arm-linux-objdump常用来显示二进制文件信息,常用来查看反汇编代码，-D 作用是反汇编所有段。 gcc mkv210_image.c -o mkx210 #用C语言编写程序，gcc 作用是编译.c 文件，-o 作用是更改默认编译过的文件名。该.c 文件作用是根据源bin 文件创建带有校验头的bin 文件。 ./mkx210 led.bin 210.bin #./ 作用是运行本目录下的程序，led.bin 和210.bin 为参数，为c 文件操作两个文件的文件名。 %.o : %.S arm-linux-gcc -o $@ $&lt; -c%.o : %.c arm-linux-gcc -o $@ $&lt; -c clean: rm *.o *.elf *.bin *.dis mkx210 -f 实验项目led灯-01-全亮 硬件接法和引脚：GPJ0_3 GPJ0_4 GPJ0_5 低电平亮/高电平灭。GPJ0CON（0xE0200240）寄存器和GPJ0DAT（0xE0200244）寄存器 步骤 ①使用工程管理，make编译得到led.bin和210.bin make Makefile //根据start.S、Makefile、mkv210_image.c创建start.o、led.elf、led.bin、210.bin ②用usb启动dnw下载led.bin到0xd0020010（IRAM）或用sd卡烧录210.bin到sd卡。 打开dnw.exe，在dnw软件的菜单Configuration-option中设置接口，在菜单usb port-transmit-transmit,选择镜像文件（例如led.bin）。开发板即运行程序。 ………………………………………….. win10禁用驱动签名方法（永久禁用可以在提示符后面输入bcdedit.exe /set nointegritychecks on后回车，开启数字签名的话bcdedit.exe /set nointegritychecks off回车） ………………………………………….. windows：打开x210_Fusing_Tool.exe，选择路径，将210.bin镜像文件烧录到sd卡 linux：在linux终端输入cd /mnt/hgfs/share/uboot_sd_fusing进入文件夹和./write2sd /dev/sdb将210.bin刷进sd卡里。 ③实验现象 开发板上按下电源键之后4颗LED默认都是半亮的，当我们下载程序后其中3颗变的很亮，这说明我们的程序已经运行了。 makefile 12345678910111213141516led.bin: start.o arm-linux-ld -Ttext 0x0 -o led.elf $^ arm-linux-objcopy -O binary led.elf led.bin arm-linux-objdump -D led.elf &gt; led_elf.dis gcc mkv210_image.c -o mkx210 ./mkx210 led.bin 210.bin %.o : %.s arm-linux-gcc -o $@ $&lt; -c%.o : %.c arm-linux-gcc -o $@ $&lt; -c .PHONY: clean //.PHONY后面要加`:`，否则会报错：`*** missing separator. stop.`clean: rm *.o *.elf *.bin *.dis mkx210 -f start.s 12345678910111213141516171819/* * 文件名：start.s * 作者： pxf * 描述： 使210开发板的三颗led灯变亮 */.global _start @arm汇编注释用`@`，没有`.global _start`执行`.arm-none-linux-gnueabi-ld`会警告：`warning: cannot find entry symbol _start; defaulting to 00000000`_start: @设置GPJ0CON（0xE0200240）寄存器，使GPJ0_3 GPJ0_4 GPJ0_5引脚变为输出引脚 ldr r0, =0xE0200240 ldr r1, =0x00111000 str r1, [r0] @设置GPJ0DAT（0xE0200244）寄存器，使GPJ0_3 GPJ0_4 GPJ0_5引脚变为低电平 ldr r0, =0xE0200244 ldr r1, =0x00 str r1, [r0]flag: b flag @最后一个回车如果是在linux里面编辑的不会警告，如果是windows里面编辑的会警告：`Warning: end of file not at end of a line; newline inserted` mkv210_image.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* * mkv210_image.c的主要作用就是由usb启动时使用的led.bin制作得到由sd卡启动的镜像210.bin *//* 在BL0阶段，Irom内固化的代码读取nandflash或SD卡前16K的内容， * 并比对前16字节中的校验和是否正确，正确则继续，错误则停止。 */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define BUFSIZE (16*1024)#define IMG_SIZE (16*1024)#define SPL_HEADER_SIZE 16//#define SPL_HEADER "S5PC110 HEADER "#define SPL_HEADER "****************"int main (int argc, char *argv[])&#123; FILE *fp; char *Buf, *a; int BufLen; int nbytes, fileLen; unsigned int checksum, count; int i; // 1. 3个参数 if (argc != 3) &#123; printf("Usage: %s &lt;source file&gt; &lt;destination file&gt;\n", argv[0]); return -1; &#125; // 2. 分配16K的buffer BufLen = BUFSIZE; Buf = (char *)malloc(BufLen); if (!Buf) &#123; printf("Alloc buffer failed!\n"); return -1; &#125; memset(Buf, 0x00, BufLen); // 3. 读源bin到buffer // 3.1 打开源bin fp = fopen(argv[1], "rb"); if( fp == NULL) &#123; printf("source file open error\n"); free(Buf); return -1; &#125; // 3.2 获取源bin长度 fseek(fp, 0L, SEEK_END); // 定位到文件尾 fileLen = ftell(fp); // 得到文件长度 fseek(fp, 0L, SEEK_SET); // 再次定位到文件头 // 3.3 源bin长度不得超过16K-16byte count = (fileLen &lt; (IMG_SIZE - SPL_HEADER_SIZE)) ? fileLen : (IMG_SIZE - SPL_HEADER_SIZE); // 3.4 buffer[0~15]存放"S5PC110 HEADER " memcpy(&amp;Buf[0], SPL_HEADER, SPL_HEADER_SIZE); // 3.5 读源bin到buffer[16] nbytes = fread(Buf + SPL_HEADER_SIZE, 1, count, fp); if ( nbytes != count ) &#123; printf("source file read error\n"); free(Buf); fclose(fp); return -1; &#125; fclose(fp); // 4. 计算校验和 // 4.1 从第16byte开始统计buffer中共有几个1 // 4.1 从第16byte开始计算，把buffer中所有的字节数据加和起来得到的结果 a = Buf + SPL_HEADER_SIZE; for(i = 0, checksum = 0; i &lt; IMG_SIZE - SPL_HEADER_SIZE; i++) checksum += (0x000000FF) &amp; *a++; // 4.2 将校验和保存在buffer[8~15]！！！！ a = Buf + 8; // Buf是210.bin的起始地址，+8表示向后位移2个字，也就是说写入到第3个字 *( (unsigned int *)a ) = checksum; // 5. 拷贝buffer中的内容到目的bin // 5.1 打开目的bin fp = fopen(argv[2], "wb"); if (fp == NULL) &#123; printf("destination file open error\n"); free(Buf); return -1; &#125; // 5.2 将16k的buffer拷贝到目的bin中 a = Buf; nbytes = fwrite( a, 1, BufLen, fp); if ( nbytes != BufLen ) &#123; printf("destination file write error\n"); free(Buf); fclose(fp); return -1; &#125; free(Buf); fclose(fp); return 0;&#125; 移位：左移+标志位的（0、1）逻辑右移操作 LSR led灯-02-优化代码 使用寄存器名字的宏定义来定义寄存器地址。 用b .来实现死循环 用.global把_start链接属性改为外部，消除链接时的警告(01已经实现) global关键字用来让一个符号对链接器可见，可以供其他链接对象模块使用。.global _start让_start符号成为可见的标示符，这样链接器就知道跳转到程序中的什么地方并开始执行。linux寻找这个_start标签作为程序的默认进入点。在汇编和C混合编程中，在GNU ARM编译环境下，汇编程序中要使用.global伪操作声明汇编程序为全局的函数，意即可被外部函数调用，同时C程序中要使用extern声明要调用的汇编语言程序。 点亮第四颗led灯（硬件接法和引脚：GPD0_1低电平亮/高电平灭。GPD0CON（0xE02000A0）寄存器和GPD0DAT（0xE02000A4）寄存器） led灯-03-部分点亮 使用位运算点亮1颗LED,在GPJ0CON寄存器不需要修改，GPJ0DAT中设置相应的输出值即可。常用位运算：位与(&amp;)位或(|)位非（取反 ~）移位（左移&lt;&lt; 右移&gt;&gt;） 步骤 ①GPJ0DAT = 0x28 ②使用位运算实现功能 1&lt;&lt;3 等于 0b10001&lt;&lt;5 等于 0b100000(1&lt;&lt;3) | (1&lt;&lt;5) 等于 0b101000（二进制）((0&lt;&lt;3) | (1&lt;&lt;4) | (0&lt;&lt;5)) 等于 0b010000 led灯-04-闪烁 编写循环函数，用一个寄存器存放一个数字，然后在循环中每个循环里给数字减1，然后再判断这个数字的值是否为0.如果为0则停止循环，如果不为0则继续循环。 调用函数，汇编中主程序是一个死循环，这个死循环是我们汇编程序的主体，类似于C中的main函数。其他函数必须写在这个主死循环程序的后面（死循环外）。汇编中调用函数用bl指令，子函数中最后用mov pc, lr来返回。 led灯-05-跑马灯 位取反操作符实现单颗LED点亮,用移位实现4颗LED流水效果。mov r1, r1, ror#1 整个程序易错点：忘记修改makefile里面的文件名（忘记使用编译器）；忘记修改寄存器名字；ldr伪指令的操作数不加=；设置寄存器的值忘记要使用str；寄存器存放的值具体有几位；移位指令理解错误，移位后的数是放在第一个寄存器里面，并且无循环左移；移位的时候要注意寄存器是32位的；设置数据寄存器的时候要注意尽量不要把其他寄存器的值修改（先设置地址小的寄存器，即使寄存器大小不足32位，32位的通用寄存器的高位覆盖了下一个寄存器，这个时候要使用下一个寄存器则继续设置寄存器里面的值即可）；延迟函数使用了主函数正在使用的寄存器，导致结果错误； 实验02-启动代码基本概念看门狗硬件上是SoC内部的一个内部外设，watch dog timer：看门狗定时器。现实中因为一些外部因素，电子设备经常会跑飞或者死机（譬如极端炎热、极端寒冷、工业复杂场合）。在这种情况下我们希望设备自动复位而不需要人工干预（无人值守）。看门狗用来完成这个工作。看门狗其实是我们SoC内部的一个定时器，定好时间之后看门狗定时器会去计时，时间到之前必须去重新置位看门狗定时器，如果没有置位系统就会被强制复位。系统在正常工作时，系统软件会自动置位，所以看门狗定时器不会复位。但是系统一旦故障，看门狗就无法置位，然后下一个周期就会自动复位，达到我们期望的效果。 注：程序跑飞是指系统受到某种干扰后,程序计数器PC的值偏离了给定的唯一变化历程,导致程序运行偏离正常的运行路径；s5pv210内部的iROM代码（BL0）中，已经关闭看门狗。CPU内部没有BL0的，都要在启动代码前段自己写代码关看门狗。 特殊功能寄存器(SFR)WTCON（0xE2700000），其中bit5是看门狗的开关：0代表关，1代表开 c语言 C语言运行时（runtime）需要一定的条件，这些条件由汇编来提供。C语言运行时主要是需要栈。 C语言与栈的关系 C语言中的局部变量都是用栈来实现的。如果我们汇编部分没有给C部分预先设置合理合法的栈地址，那么C代码中定义的局部变量就会丢失。 编写单片机程序（譬如51单片机）或者编写应用程序时并没有去设置栈，但是C程序还是可以运行的。原因是：在单片机中由硬件初始化时提供了一个默认可用的栈，在应用程序中我们编写的C程序其实并不是全部，编译器（gcc）在链接的时候会帮我们自动添加一个头，这个头就是一段引导我们的C程序能够执行的一段汇编实现的代码，这个代码中就帮我们的C程序设置了栈及其他的运行时需要。 CPU模式和各种模式下的栈 在ARM中37个寄存器中，每种模式下都有自己的独立的SP寄存器（r13），是因为如果各种模式都使用同一个SP，那么就意味着整个程序（操作系统内核程序、用户自己编写的应用程序）都是用一个栈的。你的应用程序如果一旦出错（譬如栈溢出），就会连累操作系统的栈也损坏，整个操作系统的程序就会崩溃。这样的操作系统设计是非常脆弱的，不合理的。 解决方案就是各种模式下用不同的栈。操作系统内核使用自己的栈，每个应用程序也使用自己独立的栈，这样各是各的，一个损坏不会连累其他人。 如何访问SVC模式下的SP？先把模式设置为SVC，再直接操作SP。但是因为系统在复位后就已经是SVC模式了，所以直接设置SP即可。 查阅文档并设置栈指针至合法位置 栈必须是当前一段可用的内存（可用的意思是这个地方必须有被初始化过的可以访问的内存，而且这个内存只会被我们用作栈，不会被其他程序征用） 当前CPU刚复位（刚启动），外部的DRRAM尚未初始化，目前可用的内存只有内部的SRAM（因为它不需初始化即可使用）。因此我们只能在SRAM中找一段内存来作为SVC的栈。 栈有四种：满减栈 满增栈 空减栈 空增栈 满栈：进栈：先移动指针再存； 出栈：先出数据再移动指针 空栈：xxx 减栈：进栈：指针向下移动； 出栈：指针向上移动 增栈：xxx 在ARM中，ATPCS（ARM关于程序应该怎么实现的一个规范）要求使用满减栈，所以不出意外都是用满减栈，结合iROM_application_note中的memory map，可知SVC栈应该设置为0xd0037D80 汇编程序和C程序互相调用：bl cfuncion 设置栈在工程中新建并且添加一个C语言源文件（led.c），注意添加时要修改Makefile。在汇编启动代码中设置好栈后，使用bl xxx的方式来调用C中的函数xxx 使用C语言访问寄存器 寄存器的地址类似于内存地址（IO与内存统一编址的），用C语言读写寄存器，就是用C语言来读写内存地址，就要用到指针。 1234unsigned int *p = (unsigned int *)0xE0200240;*p = 0x11111111;*((unsigned int *)0xE0200240) = 0x11111111;//另一种写法 volatile volatile的作用是让程序在编译时，编译器不对程序做优化。优化有时候是可以的，但是有时候会使程序错误。比如说某个变量经过循环，里面的值不断发生改变，编译器会在预编译的时候就算好结果，在运行的时候就已经是最后的变量了。如果一个变量是易变的，不希望编译器帮我们做优化，就在这个变量定义时加volatile。 加不加有没有差别，取决于编译器。如果编译器做了优化则有差异；如果编译器本身没做优化，那就没有差别。 在我们这里（编译器是arm-2009q3），实际测试加不加效果是一样的。 编译报错 连接阶段报错undefined reference to __aeabi_unwind_cpp_pr1 解决：在编译时添加-nostdlib这个编译选项即可解决。nostdlib就是不使用标准函数库。标准函数库就是编译器中自带的函数库，用-nostdlib可以让编译器链接器优先选择我程序内自己写的函数库。 icache 什么是cache，有什么用 cache是一种内存，叫高速缓存。 从容量来说：CPU &lt; 寄存器 &lt; cache &lt; DDR 从速度来说：CPU &gt; 寄存器 &gt; cache &gt; DDR cache的存在，是因为寄存器和ddr之间速度差异太大，ddr的速度远不能满足寄存器的需要（不能满足cpu的需要，所以没有cache会拉低整个系统的整体速度） 整个系统中CPU的供应链由：寄存器+cache+DDR+硬盘/flash四阶组成，这是综合考虑了性能、成本后得到的妥协的结果。 210内部有32KB icache和32kb dcache。icache是用来缓存指令的；dcache是用来缓存数据的。 cache的意义 指令平时是放在硬盘/flash中的，运行时读取到DDR中，再从DDR中读给寄存器，再由寄存器送给cpu。但是DDR的速度和寄存器（代表的就是CPU）相差太大，如果CPU运行完一句再去DDR读取下一句，那么CPU的速度完全就被DDR给拖慢了。解决方案就是icache。 icache工作时，会把我们CPU正在运行的指令的旁边几句指令事先给读取到icache中（CPU设计有一个基本原理：代码执行时，下一句执行当前一句代码旁边代码的可能性要大很多）。当下一句CPU要指令时，cache首先检查自己事先准备的缓存指令中有没这句，如果有就直接拿给CPU，如果没有则需要从DDR中重新去读取拿给CPU，并同时做一系列的动作：清缓存、重新缓存。 iROM中BL0对cache的操作 icache的一切动作都是自动的，不需人为干预。我们所需要做的就是打开/关闭icache。在210的iROM中BL0已经打开了icache。 汇编代码读写cp15以开关icache mrc p15,0,r0,c1,c0,0; // 读出p15的c1到r0中 bic r0, r0, #(1&lt;&lt;12) // bit12 置0 关icache,bic：清零 orr r0, r0, #(1&lt;&lt;12) // bit12 置1 开icache,orr：或运算 mcr p15,0,r0,c1,c0,0; 实验结果分析 结论1：irom中确实是打开了icache的。 结论2：icache关闭确实比icache打开时led闪烁变慢，说明指令执行速度变慢。 重定位 位置有关编码&amp;位置无关编码 位置无关编码(PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。 位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的，大部分指令是位置有关编码。 链接地址和运行地址 设计一个程序时，通常会给这个程序指定一个链接地址。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以和指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。 位置无关代码要好一些，适应性强，放在哪里都能正常运行；位置有关代码就必须运行在链接时指定的地址上，适应性差。位置无关码有一些限制，不能完成所有功能，有时候不得不使用位置有关代码。 我们之前的裸机程序中，Makefile中用 -Ttext 0x0 来指定链接地址是0x0。这意味着我们认为这个程序将来会放在0x0这个内存地址去运行。 但是实际上我们运行时的地址是0xd0020010(我们用dnw下载时指定的下载地址)。这两个地址看似不同，但是实际相同。这是因为S5PV210内部做了映射，把SRAM映射到了0x0地址去。 链接地址和运行地址指定方式 链接地址：链接时指定的地址（指定方式为：Makefile中用-Ttext，或者链接脚本） 运行地址：程序实际运行时地址（指定方式：由实际运行时被加载到内存的哪个位置说了算，运行时的地址是由运行时决定的，编译链接时是无法绝对确定运行时地址的） 举例：1、linux中的应用程序。gcc hello.c -o hello，这时使用默认的链接地址就是0x0，所以应用程序都是链接在0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享4G的虚拟地址空间。所以应用程序都可以链接到0地址，因为每个进程都是从0地址开始的。（编译时可以不给定链接地址而都使用0） 2、210中的裸机程序。运行地址由我们下载时确定，下载时下载到0xd0020010，所以就从这里开始运行。（这个下载地址也不是我们随意定的，是iROM中的BL0加载BL1时事先指定好的地址，这是由CPU的设计决定的）。所以理论上我们编译链接时应该将地址指定到0xd0020010，但是实际上我们在之前裸机程序中都是使用位置无关码PIC，所以链接地址可以是0。 S5PV210的启动过程 三星推荐和uboot的实现是不同的，三星推荐的启动方式中：bootloader必须小于96KB并大于16KB，假定bootloader为80KB，启动过程是这样子：先开机上电后BL0运行，BL0会加载外部启动设备中的bootloader的前16KB（BL1）到SRAM中去运行，BL1运行时会加载BL2（bootloader中80-16=64KB）到SRAM中（从SRAM的16KB处开始用）去运行；BL2运行时会初始化DDR并且将OS搬运到DDR去执行OS，启动完成。 uboot实际使用的方式：uboot大小随意，假定为200KB。启动过程是这样子：先开机上电后BL0运行，BL0会加载外部启动设备中的uboot的前16KB（BL1）到SRAM中去运行，BL1运行时会初始化DDR，然后将整个uboot搬运到DDR中，然后用一句长跳转（从SRAM跳转到DDR）指令从SRAM中直接跳转到DDR中继续执行uboot直到uboot完全启动。uboot启动后在uboot命令行中去启动OS。 重定位 静态重定位：即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。 动态重定位：它不是在程序装入内存时完成的，而是CPU每次访问内存时 由动态地址变换机构（硬件）自动进行把相对地址转换为绝对地址。动态重定位需要软件和硬件相互配合完成。 链接地址和运行地址有时候必须不相同，而且还不能全部用位置无关码，这时候只能重定位。 分散加载：把uboot分成2部分（BL1和整个uboot），两部分分别指定不同的链接地址。启动时将两部分加载到不同的地址（BL1加载到SRAM，整个uboot加载到DDR），这时候不用重定位也能启动。 评价：分散加载其实相当于手工重定位。重定位是用代码来进行重定位，分散加载是手工操作重定位的。 从源码到可执行程序的步骤 预编译：预编译器执行。譬如C中的宏定义就是由预编译器处理，注释等也是由预编译器处理的。 编译： 编译器来执行。把源码.c .S编程机器码.o文件。 链接： 链接器来执行。把.o文件中的各函数（段）按照一定规则（链接脚本来指定）累积在一起，形成可执行文件。 strip： strip是把可执行程序中的符号信息给拿掉，以节省空间。（Debug版本和Release版本） objcopy：由可执行程序生成可烧录的镜像bin文件。 程序段的概念 代码段、数据段、bss段（ZI段）、自定义段 段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段站在核实的位置。 段名分为2种：一种是编译器链接器内部定好的；一种是程序员自己指定的、自定义的段名。 不可更改的段名： 代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西 数据段：（.data），数据段就是C语言中有显式初始化为非0的全局变量 bss段：（.bss），又叫ZI（zero initial）段，就是零初始化段，对应C语言中初始化为0的全局变量。 自定义的段名： 段名由程序员自己定义，段的属性和特征也由程序员自己定义。 相关例子： C语言中全局变量如果未显式初始化（例：int a;），值是0。本质就是C语言把这类全局变量放在了bss段，从而保证C运行时环境。显式初始化为非0（例：int a = 1;）的全局变量的值在main之前就被赋值了，就是因为它把这类变量放在了.data段中，而.data段会在main执行之前被处理（初始化）。 链接脚本 链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理.o文件中那些段，将其链接成一个可执行程序。 链接脚本的关键内容有2部分：段名 + 地址（作为链接地址的内存地址） 链接脚本的理解： SECTIONS {} 这个是整个链接脚本 . 点号在链接脚本中代表当前位置。 = 等号代表赋值 sdram SDRAM：synchronous dynamic random-access memory，同步动态随机存储器，特性：容量大、价格低、掉电易失性、随机读写、总线式访问SDRAM属于动态内存（相对于静态内存SRAM），需要先运行一段初始化代码来初始化才能使用,不像SRAM开机上电后就可以直接运行。 SDRAM数据手册SDRAM在系统中属于SoC外接设备（外部外设。在外部的一般有：Flash、SDRAM/DDR、网卡芯片如DM9000、音频Codec。现在有一些高集成度的芯片也试图把这几个集成进去，做成真正的单芯片解决方案。）SDRAM通过地址总线和数据总线接口（总线接口）与SoC通信。 开发板原理图上使用的是K4T1G164QQ，但是实际开发板上是另一款。但是这两款是完全兼容的，进行软件编程分析的时候完全可以参考K4T1G164QQ的文档。 全球做SDRAM的厂商不多，二线厂家做的产品参数都是向一线厂家（三星、KingSton）看齐，目的是兼容一线厂家的设计，然后让在意成本的厂商选择它的内存芯片替代一线厂家的内存芯片。SDRAM的这个市场特征就导致这个东西比较标准化，大部分时候细节参数官方（芯片原厂家）都会给你一个参考值。 K4T1G164QE：K表示三星产品，4表示是DRAM，T表示产品号码，1G表示容量（1Gb，等于128MB，我们开发板X210上一共用了4片相同的内存，所以总容量是128×4=512MB）16表示单芯片是16位宽的，4表示是4bank 三星官方的数据手册上其实没有芯片相关的参数设置信心，都是芯片选型与外观封装方面的信息，选型是给产品经理来看的，封装和电压等信息是给硬件工程师看的。软件工程师最关注的是工作参数信息，但是数据手册没有。 原理图中SDRAM相关部分S5PV210共有2个内存端口（就好像有2个内存插槽）。再结合查阅数据手册中内存映射部分，可知：两个内存端口分别叫DRAM0和DRAM1：DRAM0：内存地址范围：0x20000000～0x3FFFFFFF（512MB），对应引脚是Xm1xxxxDRAM1: 内存地址范围：0x40000000～0x7FFFFFFF（1024MB），对应引脚是Xm2xxxx 结论：(1)整个210最多支持内存为1.5GB，如果给210更多的内存CPU就无法识别。 (2)210最多支持1.5GB内存，但是实际开发板不一定要这么多，譬如我们X210开发板就只有512MB内存，连接方法是在DRAM0端口分布256MB，在DRAM1端口分布了256MB。 (3)由2可知，X210开发板上内存合法地址是：0x20000000～0x2FFFFFFF（256MB） + 0x40000000～0x4FFFFFFF（256MB）。当板子上DDR初始化完成之后，这些地址都是可以使用的；如果使用了其他地址譬如0x30004000就是死路一条。 原理图中每个DDR端口都由3类总线构成：地址总线（Xmn_ADDR0 ~ XMnADDR13共14根地址总线） + 控制总线（中间部分，自己看原理图） + 数据总线（Xmn_DATA0 ~ XMnDATA31共32根数据线） 分析：从数据总线的位数可以看出，我们用的是32位的（物理）内存。原理图中画出4片内存芯片的一页，可以看出：X210开发板共使用了4片内存（每片1Gb=128MB，共512MB），每片内存的数据总线都是16位的（单芯片是16位内存）。如何由16位内存得到32位内存呢？可以使用并联方法。在原理图上横向的2颗内存芯片就是并联连接的。并联时地址总线接法一样，但是数据总线要加起来。这样连接相当于在逻辑上可以把这2颗内存芯片看成是一个（这一个芯片是32位的，接在Xm1端口上）。 数据手册中SDRAM相关部分看数据手册《NT5TU64M16GG-DDR2-1G-G-R18-Consumer》第10页的block diagram。这个框图是128Bb×8结构的，这里的8指的是8bank，每bank128Mbit。 210的DDR端口信号中有BA0～BA2，接在内存芯片的BA0～BA2上，这些引脚就是用来选择bank的。每个bank内部有128Mb，通过row address（14位） + column address（10位）的方式来综合寻址。一共能寻址的范围是：2的14次方+2的10次方 = 2的24次方。对应16MB（128Mbit）内存。 汇编初始化SDRAM（DDR2）SDRAM初始化使用一个函数sdram_asm_init，函数在sdram_init.S文件中实现，是一个汇编函数。强调：汇编实现的函数在返回时需要明确使用返回指令（mov pc, lr） 初始化DDR2准备(1)DDR初始化和SoC（准确说是和SoC中的DDR控制器）有关，也和开发板使用的DDR芯片有关，和开发板设计时DDR的连接方式也有关。(2)S5PV210的DDR初始化步骤在SoC数据手册：1.2.1.3 DDR2。可知初始化DDR共需27个步骤。(3)之前分析过X210的内存连接方式是：在DRAM0上连接256MB，在DRAM1上连接了256MB。所以初始化DRAM时分为2部分，第一部分初始化DRAM0，第二部分初始化DRAM1.(4)代码来自于：九鼎官方的uboot、九鼎的裸机教程中对DDR的初始化、根据实际改进。 设置IO端口驱动强度因为DDR芯片和S5PV210之间是通过很多总线连接的，总线的物理表现就是很多个引脚，也就是说DDR芯片和S5PV210芯片是通过一些引脚连接的。DDR芯片工作时需要一定的驱动信号，这个驱动信号需要一定的电平水平才能抗干扰，所以需要设置这些引脚的驱动能力，使DDR正常工作。DRAM控制器对应的引脚设置为驱动强度2X（参考原厂代码） DRAM port 时钟设置代码第128行到154行。主要是开启DLL（dram pll）然后等待锁存。这段代码对应27步中的第2到第4步。 DMC0_MEMCONTROLburst length=4，1chip，······ 对应值是0x00202400DMC0_MEMCONFIG_0：DRAM0通道中memory chip0的参数设置寄存器DMC0_MEMCONFIG_1：DRAM0通道中memory chip1的参数设置寄存器推论：三星设置DRAM0通道，允许接2片256MB的内存，分别叫memory chip0和memory chip1，分别用这两个寄存器来设置它的参数。chip0的地址应该是0x20000000到0x2FFFFFFF，然后chip1的地址应该是0x30000000~0x3FFFFFFF.各自256MB。X210开发板实际在DRAM0端口只接了256MB的内存，所以只用了chip0，没有使用chip1.（2片芯片并联形成32位内存的，逻辑上只能算1片）。DMC0_MEMCONFIG_0有用，而DMC0_MEMCONFIG_1无用，所以设置默认值。 DMC_DIRECTCMD这个寄存器是个命令寄存器，我们210通过向这个寄存器写值来向DDR芯片发送命令（通过命令总线），这些命令应该都是用来配置DDR芯片工作参数。 总结：DDR配置过程比较复杂，基本上是按照DDR控制器的时序要求来做的，其中很多参数要结合DDR芯片本身的参数来定，还有些参数是时序参数，要去详细计算。所以DDR配置非常繁琐、细致、专业。所以我们对DDR初始化的态度就是：学会这种思路和方法，结合文档和代码能看懂，会算一些常见的参数即可。 重定位代码到SDRAM中DRAM初始化之后，重定位代码过程和之前重定位到SRAM中完全相同。 时钟系统 什么是时钟？SoC为什么需要时钟？(1)时钟是同步工作系统的同步节拍。……………………….(2)SoC内部有很多器件，譬如CPU、串口、DRAM控制器、GPIO等内部外设，这些东西要彼此协同工作，需要一个同步的时钟系统来指挥。这个就是我们SoC的时钟系统。 SoC的时钟获得一般有： 外部直接输入时钟信号，SoC有个引脚用来输入外部时钟信号，用的很少。 外部晶振+内部时钟发生器产生时钟，大部分低频单片机都是这么工作的。 外部晶振+内部时钟发生器+内部PLL产生高频时钟+内部分频器分频得到各种频率的时钟，210属于这种。 S5PV210时钟属于第三种。主要是因为芯片外部电路不适宜使用高频率，因为传导辐射比较难控制；高频率的晶振价格成本高。SoC内部有很多部件都需要时钟，而且各自需要的时钟频率不同，没法统一供应。因此设计思路是PLL后先得到一个最高的频率（1GHz、1.2GHz），然后各外设使用分频器分频得到合适的频率。 时钟和系统性能的关系、超频、稳定性 (1)一般SoC时钟频率都是可以人为编程控制的，频率的高低对系统性能有很大影响。 (2)S5PV210建议工作频率800MHz～1.2GHz，一般设置主频1GHz。如果你设置到1.2GHz就叫超频。超频的时候系统性能会提升，但是发热量也会增大，因此会影响系统稳定性。 时钟和外设编程的关联 (1)每个外设工作都需要一定频率的时钟，这些时钟都是由时钟系统提供的。时钟系统可以编程控制工作模式，因此程序员可以为每个外设指定时钟来源、时钟分频系统、从而制定这个外设的工作时钟。 时钟和功耗控制的关系 (1)SoC中各种设备工作时，时钟频率越高其功耗越大，发热越大，越容易不稳定，需要外部的散热条件越苛刻。 (2)SoC内部有很多外设，这些外设不用的时候最好关掉（不关掉会一定程度浪费电），开关外设不是通过开关，而是通过时钟。也就是说我们给某个外设断掉时钟，这个外设就不工作了。 S5PV210的时钟系统简介 时钟域：MSYS、DSYS、PSYS(1)S5PV210的时钟体系比较复杂，内部外设模块多，因此把整个内部的时钟划分为3大块，叫做3个域。 (2)MSYS: CPU（Cortex-A8内核）、DRAM控制器（DMC0和DMC1）、IRAM&amp;IROM······ (3)DSYS: 都是和视频显示、编解码等有关的模块 (4)PSYS: 和内部的各种外设时钟有关，譬如串口、SD接口、I2C、AC97、USB等。 (5)内部要分为3个域，因为210内部的这些模块彼此工作时钟速率差异太大了，所以有必要把高速的放一起，相对低速的放一起。 时钟来源：晶振+时钟发生器+PLL+分频电路(1)S5PV210外部有4个晶振接口，设计板子硬件时可以根据需要来决定在哪里接晶振。接了晶振之后上电相应的模块就能产生振荡，产生原始时钟。原始时钟再经过一系列的筛选开关进入相应的PLL电路生成倍频后的高频时钟。高频时钟再经过分频到达芯片内部各模块上。（有些模块，譬如串口内部还有进一步的分频器进行再次分频使用） PLL：APLL、MPLL、EPLL、VPLLAPLL：Cortex-A8内核 MSYS域MPLL&amp;EPLL：DSYS PSYSVPLL：Video视频相关模块 S5PV210时钟域详解 MSYS域：ARMCLK： 给cpu内核工作的时钟，也就是所谓的主频。HCLK_MSYS： MSYS域的高频时钟，给DMC0和DMC1使用PCLK_MSYS： MSYS域的低频时钟HCLK_IMEM：给iROM和iRAM（合称iMEM）使用 DSYS域：HCLK_DSYS：DSYS域的高频时钟PCLK_DSYS：DSYS域的低频时钟 PSYS域：HCLK_PSYS：PSYS域的高频时钟PCLK_PSYS：PSYS域的低频时钟SCLK_ONENAND： 总结：210内部的各个外设都是接在（内部AMBA总线）总线上面的，AMBA总线有1条高频分支叫AHB，有一条低频分支叫APB。上面的各个域都有各自对应的HCLK_XXX和PCLK_XXX，其中HCLK_XXX就是XXX这个域中AHB总线的工作频率；PCLK_XXX就是XXX这个域中APB总线的工作频率。SoC内部的各个外设其实是挂在总线上工作的，也就是说这个外设的时钟来自于他挂在的总线，譬如串口UART挂在PSYS域下的APB总线上，因此串口的时钟来源是PCLK_PSYS。我们可以通过记住和分析上面的这些时钟域和总线数值，来确定我们各个外设的具体时钟频率。 各时钟典型值（默认值，iROM中设置的值） (1)当210刚上电时，默认是外部晶振+内部时钟发生器产生的24MHz频率的时钟直接给ARMCLK的，这时系统的主频就是24MHz，运行非常慢。 (2)iROM代码执行时第6步中初始化了时钟系统，这时给了系统一个默认推荐运行频率。这个时钟频率是三星推荐的210工作性能和稳定性最佳的频率。 (3)各时钟的典型值： * freq(ARMCLK) = 1000 MHz * freq(HCLK_MSYS) = 200 MHz * freq(HCLK_IMEM) = 100 MHz * freq(PCLK_MSYS) = 100 MHz * freq(HCLK_DSYS) = 166 MHz * freq(PCLK_DSYS) = 83 MHz * freq(HCLK_PSYS) = 133 MHz * freq(PCLK_PSYS) = 66 MHz * freq(SCLK_ONENAND) = 133 MHz, 166 MHz S5PV210时钟体系框图详解 (1)时钟体系框图的位置：数据手册P361&amp;P362，Figure3-3 (2)两张图之间是渐进的关系。第一张图从左到右依次完成了原始时钟生成-&gt;PLL倍频得到高频时钟-&gt;初次分频得到各总线时钟；第二张图是从各中间时钟（第一张图中某个步骤生成的时钟）到各外设自己使用的时钟（实际就是个别外设自己再额外分频的设置）。可见，第一张图是理解整个时钟体系的关键，第二种图是进一步分析各外设时钟来源的关键。 (3)要看懂时钟体系框图，2个符号很重要：一个是MUX开关，另一个是DIV分频器。 (3.1)MUX开关就是个或门，实际对应某个寄存器的某几个bit位的设置，设置值决定了哪条通道通的，分析这个可以知道右边的时钟是从左边哪条路过来的，从而知道右边时钟是多少。 (3.2)DIV分频器，是一个硬件设备，可以对左边的频率进行n分频，分频后的低频时钟输出到右边。分频器在编程时实际对应某个寄存器中的某几个bit位，我们可以通过设置这个寄存器的这些对应bit位来设置分频器的分频系数（譬如左边进来的时钟是80MHz，分频系统设置为8，则分频器右边输出的时钟频率为10MHz）。 (3.3)寄存器中的clock source x就是在设置MUX开关；clock divider control寄存器就是在设置分频器分频系数。 时钟设置的关键性寄存器 xPLL_LOCK：xPLL_LOCK寄存器主要控制PLL锁定周期的。 xPLL_CON/xPLL_CON0/xPLL_CON1：PLL_CON寄存器主要用来打开/关闭PLL电路，设置PLL的倍频参数，查看PLL锁定状态等 CLK_SRCn(n：0～6)：CLK_SRC寄存器是用来设置时钟来源的，对应时钟框图中的MUX开关。 CLK_SRC_MASKn：CLK_SRC_MASK决定MUX开关n选1后是否能继续通过。默认的时钟都是打开的，好处是不会因为某个模块的时钟关闭而导致莫名其妙的问题，坏处是功耗控制不精细、功耗高。 CLK_DIVn：各模块的分频器参数配置 CLK_GATE_x：类似于CLK_SRC_MASK，对时钟进行开关控制 CLK_DIV_STATn、CLK_MUX_STATn：这两类状态位寄存器，用来查看DIV和MUX的状态是否已经完成还是在进行中总结：其中最重要的寄存器有3类：CON、SRC、DIV。其中CON决定PLL倍频到多少，SRC决定走哪一路，DIV决定分频多少。 实验项目启动代码-01-watch dog timer123456# define WTCON 0xE2700000//关看门狗（向WTCON的bit5写入0即可）ldr r0, =WTCONldr r1, =0x0str r1, [r0] 启动代码-02-设置栈1234#define SVC_STACK 0xD0037D80//设置SVC栈ldr sp, =SVC_STACK 设置栈之后就可以用汇编代码调用C语言代码，从而将实验代码用C语言来实现。在工程中新建并且添加一个C语言源文件（start.c），注意添加时要修改Makefile。在汇编启动代码中设置好栈后，使用bl xxx的方式来调用C中的函数xxx 1234567%.o : %.S arm-linux-gcc -o $@ $&lt; -c -nostdlib%.o : %.c arm-linux-gcc -o $@ $&lt; -c -nostdlib//连接阶段报错undefined reference to `__aeabi_unwind_cpp_pr1`//解决：在编译时添加-nostdlib这个编译选项即可解决。nostdlib就是不使用标准函数库。标准函数库就是编译器中自带的函数库，用-nostdlib可以让编译器链接器优先选择我程序内自己写的函数库。 使用C语言访问寄存器 寄存器的地址类似于内存地址（IO与内存统一编址的），用C语言读写寄存器，就是用C语言来读写内存地址，就要用到指针。1234unsigned int *p = (unsigned int *)0xE0200240;*p = 0x11111111;*((unsigned int *)0xE0200240) = 0x11111111;//另一种写法 启动代码-03-icache汇编代码读写p15以开关icache mrc&amp;mcr指令 mrc指令将协处理器的寄存器中数值传送到ARM处理器的寄存器中。mrc{条件} 协处理器编码,协处理器操作码1,目的寄存器,源寄存器1,源寄存器2,协处理器操作码2 mcr指令将ARM处理器的寄存器中的数据传送到协处理器的寄存器中。mcr{条件} 协处理器编码,协处理器操作码1,源寄存器,目的寄存器1,目的寄存器2,协处理器操作码2 当中，”条件”为指令运行的条件码。当”条件”忽略时指令为无条件运行。例：mrc2中，”条件”为Ob1111,指令为无条件运行指令。 “协处理器编码”指定协处理器（p1-p15） “协处理器操作码1”为协处理器将运行的操作的操作码。对于P15协处理器来说，协处理器操作码1永远为0b000,当”协处理器操作码1”不为0b000时，该指令操作结果不可预知。 mrc和mcr指令中，”目的寄存器/源寄存器”为ARM寄存器，当指令为mrc时，协处理器寄存器（c1-c15）的值传送到ARM寄存器中；当指令为mcr时，ARM寄存器的值传送到协处理器寄存器（c1-c15）中。ARM寄存器不能为PC，当”目的寄存器”为PC时，指令操作结果不可预知。 mrc和mcr指令中，”源寄存器2/目的寄存器2”用于区分同一个编号的不同物理寄存器。当指令中不须要提供附加信息时，将C0指定为源寄存器2/目的寄存器2，否则指令操作结果不可预知。 “协处理器操作码2”提供附加信息，用于差别同一个编号的不同物理寄存器。当指令中指定附加信息时，省略协处理器操作码2或者将其指定为0,否则指令操作结果不可预知。 1234mrc p15,0,r0,c1,c0,0 // 该指令将协处理器p15的c1寄存器中的数据送到ARM处理器的r0寄存器中。bic r0, r0, #(1&lt;&lt;12) // bit12 置0 关icacheorr r0, r0, #(1&lt;&lt;12) // bit12 置1 开icachemcr p15,0,r0,c1,c0,0 // 该指令将ARM处理器的r0寄存器中的数据送到协处理器p15的c1寄存器中。 启动代码-04-重定位 在SRAM中将代码从0xd0020010重定位(relocate)到0xd0024000 本来代码是运行在0xd0020010的，但是因为一些原因我们又希望代码实际是在0xd0024000位置运行的。这时候就需要重定位了。这种情况对代码本身运行无实际意义，因为此代码为位置无关代码，但是某些情况重定位就是必须的，譬如在uboot中。 步骤 第一：通过链接脚本将代码链接到0xd0024000（先准备好下面的代码） 第二：dnw下载时将bin文件下载到0xd0020010 当把代码链接地址设置为0xd0024000时（Makefile、link.lds），实际隐含意思就是代码将来必须放在0xd0024000位置才能正确执行（除非代码是PIC位置无关码），就知道重定位代码的作用就是：在PIC执行完之前（在代码中第一句位置有关码执行之前）必须将整个代码搬移到0xd0024000位置去执行，这就是重定位。 第三：代码执行时通过代码前段的少量位置无关码（start.S）将整个代码搬移到0xd0024000（代码拷贝） 第四：清bss段（start.S），因为C语言规定显式初始化为0的全局变量，或者未显式初始化的全局变量的值为0 第五：使用一个长跳转跳转到0xd0024000处的代码继续执行（start.S），重定位完成 长跳转&amp;短跳转 长跳转：是一句跳转指令（ARM中的跳转指令就是类似于分支指令B、BL等作用的指令），跳转指令通过给PC（r15）赋一个新值来完成代码段的跳转执行。长跳转指的是跳转到的地址和当前地址差异比较大，跳转的范围比较宽广。 执行完代码重定位后，实际上在SRAM中有2份代码的镜像（一份是我们下载到0xd0020010处开头的，另一份是重定位代码复制到0xd0024000处开头的），这两份内容完全相同，仅仅地址不同。重定位之后使用ldr pc, =led_blink这句长跳转直接从0xd0020010处代码跳转到0xd0024000开头的那一份代码的led_blink函数处去执行。（实际上此时在SRAM中有2个led_blink函数镜像，两个都能执行，如果短跳转bl led_blink则执行的就是0xd0020010开头的这一份，如果长跳转ldr pc, =led_blink则执行的是0xd0024000开头处的这一份）。这就是短跳转和长跳转的区别。 当链接地址和运行地址相同时，短跳转和长跳转实际效果是一样的；但是当链接地址不等于运行地址时，短跳转和长跳转就有差异了。这时候短跳转实际执行的是运行地址处的那一份，而长跳转执行的是链接地址处那一份。 重定位实际就是在运行地址处执行一段位置无关码PIC，让这段PIC（也就是重定位代码）从运行地址处把整个程序镜像拷贝一份到链接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到链接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。 adr与ldr伪指令的区别 ldr和adr都是伪指令，区别是ldr是长加载、adr是短加载。 重点：adr指令加载符号地址，加载的是运行时地址；ldr指令在加载符号地址时，加载的是链接地址。 只要知道adr和ldr分别用于加载运行地址和链接地址，从而可以判断是否需要重定位即可。 重定位（代码拷贝） 重定位就是汇编代码中的copy_loop函数，代码的作用是使用循环结构来逐句复制代码到链接地址。 复制的源地址是SRAM的0xd0020010，复制目标地址是SRAM的0xd0024000，复制长度是bss_start减去_start 所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段+数据段的长度。 bss段（bss段中就是0初始化的全局变量）不需要重定位。 清bss段 清除bss段是为了满足C语言的运行时要求（C语言要求显式初始化为0的全局变量，或者未显式初始化的全局变量的值为0，实际上C语言编译器就是通过清bss段来实现C语言的这个特性的）。一般情况下我们的程序是不需要负责清零bss段的（C语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的main函数之前运行，这段代码就负责清除bss）。但是在我们代码重定位了之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的bss，而未清除重定位地址处开头的那一份代码的bss，所以重定位之后需要自己去清除bss。 长跳转 清理完bss段后重定位就结束了。然后当前的状况是： 1、当前运行地址还在0xd0020010开头的（重定位前的）那一份代码中运行着。 2、此时SRAM中已经有了2份代码，1份在d0020010开头，另一份在d0024000开头的位置。 然后就要长跳转了。 启动代码-05-初始化sdram 步骤 设置link.lds文件，将连接地址改为0x20000000（dram0开始地址） 设置Makefile文件，生成sdram_init.o文件 添加s5pv210.h文件，内容为寄存器、内存、移位等宏定义 修改start.S文件，跳转到sdram_asm_init.S文件初始化dram0 编写sdram_asm_init.S文件，初始化dram0 启动代码-06-设置时钟 步骤 设置Makefile文件，生成clock.o文件 修改start.S文件，bl clock_init短跳转到clock.S/clock.c文件设置时钟 编写clock.S文件，设置时钟 时钟设置的步骤： 第1步：先选择不使用PLL。让外部24MHz原始时钟直接过去，绕过APLL那条路 第2步：设置锁定时间。默认值为0x0FFF，保险起见可以设置为0xFFFF 第3步：设置PLL，主要是设置PLL的倍频系统，决定由输入端24MHz的原始频率可以得到多大的输出频率。默认设置输出为ARMCLK为1GHz 第4步：设置分频系统，决定由PLL出来的最高时钟如何分频得到各个分时钟 第5步：打开PLL。已经设置好了所有的开关和分频系数，打开PLL后PLL开始工作，锁定频率后输出，然后经过分频得到各个频率。全部步骤涉及的寄存器：5个。 第6步：收尾：mov pc, lr CLK_SRC寄存器的设置分析CLK_SRC寄存器其实是用来设置MUX开关的。在这里先将该寄存器设置为全0，主要是bit0和bit4设置为0，表示APLL和MPLL暂时都不启用。 CLK_LOCK寄存器的设置分析设置PLL锁定延时的。官方推荐值为0xFFF，我们设置为0xFFFF。 PLL倍频的相关计算(1)、设置了APLL和MPLL。(2)、APLL和MPLL设置的关键都是M、P、S三个值，这三个值来自于官方数据手册的推荐值。 CLK_DIV寄存器的设置分析 0x14131440含义分析： PCLK_PSYS = HCLK_PSYS / 2 HCLK_PSYS = MOUT_PSYS / 5 PCLK_DSYS = HCLK_DSYS / 2 HCLK_DSYS = MOUT_DSYS / 4 PCLK_MSYS = HCLK_MSYS / 2 HCLK_MSYS = ARMCLK / 5 SCLKA2M = SCLKAPLL / 5 ARMCLK = MOUT_MSYS / 1 时钟经过上面PLL倍增和DIV分频之后得到以下时钟经典值 freq(ARMCLK) = 1000 MHz freq(HCLK_MSYS) = 200 MHz freq(HCLK_IMEM) = 100 MHz freq(PCLK_MSYS) = 100 MHz freq(HCLK_DSYS) = 166 MHz freq(PCLK_DSYS) = 83 MHz freq(HCLK_PSYS) = 133 MHz freq(PCLK_PSYS) = 66 MHz freq(SCLK_ONENAND) = 133 MHz, 166 MHz 实验03-串口通信基本概念通信发展史(1)、历史上通信：烽火台、狼烟；信件；电子通信（电报、电话、网络信号） (2)、通信中最重要的两个方面：信息表示、解析方法 + 信息的传输方法。 (3)、通信双方事先需要约定好信息的表示方法和解析方法，做到一致，否则信息不能有效传递。 (4)、信号的传输方法是指经过编码后的通信信息如何在传输介质上传输的过程。总结：通信过程其实分为3个步骤：首先发送方先按照信息编码方式对有效信息进行编码（编程成可以在通信线路上传输的信号形态），然后编码后的信息在传输介质上进行传输，输送给接收方；最后接收方接收到编码信息后进行解码，解码后得到可以理解的有效信息。 电子通信概念1：同步通信和异步通信 (1)、同步和异步的区别：首先很多地方都有同步和异步的概念，简单来说就是发送方和接收方按照同一个时钟节拍工作就叫同步，发送方和接收方没有统一的时钟节拍、而各自按照自己的节拍工作就叫异步。 (2)、同步通信中，通信双方按照统一节拍工作，所以配合很好；一般需要发送方给接收方发送信息同时发送时钟信号，接收方根据发送方给它的时钟信号来安排自己的节奏。同步通信用在通信双方信息交换频率固定，或者经常通信时。 (3)、异步通信又叫异步通知。在双方通信的频率不固定时（有时3ms收发一次，有时3天才收发一次）不适合使用同步通信，而适合异步通信。异步通信时接收方不必一直在意发送方，发送方需要发送信息时会首先给接收方一个信息开始的起始信号，接收方接收到起始信号后就认为后面紧跟着的就是有效信息，才会开始注意接收信息，直到收到发送方发过来的结束标志。 电子通信概念2：电平信号和差分信号 (1)、电平信号和差分信号是用来描述通信线路传输方式的。也就是说如何在通信线路上表达1和0. (2)、电平信号的传输线中有一个参考电平线（一般是GND），然后信号线上的信号值是由信号线电平和参考电平线的电压差决定。 (3)、差分信号的传输线中没有参考电平，所有都是信号线。然后1和0的表达靠信号线之间的电压差。总结：电平信号的2根通信线之间的电平差异容易受到干扰，传输容易失败；差分信号不容易受到干扰因此传输质量比较稳定，现代通信一般都使用差分信号，电平信号几乎没有了。总结2：看起来似乎相同根数的通信线下，电平信号要比差分信号要快；但是实际还是差分信号快，因为差分信号抗干扰能力强，因此1个发送周期更短。 电子通信概念3：并行接口和串行接口 (1)、串行、并行主要是考虑通信线的根数，就是发送方和接收方同时可以传递的信息量的多少 (2)、譬如在电平信号下，1根参考电平线+1根信号线可以传递1位二进制；如果我们有3根线（2根信号线+1根参考线）就可以同时发送2位二进制；如果想同时发送8位二进制就需要9根线。 (3)、在差分信号下，2根线（彼此差分）可以同时发送1位二进制；如果需要同时发送8位二进制，需要16根线。总结：听起来似乎并行接口比串行接口要快（串行接口一次只能发送1位二进制，而并行接口一次可以发送多位二进制）要更优秀；但是实际上串行接口才是王道，用的比较广。因为更省信号线，而且对传输线的要求更低、成本更低；而且串行时可以通过提高通信速度来提高总体通信性能，不一定非得要并行。 总结：其实这么多年发展，最终胜出的是：异步、串行、差分，譬如USB和网络通信。 串口通信 串口通信的基本概念 串口通信的特点：异步、电平信号、串行 (1)、异步：串口通信的发送方和接收方之间是没有统一的时钟信号的。 (2)、电平信号：串口通信出现的时间较早，速率较低，传输的距离较近，所以干扰还不太明显，因此当时使用了电平信号传输。后期出现的传输协议都改成差分信号传输了。 (3)、串行通信：串口通信每次同时只能传输1个二进制位。 RS232电平和TTL电平 (1)电平信号是用信号线电平减去参考线电平得到电压差，这个电压差决定了传输值是1还是0（就像水位一样，高于地面多少为涨潮，低于多少为退潮）. (2)在电平信号时多少V代表1，多少V代表0不是固定的，取决于电平标准。譬如RS232电平中-3V～-15V表示1；+3～+15V表示0；TTL电平则是+5V表示1，0V表示0. (3)不管哪种电平都是为了在传输线上表示1和0.区别在于适用的环境和条件不同。RS232的电平定义比较大，适合干扰大、距离远的情况；TTL电平电压范围小，适合距离近且干扰小的情况。 (4)我们台式电脑后面的串口插座就是RS232接口的，在工业上用串口时都用这个，传输距离小于15米；TTL电平一般用在电路板内部两个芯片之间。 (5)对编程来说，RS232电平传输还是TTL电平是没有差异的。所以电平标准对硬件工程师更有意义，而软件工程师只要略懂即可。（把TTL电平和RS232电平混接是不可以的） 波特率 (1)波特率（bandrate），指的是串口通信的速率，也就是串口通信时每秒钟可以传输多少个二进制位。譬如每秒种可以传输9600个二进制位（传输一个二进制位需要的时间是1/9600秒，也就是104us），波特率就是9600. (2)串口通信的波特率不能随意设定，而应该在一些值中去选择。一般最常见的波特率是9600或者115200（低端单片机如51常用9600，高端单片机和嵌入式SoC一般用115200）.为什么波特率不可以随便指定？主要是因为：第一，通信双方必须事先设定相同的波特率这样才能成功通信，如果发送方和接收方按照不同的波特率通信则根本收不到，因此波特率最好是大家熟知的而不是随意指定的。第二，常用的波特率经过长久发展，就形成了共识，大家常用就是9600或者115200. 起始位、数据位、奇偶校验位、停止位 (1)串口通信时，收发是一个周期一个周期进行的，每周期传输n个二进制位。这一个周期就叫做一个通信单元，一个通信单元是由：起始位+数据位+奇偶校验位+停止位组成的。 (2)起始位表示发送方要开始发送一个通信单元；数据位是一个通信单元中发送的有效信息位；奇偶校验位是用来校验数据位，以防止数据位出错的；停止位是发送方用来表示本通信单元结束标志的。 (3)起始位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。 (4)数据位是本次通信真正要发送的有效数据，串口通信一次发送多少位有效数据是可以设定的（一般可选的有6、7、8、9，99%情况下我们都是选择8位数据位。因为我们一般通过串口发送的文字信息都是ASCII码编码的，而ASCII码中一个字符刚好编码为8位。） (5)奇偶校验位是用来给数据位进行奇偶校验（把待校验的有效数据逐个位的加起来，总和为奇数奇偶校验位就为1，总和为偶数奇偶校验位就为0）的，可以在一定程度上防止位反转。 (6)停止位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。常见的有1位停止位，1.5位停止位，2位停止位等。99%情况下都是用1位停止位。 总结：串口通信时因为是异步通信，所以通信双方必须事先约定好通信参数，这些通信参数包括：波特率、数据位、奇偶校验位、停止位（串口通信中起始位定义是唯一的，所以一般不用选择） 串口通信的基本原理 单工通信和双工通信(1)单工就是单方向，双工就是双方同时收发，同时只能但方向但是方向可以改变叫半双工 (2)如果只能A发B收则单工，A发B收或者B发A收（两个方向不能同时）叫半双工，A发B收同时B发A收叫全双工。 三根通信线：Rx Tx GND(1)任何通信都要有信息传输载体，或者是有线的或者是无线的。 (2)串口通信是有线通信，是通过串口线来通信的。 (3)串口通信线最少需要2根（GND和信号线），可以实现单工通信，也可以使用3根通信线（Tx、Rx、GND）来实现全双工。 (4)一般开发板都会引出SoC上串口引脚直接输出的TTL电平的串口（X210开发板没有），插座用插针式插座，每个串口引出的都有3个线（Tx、Rx、GND），可以用这些插座直接连接外部的TTL电平的串口设备。 通信参数（波特率、数据位、奇偶校验位、停止位等） (1)串口通信属于基层基本性的通信规约，它自己本身不会去协商通信参数，需要通信前通信双方事先约定好通信参数（一般4个最重要的） (2)串口通信的任何一个关键参数设置错误，都会导致通信失败。譬如波特率调错了，发送方发送没问题，接收方也能接收，但是接收到全是乱码··· 信息以二进制流的方式在信道上传输 (1)、串口通信的发送方每隔一定时间（时间固定为1/波特率，单位是秒）将有效信息（1或者0）放到通信线上去，逐个二进制位的进行发送。 (2)接收方通过定时（起始时间由读到起始位标志开始，间隔时间由波特率决定）读取通信线上的电平高低来区分发送给我的是1还是0。依次读取数据位、奇偶校验位、停止位，停止位就表示这一个通信单元（帧）结束，然后中间是不定长短的非通信时间（发送方有可能紧接着就发送第二帧，也可能半天都不发第二帧，这就叫异步通信），下来就是第二帧·····总结：第一，波特率非常重要；第二，数据位、奇偶校验位、停止位也很重要，否则可能认不清数据。第三，通过串口不管发数字、还是文本还是命令还是什么，都要先对发送内容进行编码，编码成二进制再进行逐个位的发送。 (3)串口发送的一般都是字符，一般都是ASCII码编码后的字符，所以一般设置数据位都是8，方便刚好一帧发送1个字符。 DB9接口介绍 (1)DB9接口是串口通信早期比较常用的一种规范化接口。 (2)串行通信在早期是计算机与外界通信的主要手段，那时候的计算机都有标准配置的串口以实现和外部通信。那时候就定义了一套标准的串口规约，DB9接口就是标准接口。 (3)DB9接口中有9根通信线，其中3根很重要，为GND、Tx、Rx，必不可少；剩余6根都是和流控有关的，现代我们使用串口都是用来做调试一般都禁用流控，所以这6根没用。 (4)现在一般使用串口时要记得把流控禁止掉，不然可能发生意想不到的问题。 S5PV210串行通信接口 串口的名称(1)S5PV210的数据手册中串口控制器在section8.1 (2)串口的官方名称叫：universal asynchronous reciver and transmitter，通用异步收发器。英文缩写是uart，中文简称串口。 S5PV210的串口控制器工作原理框图 (1)整个串口控制器包含transmitter和receiver两部分，两部分功能彼此独立，transmitter负责210向外部发送信息，receiver负责从外部接收信息到210内部。 (2)总线角度来讲，串口控制器是接在APB总线上的。对我们编程有影响的是：将来计算串口控制器的源时钟时是以APB总线来计算的。 (3)transmitter由发送缓冲区和发送移位器构成。我们要发送信息时，首先将信息进行编码（一般用ASCII码）成二进制流，然后将一帧数据（一般是8位）写入发送缓冲区（从这里以后程序就不用管了，剩下的发送部分是硬件自动的），发送移位器会自动从发送缓冲区中读取一帧数据，然后自动移位（移位的目的是将一帧数据的各个位分别拿出来）将其发送到Tx通信线上。 (4)receiver由接收缓冲区和接收移位器构成。当有人通过串口线向我发送信息时，信息通过Rx通信线进入我的接收移位器，然后接收移位器自动移位将该二进制位保存入我的接收缓冲区，接收完一帧数据后receiver会产生一个中断给CPU，CPU收到中断后即可知道receiver接收满了一帧数据，就会来读取这帧数据。 总结：发送缓冲区和接收缓冲区是关键。发送移位器和接收移位器的工作都是自动的，不用编程控制的，所以我们写串口的代码就是：首先初始化（初始化的实质是读写寄存器）好串口控制器（包括发送控制器和接收控制器），然后要发送信息时直接写入发送缓冲区，要接收信息时直接去接收缓冲区读取即可。可见，串口底层的工作（譬如怎么移位的、譬如起始位怎么定义的、譬如TTL电平还是RS232电平等）对程序员是隐藏的，程序员不用去管。软件工程师对串口操作的接口就是发送/接收缓冲区（实质就是寄存器，操作方式就是读写内存） (5)串口控制器中有一个波特率发生器，作用是产生串口发送/接收的节拍时钟。波特率发生器其实就是个时钟分频器，它的工作需要源时钟（APB总线来），然后内部将源时钟进行分频（软件设置寄存器来配置）得到目标时钟，然后再用这个目标时钟产生波特率（硬件自动的）。 自动流控（AFC：Auto flow control） (1)为什么需要流控？流控的目的是让串口通信非常可靠，在发送方速率比接收方快的时候流控可以保证发送和接收不会漏掉东西。 (2)现在为什么不用流控？现在计算机之间有更好更高级（usb、internet）的通讯方式，串口已经基本被废弃了。现在串口的用途更多是SoC用来输出调试信息的。由于调试信息不是关键性信息、而且由于硬件发展串口本身速度已经相对很慢了，所以硬件都能协调发送和接收速率，因此流控已经失去意义了，所以现在基本都废弃了。 串口高级功能技术发展给串口叠加了一些高级功能，在像210这类的高级SoC的串口控制器中，都有这类高级功能。 FIFO模式及其作用 (1)典型的串口设计，发送/接收缓冲区只有1字节，每次发送/接收只能处理1帧数据。这样在单片机中没什么问题，但是到复杂SoC中（一般有操作系统的）就会有问题，会导致效率低下，因为CPU需要不断切换上下文。 (2)解决方案就是想办法扩展串口控制器的发送/接收缓冲区，譬如将发送/接收缓冲器设置为64字节，CPU一次过来直接给发送缓冲区64字节的待发送数据，然后transmitter慢慢发，发完再找CPU再要64字节。但是串口控制器本来的发送/接收缓冲区是固定的1字节长度的，所以做了个变相的扩展，就是FIFO。 (3)FIFO就是first in first out，先进先出。fifo其实是一种数据结构，这里这个大的缓冲区叫FIFO是因为这个缓冲区的工作方式类似于FIFO这种数据结构。 DMA模式及其作用 (1)DMA direct memory access，直接内存访问。DMA本来是DSP中的一种技术，DMA技术的核心就是在交换数据时不需要CPU参与，模块可以自己完成。 (2)DMA模式要解决的问题和上面FIFO模式是同一个问题，就是串口发送/接收要频繁的折腾CPU造成CPU反复切换上下文导致系统效率低下。 (3)传统的串口工作方式（无FIFO无DMA）效率是最低的，适合低端单片机；高端单片机上CPU事物繁忙所以都需要串口能够自己完成大量数据发送/接收。这时候就需要FIFO或者DMA模式。FIFO模式是一种轻量级的解决方案，DMA模式适合大量数据迸发式的发送/接收时。 IrDA模式及其用法 (1)IrDA其实就是红外，红外就是红外线通信（电视机、空调遥控器就是红外通信的）。 (2)红外通信的原理是发送方固定间隔时间向接收方发送红外信号（表示1或0）或者不发送红外信号（表示0或者1），接收方每隔固定时间去判断有无红外线信号来接收1和0. (3)分析可知，红外通信和串口通信非常像，都是每隔固定时间发送1或者0（判断1或0的物理方式不同）给接收方来通信。因此210就利用串口通信来实现了红外发送和接收。 (4)210的某个串口支持IrDA模式，开启红外模式后，我们只需要向串口写数据，这些数据就会以红外光的方式向外发射出去（当然是需要一些外部硬件支持的），然后接收方接收这些红外数据即可解码得到我们的发送信息。 串行通信与中断的关系 (1)串口通信分为发送/接收2部分。发送方一般不需要（也可以使用）中断即可完成发送，接收方必须（一般来说必须，也可以轮询方式接收）使用中断来接收。 (2)发送方可以选择使用中断，也可以选择不使用中断。使用中断的工作情景是：发送方先设置好中断并绑定一个中断处理程序，然后发送方丢一帧数据给transmitter，transmitter发送耗费一段时间来发送这一帧数据，这段时间内发送方CPU可以去做别的事情，等transmitter发送完成后会产生一个TXD中断，该中断会导致事先绑定的中断处理程序执行，在中断处理程序中CPU会切换回来继续给transmitter放一帧数据，然后CPU切换离开；不使用中断的工作情景是：发送方事先禁止TXD中断（当然也不需要给相应的中断处理程序了），发送方CPU给一帧数据到transmitter，然后transmitter耗费一段时间来发送这帧数据，这段时间CPU在这等着（CPU没有切换去做别的事情），待发送方发送完成后CPU再给它一帧数据继续发送直到所有数据发完。CPU是怎么知道transmitter已经发送完了？原来是有个状态寄存器，状态寄存器中有一个位叫发送缓冲区空标志，transmitter发送完成（发送缓冲区空了）就会给这个标志位置位，CPU就是通过不断查询这个标志位为1还是0来指导发送是否已经完成的。 (3)因为串口通信是异步的，异步的意思就是说发送方占主导权。也就是说发送方随时想发就能发，但是接收方只有时刻等待才不会丢失数据。所以这个差异就导致发送方可以不用中断，而接收方不得不使用中断模式。 210串行通信接口的时钟设计 (1)串口通信为什么需要时钟？因为串口通信需要一个固定的波特率，所以transmitter和receiver都需要一个时钟信号。 (2)时钟信号从哪里来？源时钟信号是外部APB总线（PCLK_PSYS，66MHz）提供给串口模块的（这就是为什么我们说串口是挂在APB总线上的），然后进到串口控制器内部后给波特率发生器（实质上是一个分频器），在波特率发生器中进行分频，分频后得到一个低频时钟，这个时钟就是给transmitter和receiver使用的。 (3)串口通信中时钟的设置主要看寄存器设置。重点的有：寄存器源设置（为串口控制器选择源时钟，一般选择为PCLK_PSYS，也可以是SCLK_UART），还有波特率发生器的2个寄存器。 (4)波特率发生器有2个重要寄存器：UBRDIVn和UDIVSLOTn，其中UBRDIVn是主要的设置波特率的寄存器，UDIVSLOTn是用来辅助设置的，目的是为了校准波特率的。 编程过程 x210串口通信编程 (1)整个串口通信相关程序（函数）包含2部分：uart_init负责初始化串口，uart_putc负责发送一个字节 串口控制器初始化关键步骤 (1)初始化串口的Tx和Rx引脚所对应的GPIO（查原理图可知Rx和Rx分别对应GPA0_1和GPA0_0） (2)GPA0CON（0xE0200000），bit[3:0] = 0b0010 bit[7:4] = 0b0010 (3)初始化这几个关键寄存器UCON0 ULCON0 UMCON0 UFCON0 UBRDIV0 UDIVSLOT0 主要的寄存器(1)ULCON0 = 0x3 // 0校验位、8数据位、1停止位(2)UCON0 = 0x5 // 发送和接收都是polling mode(3)UMCON0 = 0x0 // 禁止modem、afc(4)UFCON0 = 0x0 // 禁止FIFO模式(5)UBRDIV0和UDIVSLOT0和波特率有关，根据公式算。 波特率的计算和设置 (1)第一步，用PCLK_PSYS（第三章，uart的PCLK_PSYS默认为66MHz，但实际计算分频之后为66.7MHz）和目标波特率去计算DIV_VAL: DIV_VAL = (PCLK / (bps x 16)) - 1 (2)第二步，UBRDIV0寄存器中写入DIV_VAL的整数部分 (3)第三步，用小数部分X16得到1个个数，查表得uBDIVSLOT0寄存器的设置值 在C源文件中定义访问寄存器的宏 (1)定义访问寄存器的宏，将来写代码时直接使用即可。 (2)串口Tx、Rx对应的GPIO的初始化，给GPA0CON的相应bit位赋值为相应值，用C语言位操作来完成。 (3)设置UCON、ULCON、UMCON、UFCON等主要控制寄存器。 (4)设置UBRDIV0和UDIVSLOT0等寄存器。 (5)串口发送和接收函数的编写，发送前要用while循环等待发送缓冲区为空才能发送。 更改波特率程序中改了波特率后，SecureCRT也要相应修改，不然收不到东西。 uart stdio的移植 (1)库头文件：#include &lt;stdio.h&gt; (2)stdio：standard input output，标准输入输出 (3)标准输入输出就是操作系统定义的默认的输入和输出通道。一般在PC机的情况下，标准输入指的是键盘，标准输出指的是屏幕。 (4)printf函数和scanf函数可以和底层输入/输出函数绑定，然后这两个函数就可以和stdio绑定起来。直接调用printf函数输出，内容就会被从标准输出输出出去。 (5)此实验标准输出不是屏幕，是串口。标准输入不是键盘，也是串口。 printf函数的工作原理 (1)printf函数工作时内部实际调用了2个关键函数：一个是vsprintf函数（主要功能是格式化打印信息，最终得到纯字符串格式的打印信息等待输出），另一个就是真正的输出函数putc（操控标准输出的硬件，将信息发送出去） 移植printf函数的三种思路 (1)我们希望在我们的开发板上使用printf函数进行（串口）输出，使用scanf函数进行（串口）输入，就像在PC机上用键盘和屏幕进行输入输出一样。因此需要移植printf函数/scanf函数。 (2)一般移植printf函数可以有3个途径获取printf的实现源码：最原始最原本的来源就是linux内核中的printf。难度较大、关键是麻烦；稍微简单些的方法是从uboot中移植printf；更简单的方法就是直接使用别人移植好的。 (3)课程中使用第三种方法，别人移植好的printf函数来自于友善之臂的Tiny210的裸机教程中提供的。 修改Makefile进行printf移植 添加link.lds链接脚本，指定连接地址到0xd0020010 gcc可变参数及va_arg介绍(1)printf函数中首先使用了C语言的可变参数va_start/va_arg/va_end；(2)了解C语言可变参数再分析。(3)vsprintf函数详解printf-vsprintf-vsnprintf-numbervsprintf函数的作用是按照的printf传进去的格式化标本，对变参进行处理，然后将之格式化后缓存在一个事先分配好的缓冲区中。printf后半段调用putc函数将缓冲区中格式化好的字符串直接输出到标准输出。 串口实验烧录问题总结 usb下载(1)有时下载不了、有时下载但运行不了、有时正常下载运行。使用其他的dnw或更新dnw驱动，无法解决。 SD卡镜像烧录(1)Windows下烧录镜像是使用九鼎提供的工具（X210光盘资料\A盘\tools\x210_Fusing_Tool.exe），注意运行时右键“以管理员身份运行”。 (2)Linux下参考SD卡烧录镜像做裸机实验。 启动方式设置(1)X210开发板的启动方式的选择，OM5设置为VCC则从USB启动，OM5设置成GND，则从iNand/SD卡启动。 (2)开发板选择从iNand启动后，还要确保iNand中uboot是被擦除的。 (3)关于如何破坏uboot，在linux/android系统中破坏uboot的方法。在uboot中破坏uboot的方法：movi write u-boot 0x30000000。有人擦除后错乱，进不了系统也从SD卡启动不了。方法一，改为：mw 0x30000000 0x0 0x100000，然后再movi write u-boot 0x30000000。 (4)先用SD卡烧录启动之前的LED的项目，确保看到现象就证明烧录SD卡方法和启动SD卡都成功了，再做本节课的实验。 链接脚本的影响通过USB下载最多也只能下载96KB大小的bin，如果bin大于96KB，SRAM放不下会出错。如果用SD卡启动，那么mkv210_image.c决定了bin文件最大不能超过16KB。文件过大，解决方法： 第一，在USB下载时，可以先下载一个x210_usb.bin，然后再将裸机程序连接到0x23E00000，然后再修改dnw中下载地址，将裸机代码下载到0x23E00000运行。（这时不需要重定位了） 第二，在SD卡启动时，将整个裸机程序分为2部分；第一部分大小16KB以内，第二部分放剩下的（放在SD卡的后面的某个扇区开始的位置，譬如放在第50个扇区开始的位置），然后在裸机代码中进行重定位（SD卡中重定位）。 实验项目串口通信-01-设置串口 步骤 设置Makefile文件，生成uart.o文件 修改start.S文件，ldr pc, =uart_main长跳转到uart.c文件设置时钟 编写uart.c文件(用led.c文件修改)，初始化串口和编写发送、接收函数 串口通信-02-修改比特率 步骤 查看数据手册，得到波特率计算公式（常用波特率：115200、9600） 根据波特率和公式，修改uart.c文件的相关寄存器。 修改secureCRT连接时的波特率。 串口通信-03-移植printf 步骤 复制要移植的头文件和库文件到代码目录下 修改uart.c文件，加上”stdio.h”头文件和调用里面的printf函数 修改Makefile文件，使其和lib文件夹里面的Makefile风格一致并调用它 实验04-中断基本概念按键中断 物理特性一般的按键都有4个引脚，这4个引脚成2对：其中一对是常开触点（不按则断开，按下则闭合）；一对是常闭触点（平时不按时是闭合的，按下后是断开的） 电学原理（结合原理图分析） (1)硬件接法：SW5:GPH0_2 SW6:GPH0_3 SW7-SW10:GPH2_0-GPH2_3 (2)按键的电路连接分析：平时按钮没有按下时，按钮内部断开，GPIO引脚处电压为高电平；当有人按下按钮时，按钮内部导通，外部VDD经过电阻和按钮连接到地，形成回路，此时GPIO引脚处电压就变成了低电平。此时VDD电压全部分压在了电阻上（这个电阻就叫分压电阻，这个电阻不能太小，因为电阻的功率是U^2/R） (3)总结：按键的工作方法：其实就是按键的按下与弹开，分别对应GPIO的两种电平状态（按下则GPIO为低电平，弹开则GPIO为高电平）。此时SoC内部可以通过检测这个GPIO的电平高低来判断按键有没有被按下，这个判断结果即可作为SoC的输入信号。 按键属于输入类设备 (1)按键一般用来做输入设备（由人向SoC发送信息的设备，叫输入设备），由人向SoC发送按键信号（按键信号有2种：按下信号和弹开信号）。 (2)有些设备就是单纯的输入设备，譬如按键、触摸屏等；有些设备就是单纯的输出设备，譬如LCD；还有一些设备是既能输入又能输出的，叫输入输出设备（IO），譬如串口。 按键的2种响应方法 (1)SoC处理按键有2种思路：轮询方式和中断方式。 (2)轮询方式，就是SoC主动的每隔一段时间去读取（按键所对应的）GPIO的电平高低，以此获得按键信息；缺点在于CPU要一直注意按键事件，会影响CPU做其他事情。 (3)中断方式，就是SoC事先设定好GPIO触发的中断所对应的中断处理程序ISR，当外部按键按下或弹开时会自动触发GPIO对应的外部中断，导致ISR执行，从而自动处理按键信息。 轮询方式 按键对应的GPIO模式设置 (1)按键接到GPIO上，按键按下还是弹起，决定外部电路的接通与否，从而决定这个GPIO引脚的电压是高还是低；这个电压可以作为这个GPIO引脚的输入信号，此时GPIO配置为输入模式，即可从SoC内部读取该引脚的电平为1还是0（1对应高电平，0对应低电平）。 (2)GPH0CON(0xE0200C00) GPH0DAT(0xE0200C04) GPH2CON(0xE0200C40) GPH2DAT(0xE0200C44) (3)应该在CON寄存器中将GPIO设置为input模式，然后去读取DAT寄存器（读取到的相应位的值为1表示外部是高电平（对应按键弹起），读取到的位的值为0表明外部是低电平（按键按下）） 轮询方式处理按键的程序流程 (1)第一步，先初始化GPIO模式为input； (2)第二步，循环读取GPIO的电平值，然后判断有无按键按下 什么是按键消抖 (1)按键这种物理器件本身会有抖动信号，抖动信号指的是在电平由高到低（也就是按键按下时）或者电平由低到高（也就是按键弹起时）过程中，电平的变化不是立刻变化，而是经过了一段时间的不稳定期才完成变化，在这个不稳定期间电平可能会时高时低反复变化，这个不稳定期就叫抖动（抖动期内获取按键信息是不可靠的，要想办法消抖）。 (2)什么叫消抖？消抖就是用硬件或者软件方法来尽量减小抖动期对按键获取的影响。消抖常用2种思路：第一是硬件消抖，消抖思路就是尽量减小抖动时间，方法是通过硬件添加电容等元件来减小抖动；第二是软件消抖，消抖思路是发现一次按键按下/弹起事件后，不立即处理按键，而是延时一段时间（一般10～20ms，这就是消抖时间）后再次获取按键键值，如果此次获取和上次一样是按下/弹起，那就认为真的按下/弹起了。 (3)一般比较精密需要的时候，需要硬件消抖和软件消抖一起配合。 中断体系 什么是中断 (1)中断的发明是用来解决宏观上的并行需要的。宏观就是从整体上来看，并行就是多件事情都完成了。 (2)微观上的并行，就是指的真正的并行，就是精确到每一秒甚至每一刻，多个事情都是在同时进行的。宏观上面的并行并不等于围观的并行，有时候宏观上是并行的，微观上是串行的。 (3)为什么需要中断？因为单核CPU实际无法并行的，但是通过中断机制，可以实现假并行。 SoC对中断的实现机制：异常向量表 (1)异常向量表是CPU中某些特定地址的特定定义。当中断发生的时候，中断要想办法通知CPU去处理中断，怎么做到？这就要靠异常向量表。 (2)在CPU设计时，就事先定义了CPU中一些特定地址作为特定异常的入口地址（譬如定义0x00000000地址为复位异常向量地址，则发生复位异常时CPU会自动跳转到0x00000000地址去执行指令。又譬如外部中断对应的异常向量地址为0x30000008，则发生外部中断后，CPU会硬件自动跳转到0x30000008地址去执行指令。） (3)以上讲的是CPU硬件设计时对异常向量表的支持，下来就需要软件支持了。硬件已经决定了发生什么异常CPU自动跳转PC到哪个地址去执行，软件需要做的就是把处理这个异常的代码的首地址填入这个异常向量地址。 S5PV210的异常向量表 (1)异常向量表中各个向量的相对位置是固定的，但是他们的起始地址是不固定的，各种SoC可以不一样，而且复杂ARM中还可以让用户来软件设置这个异常向量表的基地址。 (2)扩展到所有架构的CPU中：所有架构（譬如51单片机、PIC单片机）的CPU实现中断都是通过异常向量表实现的，这个机制是不变的；但是不同CPU异常向量表的构造和位置是不同的。 异常和中断的区别和联系 (1)针对SoC来说，发生复位、软中断、中断、快速中断、取指令异常、数据异常等，我们都统一叫异常。所以说：中断其实是异常的一种。 (2)异常的定义就是突发事件，打断了CPU的正常常规业务，CPU不得不跳转到异常向量表中去执行异常处理程序；中断是异常的一种，一般特指SoC内的内部外设产生的打断SoC常规业务，或者外部中断（SoC的GPIO引脚传回来的中断）。 异常向量表的编程处理 像内存一样去访问异常向量表(1)S5PV210的异常向量表可以改变（在CP15协处理器中），以适应操作系统的需求。但是目前系统刚启动时，此时DRAM尚未初始化，程序都在SRAM中运行。210在iRAM中设置了异常向量表，供暂时性使用。 (2)查210的iROM application note文档中iRAM的地址分配，可知，iRAM中的异常向量表起始地址为0xD0037400。知道了异常向量表的起始地址后，各个异常对应的入口就很好知道了。 函数名的实质就是函数的首地址(1)函数名在C语言中的理解方法和变量名其实没区别。编译器会把这个函数的函数体对应的代码段和这个函数的函数名（实质是符号）对应起来，等我们在使用这个函数名符号时，编译器会将函数的函数体实际上做替换。因为函数体都不止4字节，而函数名这个符号只能对应1个地址，所以实际对应的是函数体那一个代码段的首地址。 (2)拿C语言中的语法来讲，函数名就是这个函数的函数指针。 总结：当我们将异常处理程序的首地址和异常向量表绑定起来后，异常处理初步阶段就完成了。到目前可以保证相应异常发生后，硬件自动跳转到对应异常向量表入口去执行时，可以执行到我们事先绑定的函数。 为什么中断处理要先在汇编中进行 (1)中断处理要注意保护现场（中断从SVC模式来，则保存SVC模式下的必要寄存器的值）和恢复现场（中断处理完成后，准备返回SVC模式前，要将保存的SVC模式下的必要寄存器的值恢复回去，不然到了SVC模式后寄存器的值乱了，SVC模式下原来正在进行的常规任务就被你搞坏了） (2)保存现场包括：第一：设置IRQ栈；第二，保存LR；第三，保存R0～R12 (3)为什么要保存LR寄存器？要考虑中断返回的问题。中断ISR执行完后如何返回SVC模式下去接着执行原来的代码。中断返回其实取决于我们进入中断时如何保存现场。中断返回时关键的2个寄存器就是PC和CPSR。所以我们在进入IRQ模式时，应该将SVC模式下的下一句指令的地址（中断返回地址）和CPSR保存起来，将来恢复时才可以将中断返回地址给PC，将保存的CPSR给CPSR。 (4)中断返回地址就保存在LR中，而CPSR（自动）保存在（IRQ模式下的）SPSR中 汇编保存现场和恢复现场(1)保护现场关键是保存：中断处理程序的返回地址，r0-r12（cpsr是自动保存的）(2)恢复现场主要是恢复：r0-r12，pc，cpsr S5PV210的向量中断控制器 异常处理的2个阶段(1)可以将异常处理分为2个阶段来理解。第一个阶段是异常向量表跳转；第二个阶段就是进入了真正的异常处理程序irq_handler之后的部分。 回顾：中断处理的第一阶段（异常向量表阶段）处理。(1)第一个阶段之所以能够进行，主要依赖于CPU设计时提供的异常向量表机制。第一个阶段的主要任务是从异常发生到响应异常并且保存/恢复现场、跳转到真正的异常处理程序处。(2)第二个阶段的目的是识别多个中断源中究竟哪一个发生了中断，然后调用相应的中断处理程序来处理这个中断。 S3C2440的第二阶段处理过程(1)第一个问题，怎么找到具体是哪个中断：S3C2440的中断控制器中有一个寄存器（32位的），寄存器的每一个位对应一个中断源（为了解决支持更多中断源，2440又设计了一个子中断机制。在一级中断寄存器中有一些中断是共用的一个bit位，譬如AC97和WDT。对于共用中断，用子中断来区分究竟是哪一个发生了中断） (2)第二个问题，怎么找到对应的isr的问题：首先给每个中断做了个编号，进入isr_handler之后先通过查阅中断源寄存器和子中断寄存器（中哪一位为1）确定中断的编号，然后用这个编号去isr数组（isr数组是中断初始化时事先设定好的，就是把各个中断的isr的函数名组成一个数组，用中断对应的编号作为索引来查询这个数组）中查阅得到isr地址。 评价：2440的中断处理设计不是特别优秀：第一个过程中使用子中断搞成2级的很麻烦；第二个过程中计算中断编号是个麻烦事，很耗费时间。而中断处理的时间是很宝贵的（系统有一个性能指标，叫实时性。实时性就是中断发生到响应的时间，这个时间越短越好。） S5PV210的第二阶段处理过程(1)第一个问题，怎么找到具体是哪个中断：S5PV210中因为支持的中断源很多，所以直接设计了4个中断寄存器，每个32位，每位对应一个中断源。（理论上210最多支持128个中断，实际支持不足128个，有些位是空的）；210没有子中断寄存器，每个中断源都是并列的。当中断发生时，在irq_handler中依次去查询4个中断源寄存器，看哪一个的哪一位被置1，则这个位对应的寄存器就发生了中断，即找到了中断编号。 (2)第二个问题，怎么找到对应的isr的问题：210中支持的中断源多了很多，如果还使用2440的那一套来寻找isr地址就太慢了，太影响实时性了。于是210开拓了一种全新的寻找isr的机制。210提供了很多寄存器来解决每个中断源对应isr的寻找问题，具体寻找过程和建立过程见下节，实现的效果是当发生相应中断时，硬件会自动的将相应isr推入一定的寄存器中，我们软件只要去这个寄存器中执行函数就行了。 总结：第一阶段都相同，第二阶段各不同 (1)第一阶段（异常向量表阶段）2440和210几乎是完全相同的。实际上几乎所有的CPU在第一阶段都是相同的。 (2)第二阶段就彼此不同了。各个SoC根据自己对实时性的要求，和支持的中断源的多少，各自发明了各自处理中断，找到中断编号，进一步找到对应isr地址的方式。 中断寄存器 VICnINTENABLE和VICnINTENCLEAR (1)VICnINTENABLE对应interrupt enable，INTENCLEAR对应interrupt enable clear (2)INTENABLE寄存器负责相应的中断的使能，INTENCLEAR寄存器负责相应的中断的禁止。 (3)当我们想使能（意思就是启用这个中断，意思就是当硬件产生中断时CPU能接收的到）某个中断时，只要在这个中断编号对应的VICnINTENABLE的相应bit位写1即可（注意这个位写1其他位写0对其他位没有影响）；如果我们想禁止某个中断源时，只要向VICnINTENCLEAR中相应的位写1即可。 注意：这里的设计一共有2种：有些CPU是中断使能和禁止是一个寄存器位，写1就使能写0就进制（或者反过来写1就进制写0就使能），这样的中断使能设计就要非常小心，要使用我们之前说过的读改写三部曲来操作；另一种就是使能和禁止分开为2个寄存器，要使能就写使能寄存器，要禁止就写禁止寄存器。这样的好处是我们使能/禁止操作时不需要读改写，直接写即可。 VICnINTSELECT (1)设置各个中断的模式为irq还是fiq。一般都设置成irq (2)IRQ和FIQ究竟有何区别。210中支持2种中断，irq和fiq。irq是普通中断，fiq是快速中断。快速中断提供一种更快响应处理的中断通道，用于对实时性要求很高的中断源。fiq在CPU设计时预先提供了一些机制保证fiq可以被快速处理，从而保证实时性。fiq的限制就是只能有一个中断源被设置为fiq，其他都是irq。 (3)CPU如何保证fiq比irq快？有2个原因：第一，fiq模式有专用的r8～r12，因此在fiq的isr中可以直接使用r8-r12而不用保存，这就能节省时间；第二，异常向量表中fiq是最后一个异常向量入口。因此fiq的isr不需要跳转，可以直接写在原地，这样就比其他异常少跳转一次，省了些时间。 VICnIRQSTATUS和VICnFIQSTATUS (1)中断状态寄存器，是只读的。当发生了中断时，硬件会自动将该寄存器的对应位置为1，表示中断发生了。软件在处理中断第二阶段的第一阶段，就是靠查询这个寄存器来得到中断编号的。 VICnVECTPRIORITY0～VICnVECTPRIORITY31 (1)中断优先级设置寄存器，设置多个中断同时发生时先处理谁后处理谁的问题。一般来说高优先级的中断可以打断低优先级的中断，从而嵌套处理中断。当然了有些硬件/软件可以设置不支持中断嵌套。 VICnVECTADDR0～VICnVECTADDR31、VICnADDR (1)这三个寄存器和210中断处理第二阶段的第二阶段有关。 (2)VICnVECTADDR0到31这32个寄存器分别用来存放真正的各个中断对应的isr的函数地址。相当于每一个中断源都有一个VECTADDR寄存器，程序员在设置中断的时候，把这个中断的isr地址直接放入这个中断对应的VECTADDR寄存器即可。 (3)VICnADDR这个寄存器是只需要读的，它里面的内容是由硬件自动设置的。当发生了相应中断时，硬件会自动识别中断编号，并且会自动找到这个中断的VECTADDR寄存器，然后将其读出复制到VICnADDR中，供我们使用。这样的设计避免了软件查找中断源和isr，节省了时间，提高了210的中断响应速度。 编程过程 中断控制器初始化主要工作有：第一阶段绑定异常向量表到异常处理程序；禁止所有中断源；选择所有中断类型为IRQ；清理VICnADDR寄存器为0. 中断的使能与禁止思路是先根据中断号判断这个中断属于VIC几，然后在用中断源减去这个VIC的偏移量，得到这个中断号在本VIC中的偏移量，然后1 &lt;&lt; x位，写入相应的VIC的INTENABLE/INTENCLEAR寄存器即可。 绑定自己实现的isr到VICnVECTADDR (1)搞清楚2个寄存器的区别：VICnVECTADDR和VICnADDR (2)VICVECTADDR寄存器一共有4×32个，每个中断源都有一个VECTADDR寄存器，我们应该将自己为这个中断源写的isr地址丢到这个中断源对应的VECTADDR寄存器中即可。 真正的中断处理程序如何获取isr (1)当发生中断时，硬件会自动把相应中断源的isr地址从VICnVECTADDR寄存器中推入VICnADDR寄存器中，所以我们第二阶段的第二阶段isr_handler中，只需要到相应的VICnADDR中去拿出isr地址，调用执行即可。 总结：第4步绑定isr地址到VICnVECTADDR和第5步中断发生时第二阶段的第二阶段如何获取isr地址，这两步是相关的。这两个的结合技术，就是我们一直在说的210的硬件自动寻找isr的机制。 整个中断的流程梳理：整个中断的工作分为2部分，第一部分是我们为中断响应而做的预备工作： 初始化中断控制器 绑定写好的isr到中断控制器 相应中断的所有条件使能第二部分是当硬件产生中断后如何自动执行isr： 第一步，经过异常向量表跳转入IRQ/FIQ的入口 第二步，做中断现场保护（在start.S中），然后跳入isr_handler 第三步，在isr_handler中先去搞清楚是哪个VIC中断了，然后直接去这个VIC的ADDR寄存器中取isr来执行即可。 第四步，isr执行完，中断现场恢复，直接返回继续做常规任务。 外部中断 (1)SoC支持的中断类型中有一类叫外部中断。内部中断就是指的中断源来自于SoC内部（一般是内部外设），譬如串口、定时器等部件产生的中断；外部中断是SoC外部的设备，通过外部中断对应的GPIO引脚产生的中断。 (2)按键在SoC中就使用外部中断来实现。具体实现方法是：将按键电路接在外部中断的GPIO上，然后将GPIO配置为外部中断模式。此时人通过按按键改变按键电路的电压高低，这个电压高低会触发GPIO对应的外部中断，通过引脚传进去给CPU处理。 (3)外部中断相关的介绍和寄存器都在2.2.6章节（属于GPIO部分） 电平触发和边沿触发 (1)外部中断的触发模式主要有2种：电平触发和边沿触发。 (2)电平触发就是说GPIO上的电平只要满足条件，就会不停触发中断。电平触发分为高电平触发和低电平触发。电平触发的特点是，只要电平满足条件就会不停触发中断。 (3)边沿触发分为上升沿触发、下降沿触发和双边沿触发三种。边沿触发不关心电平常规状态，只关心电平变化的瞬间（边沿触发不关心电平本身是高还是低，只关心变化是从高到低还是从低到高的这个过程）。分析按键的工作：如果我们关注的是按键按下和弹起这两个事件本身，那么应该用边沿触发来处理按键；如果我们关心的是按键按下/弹起的那一段时间，那么应该用电平触发。 关键寄存器：CON、PEND、MASK (1)外部中断的主要配置寄存器有3个：EXT_CON、EXT_PEND、EXT_MASK (2)EXT_CON配置外部中断的触发方式。触发方式就是说外部电平怎么变化就能触发中断，也就是说这个外部中断产生的条件是什么 (3)EXT_PEND寄存器是中断挂起寄存器。这个寄存器中每一位对应一个外部中断，平时没有中断时值为0。当发生了中断后，硬件会自动将这个寄存器中该中断对应的位置1，我们去处理完这个中断后应该手工将该位置0。这个PEND寄存器的位就相当于是一个标志，如果发生了中断但是我们暂时忙来不及去处理时，这个位一直是1（这就是挂起），直到我有空了去处理了这个中断才会手工清除（写代码清除）这个挂起位表示这个中断被我处理了。 (4)EXT_MASK寄存器就是各个外部中断的使能/禁止开关。 分析X210开发板的按键对应的EINT编号：EINT2、EINT3、EINT16、EINT17、EINT18、EINT19 实验项目中断-01-按键轮询 步骤 新建key.c文件，设置相关的寄存器（GPH0CON、GPH0DAT、 GPH2CON、GPH2DAT） 修改Makefile文件，生成key.o文件 修改led.c，修改led灯闪烁的函数。 中断-02-移植printf 步骤 在前面串口实验基础上，新建key.c文件，设置相关的寄存器（GPH0CON、GPH0DAT、 GPH2CON、GPH2DAT），调用打印函数。（调用其他文件的函数时在前面加上extern 函数类型 函数名(函数参数类型)） 新增main.c文件，调用其他c文件的函数。 增加led.c，修改led灯闪烁的函数。 修改Makefile文件，生成key.o文件，led.o文件，main.o文件。 中断-03-按键中断 步骤 在前面串口实验基础上，新建key.c文件，设置相关的寄存器：GPH0CON、GPH2CON （外部中断的GPIO模式设置）EXT_INT_0_CON、EXT_INT_2_CON （中断触发模式设置）EXT_INT_0_MASK、EXT_INT_2_MASK （中断允许）EXT_INT_0_PEND、EXT_INT_2_PEND （中断挂起与清除中断挂起）//挂起的时候系统不能响应其他中断（寄存器标志位）//使能中断是能够被系统响应 创建按键中断后，对应的isr函数（key.c）：要执行的代码、清除中断挂起（EXT_INT_n_PEND）、清除读取isr函数的寄存器（VICnADDR） 新建int.c文件，绑定异常向量表：①给不同的中断写不同的函数（比如irq中断，分两部分，一部分写在start.S里面，先设置irq模式的栈，然后保存lr和r0-r12到栈里面（cpsr寄存器内容放进spsr寄存器），再调用int.c里面的中断函数，最后返回时把寄存器恢复；第二部分先判断isr函数在哪个VICnADDR寄存器里面，然后用函数指针来调用该函数；判断方法为读取VICnIRQSTATUS寄存器，第n个寄存器为1，代表第n个VICnADDR寄存器里面已经存放了isr函数；其他中断的功能暂时设置为打印一段话）②将irs的函数名绑定（放到）到异常向量表不同中断对应的地址里面，当发送中断的时候VICnADDR寄存器自动将地址里面的函数地址放进VICnADDR寄存器里面。 初始化中断控制器的基本寄存器（与第三步可以对调）禁止所有中断，防止中断产生，系统无法找到对应中断（VICnINTENCLEAR = 0xffffffff;）设置中断类型为IRQ（VICnINTSELEC = 0x0;）清除VICnADDR寄存器，防止里面原本就有isr函数（VICnADDR = 0;） 绑定isr函数到中断控制器硬件每个中断有对应编号，将对应的函数名（函数地址）放进对应的VICnVECTADDRn寄存器去，当系统检测到中断时，会将VICnVECTADDRn寄存器里面的函数地址推到相应的VICnADDR寄存器里面去。 使能中断（启用中断）根据中断编号，往VICnINTENABLE寄存器里面对应位写1，即使系统能够识别并处理该中断。 创建main.c文件调用以上函数 过程梳理 main函数调用uart_init()初始化函数，调用key_init_interrupt()初始化函数，system_init_exception()初始化函数，绑定isr函数到对应中断编号的寄存器里面，开启对应编号中断。 当中断发生时，VICnIRQSTATUS寄存器对应位自动置1（中断编号对应的位），VIC0VECTADDR寄存器对应位的函数自动推到相应的VICnADDR寄存器（中断编号对应的位），然后中断给CPU发送中断请求，系统判断是什么中断，然后根据异常向量表进入对应的中断模式，并进行中断处理，IRQ_handle保护现场、IRQ_handler利用VICnIRQSTATUS寄存器判断接下来要执行的代码在哪个VICnADDR寄存器里，然后运行该寄存器里面的代码。 实验05-定时器基本概念定时器(1)定时器与计数器。定时器是SoC中常见外设,计数器是用来计数的（每隔一个固定时间会计一个数）；因为计数器的计数时间周期是固定的，因此到了一定时间只要用计数值×计数时间周期，就能得到一个时间段（xx时间后），这个时间段就是我们定的时间（这就是定时器了）。 (2)定时器/计数器作为SoC的外设，主要用来实现定时执行代码的功能。定时器相对于SoC来说，就好象闹钟相对于人来说意义一样。 (3)定时器可以让SoC在执行主程序的同时，可以（通过定时器）具有计时功能，到了一定时间（计时结束）后，定时器会产生中断提醒CPU，CPU会去处理中断并执行定时器中断的ISR。从而去执行预先设定好的事件。 (4)定时器就好象是CPU的一个秘书一样，这个秘书专门管帮CPU来计时，并到时间后提醒CPU要做某件事情。所以CPU有了定时器之后，只需预先把自己xx时间之后必须要做的事情绑定到定时器中断ISR即可，到了时间之后定时器就会以中断的方式提醒CPU来处理这个事情。 定时器的原理 (1)定时器计时其实是通过计数来实现的。定时器内部有一个计数器，这个计数器根据一个时钟（这个时钟源来自于ARM的APB总线，然后经过时钟模块内部的分频器来分频得到）来工作。每隔一个时钟周期，计数器就计数一次，定时器的时间就是计数器计数值×时钟周期。 (2)定时器内部有1个寄存器TCNT，计时开始时我们会把一个总的计数值（譬如说300）放入TCNT寄存器中，然后每隔一个时钟周期（假设为1ms）TCNT中的值会自动减1（硬件自动完成，不需要CPU软件去干预），直到TCNT中减为0的时候，TCNT就会触发定时器中断。 (3)定时时间是由2个东西共同决定的：一个是TCNT中的计数值，一个是时钟周期。譬如上例中，定时周期就为300×1ms = 300ms。 定时器和看门狗、RTC、蜂鸣器的关系 (1)这几个东西都是和时间有关的部件。 (2)看门狗其实就是一个定时器，只不过定时时间到了之后不只是中断，还可以复位CPU (3)RTC是实时时钟，它和定时器的差别就好象闹钟（定时器）和钟表（RTC）的差别一样。 (4)蜂鸣器是一个发声设备，在ARM里面蜂鸣器是用定时器模块来驱动的。 S5PV210中的定时器在S5PV210内部，一共有4类定时器件。这4类定时器件的功能、特征是不同的。 PWM定时器(1)Pulse Width Modulation,简称脉宽调制。这种是最常用的，平时所说的定时器一般指的是这个。像简单单片机（譬如51单片机）中的定时器也是这类。 (2)为什么叫PWM定时器，因为一般SoC中产生PWM信号都是靠这个定时器模块的。 (3)S5PV210有5个PWM定时器。其中0、1、2、3各自对应一个外部GPIO，可以通过这些对应的GPIO产生PWM波形信号并输出；timer4没有对应的外部GPIO（因此不是为了生成PWM波形而是为了产生内部定时器中断而生的） (4)S5PV210的5个PWM定时器的时钟源为PCLK_PSYS，timer0和timer1共同使用一个预分频器、timer2、3、4共同使用一个预分频器；每个timer有一个专用的独立的分频器；预分频器和分频器构成了2级分频系统，将PCLK_PSYS两级分频后生成的时钟供给timer模块作为时钟周期。 系统定时器(1)系统（指的是操作系统）定时器，系统定时器也是用来产生固定时间间隔（TCNT×时钟周期）信号的，称为systick，这个systick用来给操作系统提供tick信号。 (2)产生systick作为操作系统的时间片（time slice）的。 (3)一般做操作系统移植的时候，这里不会由我们自己来做，一般原厂提供的基础移植部分就已经包含了，所以这里我也从来没有研究过。 看门狗定时器(1)看门狗定时器本质上也是一个定时器，和上面2个没有任何本质区别。 (2)看门狗定时器可以设置在时间到了的时候产生中断，也可以选择发出复位信号复位CPU。 (3)看门狗定时器在实践中应用很多，尤其是工业领域（环境复杂、干扰多）机器容易出问题，而且出问题后后果很严重，此时一般都会用看门狗来进行系统复位。 实时时钟RTC（real time clock）(1)区分时间段和时间点。时间段是相对的，两个时间点相减就会得到一个时间段；而时间点是绝对的，是绝无仅有的一个时间点。 (2)定时器关注的是时间段（而不是时间点），定时器计时从开启定时器的那一刻开始，到定的时间段结束为止产生中断；RTC中工作用的是时间点（xx年x月x日x时x分x秒星期x）。 (3)RTC和定时器的区别，就相当于是钟表和闹钟的区别。 pwm定时器 S5PV210的PWM定时器框图 (1)关键点：时钟源、预分频器、分频器、TCMPB&amp;TCNTB、dead zone 预分频器与分频器 (1)两级分频是串联（级联）的，所以两级分频的分频数是相乘的。 (2)两级分频的分频系数分别在TCFG0(TIMER CONFIGURATION) 和TCFG1两个寄存器中设置。 (3)预分频器有2个，prescaler0为timer0&amp;timer1共用；prescaler1为timer2、3、4共用；两个prescaler都是8个bit位，因此prescaler value范围为0～255；所以预分频器的分频值范围为1～256（注意实际分频值为prescaler value + 1）。 (4)分频器实质上是一个MUX开关，多选一开关决定了走哪个分频系数路线。可以选择的有1/1，1/2，1/4，1/8，1/16等。 (5)计算一下，两级分频下来，分频最小为1/1（也可能是1/2），最大分频为1/256×16（1/4096）。 (6)在PCLK_PSYS为66MHz的情况下（默认时钟设置就是66MHz的），此时两级分频后的时钟周期范围为0.03us到62.061us；再结合TCNTB的值的设置（范围为1～2的32次方），可知能定出来的时间最长为266548.27s（折合74小时多，远远够用了）。 TCNT&amp;TCMP、TCNTB&amp;TCMPB、TCNTO (1)TCNT和TCNTB是相对应的，TCNTB是有地址的寄存器，供程序员操作；TCNT在内部和TCNTB相对应，它没有寄存器地址，程序员不能编程访问这个寄存器。 (2)TCNT寄存器功能就是用来减1的，它是内部的不能读写；我们向TCNT中写要通过TCNTB往进写；读取TCNT寄存器中的值要通过读取相对应的TCNTO寄存器。 (3)工作流程就是：我们事先算好TCNT寄存器中开始减的那个数（譬如300），然后将之写入TCNTB寄存器中，在启动timer前，将TCNTB中的值刷到TCNT寄存器中（有一位寄存器专门用来操作刷数据过去的），刷过去后就可以启动定时器开始计时；在计时过程中如果想知道TCNT寄存器中的值减到多少了，可以读取相应的TCNTO寄存器来得知。 (4)定时功能只需要TCNT、TCNTB两个即可；TCNTO寄存器用来做一些捕获计时；TCMPB用来生成PWM波形。 自动重载和双缓冲（auto-reload and double buffering） (1)定时器工作的时候，一次定时算一个工作循环。定时器默认是单个循环工作的，也就是说定时一次，计时一次，到期中断一次就完了。下次如果还要再定时中断，需要另外设置。 (2)但是现实中用定时器来做的时候往往是循环的，最简单最笨的方法就是写代码反复重置定时器寄存器的值（在每次中断处理的isr中再次给TCNTB中赋值，再次刷到TCNT中再次启动定时器），早期的单片机定时器就是这样的；但是现在的高级SoC中的定时器已经默认内置了这种循环定时工作模式，就叫自动装载（auto-reload）机制。 (3)自动装载机制就是当定时器初始化好开始计时后再不用管了，他一个周期到了后会自己从TCNTB中再次装载值到TCNT中，再次启动定时器开始下个循环。 PWM (1)PWM(pulse wide modulation 脉宽调制) (2)PWM波形是一个周期性波形，周期为T，在每个周期内波形是完全相同的。每个周期内由一个高电平和一个低电平组成。 (3)PWM波形有2个重要参数：一个是周期T，另一个是占空比duty（占空比就是一个周期内高电平的时间除以周期时间的商）。 (4)对于一个PWM波形，知道了周期T和占空比duty，就可以算出这个波形的所有细节。譬如高电平时间为Tduty，低电平时间为T(1-duty)。 (5)PWM波形有很多用处，譬如通信上用PWM来进行脉宽调制对基波进行载波调制；在发光二极管LED照明领域可以用PWM波形来调制电流进行调光；用来驱动蜂鸣器等设备。 PWM波形的生成原理 (1)PWM波形其实就是用时间来控制电平高低，所以用定时器来实现PWM波形是天经地义的。 (2)早期的简单单片机里（譬如51单片机）是没有专用的PWM定时器的，那时候我们需要自己结合GPIO和定时器模块来手工生产PWM波形（流程是这样：先将GPIO引脚电平拉高、同时启动定时器定T x duty时间，时间到了在isr中将电平拉低，然后定时T x (1-duty)后再次启动定时器，然后时间到了后在isr中将电平拉高，然后再定时T x duty时间再次启动定时器····如此循环即可得到周期为T，占空比为duty的PWM波形）。 (3)后来因为定时器经常和PWM产生纠结一起，所以设计SoC的时候就直接把定时器和一个GPIO引脚内部绑定起来了，然后在定时器内部给我们设置了PWM产生的机制，可以更方便的利用定时器产生PWM波形。此时我们利用PWM定时器来产生PWM波形再不用中断了。绑定了之后坏处就是GPIO引脚是固定的、死板的、不能随便换的；好处是不用进入中断isr中，直接可以生成PWM。 (4)在S5PV210中，PWM波形产生有2个寄存器很关键，一个是TCNTB、一个是TCMPB。其中，TCNTB决定了PWM波形的周期，TCMPB决定了PWM波形的占空比。 (5)最终生成的PWM波形的周期是：TCNTB×时钟周期（PCLK_PSYS经过两极分频后得到的时钟周期）。注意这个周期是PWM中高电平+低电平的总时间，不是其中之一。 (6)最终生成的PWM波形的占空比是：TCMPB/TCNTB 输出电平翻转器 (1)PWM定时器可以规定：当TCNT&gt;TCMPB时为高电平，当TCNT&lt;TCMPB时为低电平。也可以规定：当TCNT&gt;TCMPB时为低电平，当TCNT&lt;TCMPB时为高电平。在这两种规定下，计算时TCMP寄存器的值会变化。 (2)基于上面讲的，当duty从30%变到70%时，我们TCMPB寄存器中的值就要改（譬如TCNTB中是300时，TCMPB就要从210变化到90）。这样的改变可以满足需要，但是计算有点麻烦。于是乎210的PWM定时器帮我们提供了一个友好的工具叫做电平翻转器。 (3)电平翻转器在电路上的实质就是一个电平取反的部件，在编程上反映为一个寄存器位。写0就关闭输出电平反转，写1就开启输出电平反转。开启后和开启前输出电平刚好高低反转。（输出电平一反转30%的duty就变成70%了） (4)实战中到底是TCNT和TCMPB谁大谁小时高电平还是低电平，一般不用理论分析，只要写个代码然后用示波器实际看一下出来的波形就知道了；如果反了就直接开启电平翻转器即可。 死区生成器 (1)PWM有一个应用就是用在功率电路中用来对交流电压进行整流。整流时2路整流分别在正电平和负电平时导通工作，不能同时导通（同时导通会直接短路，瞬间的同时导通都会导致电路烧毁）。大功率的开关电源、逆变器等设备广泛使用了整流技术。特别是逆变器，用SoC的GPIO输出的PWM波形来分别驱动2路整流的IGBT。 (2)PWM波形用来做整理时要求不能同时高或低，因为会短路。但是实际电路是不理想的，不可能同时上升/下降沿，所以比较安全的做法是留死区。 (3)死区这东西离不了也多不了。死区少了容易短路，死区多了控制精度低了不利于产品性能的提升。 (4)S5PV210给大家提供了自带的死区生成器，只要开启死区生成器，生产出来的PWM波形就自带了死区控制功能，用户不用再自己去操心死区问题。 (5)大部分人工作是用不到这个的，直接关掉死区生成器即可。 蜂鸣器的工作原理 (1)蜂鸣器里面有2个金属片，离的很紧但没挨着；没电的时候两个片在弹簧本身张力作用下分开彼此平行；有电的时候两边分别充电，在异性电荷的吸力作用下两个片挨着； (2)我们只要以快速的频率给蜂鸣器的正负极：供电、断电。进行这样的循环，蜂鸣器的两个弹簧片就会挨着分开挨着分开···形成敲击，发出声音。 (3)因为人的耳朵能听见的声音频率有限制（20Hz-20000Hz），我们做实验时一般给个2KHz的频率，大部分人都能听到（听不到的就就近医院处理）。 (4)频率高低会影响声音的音频，一般是音频越低声音听起来越低沉、音频越高听起来越尖锐。 (5)根据以上的分析，可以看出，只要用PWM波形的电压信号来驱动蜂鸣器，把PWM波形的周期T设置为要发出的声音信号的1/频率即可；PWM的占空比只要确保能驱动蜂鸣器即可（驱动能力问题，一般引脚驱动能力都不够，所以蜂鸣器会额外用三极管来放大流来供电）。 原理图和硬件信息 (1)查阅原理图可知，开发板底板上的蜂鸣器通过GPD0_2（XpwmTOUT2）引脚连接在SoC上。 (2)GPD0_2引脚通过限流电阻接在三极管基极上，引脚有电蜂鸣器就会有电（三极管导通）；引脚没电蜂鸣器就会没电（三极管关闭）。这些都是硬件问题，软件工程师不用管，软件工程师只要写程序控制GPD0_2引脚的电平产生PWM波形即可。 (3)GPD0CON(0xE02000A0)，要把bit8～bit11设置为0b0010（功能选择为TOUT_2，就是把这个引脚设置为PWM输出功能） (4)从GPD0_2引脚可以反推出使用的是timer2这个PWM定时器。 PWM定时器的主要寄存器详解 (1)相关的寄存器有TCFG0、TCFG1、CON、TCNTB2、TCMPB2、TCNTO2 蜂鸣器和PWM定时器编程实践基于uart_stdio项目源码来添加PWM定时器驱动蜂鸣器实验。注意：PWM定时器来产生PWM波形时是不需要中断干预的。 看门狗定时器 看门狗 (1)看门狗定时器和普通的定时器并无本质区别。定时器可以设定一个时间，在这个时间完成之前定时器不断计时，时间到的时候定时器会复位CPU（重启系统）。 (2)系统正常工作的时候当然不希望被重启，但是系统受到干扰、极端环境等可能会产生异常工作或者不工作，这种状态可能会造成不良影响（至少是不工作），此时解决方案就是重启系统。 (3)普通设备重启不是问题，但是有些设备人工重启存在困难。这时候我们希望系统能够自己检验自己是否已经跑飞，并且在意识到自己跑飞的时候，可以很快的（几个ms或者更短）自我重启。这个功能就要靠看门狗定时器来实现。 (4)典型应用的情景是：我们在应用程序中打开看门狗设备，初始化好给它一个时间，然后应用程序使用一个线程来喂狗，这个线程的执行时间安全短于看门狗的复位时间。当系统（或者应用程序）异常后，喂狗线程自然就不工作了，然后到时候看门狗就会复位。 (5)补充：实战中有时候为了绝对的可靠，我们并不会用SoC中自带的看门狗，而是使用专门的外置的看门狗芯片来实现看门狗。 S5PV210看门狗定时器的结构框图 (1)PCLK_PSYS经过两级分频后生成WDT（watchdog timer）的时钟周期，然后把要定的时间写到WTDAT寄存器中，刷到WTCNT寄存器中去减1，减到0时（定时时间到）产生复位信号或中断信号。 (2)典型应用中是配置为产生复位信号，我们应该在WTCNT寄存器减到0之前给WTDAT寄存器中重新写值以喂狗。 看门狗定时器的主要寄存器WTCON WTDAT WTCNT WTCLRINT 实时时钟rtc 何为实时时钟 (1)real time clock，真实时间，就是所谓的xx年x月x日x时x分x秒星期x (2)RTC是SoC中一个内部外设，RTC有自己独立的晶振提供RTC时钟源（32.768KHz），内部有一些寄存器用来记录时间（年月日时分秒星期）。一般情况下为了在系统关机时时间仍然在走，还会给RTC提供一个电池供电。 S5PV210实时时钟的结构框图 (1)时间寄存器7个 (2)闹钟发生器 闹钟发生器 (1)可以定闹钟时间，到时间会产生RTC alarm interrupt，通知系统闹钟定时到了。 (2)闹钟定时是定的时间点，而timer定时是定的时间段。 S5PV210实时时钟的主要寄存器 (1)INTP 中断挂起寄存器 (2)RTCCON RTC控制寄存器 (3)RTCALM ALMxxx 闹钟功能有关的寄存器 (4)BCDxxx 时间寄存器 BCD码 (1)RTC中所有的时间（年月日时分秒星期，包括闹钟）都是用BCD码编码的。 (2)BCD码本质上是对数字的一种编码。用来解决这种问题：由56得到0x56（或者反过来）。也就是说我们希望十进制的56可以被编码成56（这里的56不是十进制56，而是两个数字5和6）。 (3)BCD码的作用在于可以将十进制数拆成组成这个十进制数的各个数字的编码，变成编码后就没有位数的限制了。譬如我有一个很大的数123456789123456789，如果这个数纯粹当数字肯定超出了int的范围，计算机无法直接处理。要想让计算机处理这个数，计算机首先得能表达这个数，表达的方式就是先把这个数转成对应的BCD码（123456789123456789） (4)BCD码在计算机中可以用十六进制的形式来表示。也就是说十进制的56转成BCD码后是56，在计算机中用0x56来表达（暂时存储与运算）。 (5)需要写2个函数，一个是bcd转十进制，一个是十进制转bcd。当我们要设置时间时（譬如要设置为23分），我们需要将这个23转成0x23然后再赋值给相应的寄存器BCDMIN；当我们从寄存器BCDMIN中读取一个时间时（譬如读取到的是0x59），需要将之当作BCD码转成十进制再去显示（0x59当作BCD码就是59，转成十进制就是59，所以显示就是59分）。 设置时间与读取显示时间 (1)为了安全，默认情况下RTC读写是禁止的，此时读写RTC的时间是不允许的；当我们要更改RTC时间时，应该先打开RTC的读写开关，然后再进行读写操作，操作完了后立即关闭读写开关。 (2)读写RTC寄存器时，一定要注意BCD码和十进制之间的转换。 (3)年的问题。S5PV210中做了个设定，BCDYEAR寄存器存的并不是完整的年数（譬如今年2015年），而是基于2000年的偏移量来存储的，譬如今年2015年实际存的就是15（2015-2000）.还有些RTC芯片是以1970年（貌似）为基点来记录的。 实验项目定时器-01-蜂鸣器步骤： 在前面串口实验基础上，新建pwm.c文件，设置相关的寄存器：GPD0CON（设置GPD0_2引脚，将其配置为XpwmTOUT_2）TCFG0（设置预分频器为65）TCFG1（设置分频器为1）CON（打开auto-reload、刷新TCNTB到TCNT中）TCNTB2（时钟频率/蜂鸣器频率，蜂鸣器频率越高音调越高，自动刷进TCNT2）TCMPB2（TCMPB2/TCNTB2=占空比，占空比越大声音越大） 修改uart.c、start.S文件，使其符合新实验 创建main.c文件，调用初始化uart、pwm的函数 修改Makefile文件，增加pwm.o、main.o文件 定时器-02-看门狗中断步骤： 在前面中断实验基础上，新建wdt.c文件，设置相关的寄存器：WTCON（设置预分频器为65、分频器为128，使能中断）WTDAT（定时/时钟周期）WTCNT（一开始里面的值为默认值，经过一个周期才自动将WTDAT的值写进去，可以人为先写进去，值为WTDAT）WTCON（打开看门狗） 编写中断处理函数，打印一段文字，然后清理中断 修改start.S文件，使其符合新实验 修改main.c文件，调用初始化uart、wdt的函数 修改Makefile文件，增加wdt.o文件 定时器-03-看门狗复位步骤： 在前面看门狗中断实验基础上，修改wdt.c文件，设置相关的寄存器：WTCON（使能中断改为使能复位） 删除int.c文件，使其符合新实验 修改main.c文件，删除中断函数 烧录210.bin到sd卡，因为看门狗复位可能导致sram的代码丢失 定时器-04-rtc定时器步骤： 在前面中断实验基础上，新建rtc.c文件，设置相关的寄存器：sett_ime函数、get_time函数（注意要使用bcd码转换）RTCCON（打开rtc读写开关，写进数据，关闭读写开关）BCDYEAR、BCDMON、BCDDATE、BCDHOUR、BCDMIN、BCDSEC、BCDDAY（rtc时间寄存器）rtc_set_alarm函数ALMSEC（一分钟的第几秒，产生中断）RTCALM（使能总中断、秒中断） 编写bcd码转换函数，将十进制和十六进制互相转换 编写isr_rtc_alarm函数，打印一段话，清中断（INTP寄存器） 修改main.c文件，调用初始化中断、rtc的函数 实验06-sd卡启动基本概念sd卡的编程接口 SD卡的物理接口 (1)SD卡由9个针脚与外界进行物理连接，这9个脚中有2个地，1个电源，6个信号线。 SD协议与SPI协议 (1)SD卡与SRAM/DDR/SROM之类的东西的不同：SRAM/DDR/SROM之类的存储芯片是总线式的，只要连接上初始化好之后就可以由SoC直接以地址方式来访问；但是SD卡不能直接通过接口给地址来访问，它的访问需要按照一定的接口协议（时序）来访问。 (2)SD卡虽然只有一种物理接口，但是却支持两种读写协议：SD协议和SPI协议。 * SPI协议特点（低速、接口操作时序简单、适合单片机） (1)SPI协议是单片机中广泛使用的一种通信协议，并不是为SD卡专门发明的。 (2)SPI协议相对SD协议来说速度比较低。 (3)SD卡支持SPI协议，就是为了单片机方便使用。 * SD协议特点（高速、接口时序复杂，适合有SDIO接口的SoC） (1)SD协议是专门用来和SD卡通信的。 (2)SD协议要求SoC中有SD控制器，运行在高速率下，要求SoC的主频不能太低。 S5PV210的SD/MMC控制器 (1)数据手册Section8.7，为SD/MMC控制器介绍。 (2)SD卡内部除了存储单元Flash外，还有SD卡管理模块，我们SoC和SD卡通信时，通过9针引脚以SD协议/SPI协议向SD卡管理模块发送命令、时钟、数据等信息，然后从SD卡返回信息给SoC来交互。工作时每一个任务（譬如初始化SD卡、譬如读一个块、譬如写、譬如擦除····）都需要一定的时序来完成（所谓时序就是先向SD卡发送xx命令，SD卡回xx消息，然后再向SD卡发送xx命令····） s5pv210的sd卡启动详解 SoC为何要支持SD卡启动 (1)一个普遍性的原则就是：SoC支持的启动方式越多，将来使用时就越方便，用户的可选择性就越大，SoC的适用面就越广。 (2)SD卡有一些好处：比如可以在不借用专用烧录工具（类似Jlink）的情况下对SD卡进行刷机，然后刷机后的SD卡插入卡槽，SoC既可启动；譬如可以用SD卡启动进行量产刷机（量产卡）。像我们X210开发板，板子贴片好的时候，内部iNand是空的，此时直接启动无启动；板子出厂前官方刷机时是把事先做好的量产卡插入SD卡卡槽，然后打到iNand方式启动；因为此时iNand是空的所以第一启动失败，会转而第二启动，就从外部SD2通道的SD卡启动了。启动后会执行刷机操作对iNand进行刷机，刷机完成后自动重启（这回重启时iNand中已经有image了，所以可以启动了）。刷机完成后SD量产卡拔掉，烧机48小时，无死机即可装箱待发货。 SD卡启动的难点（SRAM、DDR、SDCard） (1)SRAM、DDR都是总线式访问的，SRAM不需初始化既可直接使用而DDR需要初始化后才能使用，但是总之CPU可以直接和SRAM/DRAM打交道；而SD卡需要时序访问，CPU不能直接和SD卡打交道；NorFlash读取时可以总线式访问，所以Norflash启动非常简单，可以直接启动，但是SD/NandFlash不行。 (2)以前只有Norflash可以作为启动介质，台式机笔记本的BIOS就是Norflash做的。后来三星在2440中使用了SteppingStone的技术，让Nandflash也可以作为启动介质。SteppingStone（翻译为启动基石）技术就是在SoC内部内置4KB的SRAM，然后开机时SoC根据OMpin判断用户设置的启动方式，如果是NandFlash启动，则SoC的启动部分的硬件直接从外部NandFlash中读取开头的4KB到内部SRAM作为启动内容。 (3)启动基石技术进一步发展，在6410芯片中得到完善，在210芯片时已经完全成熟。210中有96KB的SRAM，并且有一段iROM代码作为BL0，BL0再去启动BL1（210中的BL0做的事情在2440中也有，只不过那时候是硬件自动完成的，而且体系没有210中这么详细）。 S5PV210的启动过程 (1)210启动首先执行内部的iROM（也就是BL0），BL0会判断OMpin来决定从哪个设备启动，如果启动设备是SD卡，则BL0会从SD卡读取前16KB（不一定是16，反正16是工作的）到SRAM中去启动执行（这部分就是BL1，这就是steppingstone技术） (2)BL1执行之后剩下的就是软件的事情了，SoC就不用再去操心了（也就是说SD卡里面只有一个小于等于16KB的bin文件）。 SD卡启动流程（bin文件小于16KB时和大于16KB时） (1)启动的第一种情况是整个镜像大小小于16KB。这时候相当于我的整个镜像作为BL1被steppingstone直接硬件加载执行了而已。 (2)启动的第二种情况就是整个镜像大小大于16KB。（只要大于16KB，哪怕是17KB，或者是700MB都是一样的）这时候就要把整个镜像分为2部分：第一部分16KB大小，第二部分是剩下的大小。然后第一部分作为BL1启动，负责去初始化DRAM并且将第二部分加载到DRAM中去执行（uboot就是这样做的）。 隐含要点 (1)问题：iROM究竟是怎样读取SD卡/NandFlash的？ (2)三星在iROM中事先内置了一些代码去初始化外部SD卡/NandFlash，并且内置了读取各种SD卡/NandFlash的代码在iROM中。BL0（SteppingStone技术）执行时就是通过调用这些iROM application note：block device copy function来读取外部SD卡/NandFlash中的BL1的。 扇区和块的概念 (1)早期的块设备就是软盘硬盘这类磁存储设备，这种设备的存储单元不是以字节为单位，而是以扇区为单位。磁存储设备读写的最小单元就是扇区，不能只读取或写部分扇区。这个限制是磁存储设备本身物理方面的原因造成的，也成为了我们编程时必须遵守的规律。 (2)一个扇区有好多个字节（一般是512个字节）。早期的磁盘扇区是512字节，实际上后来的磁盘扇区可以做的比较大（譬如1024字节，譬如2048字节，譬如4096字节），但是因为原来最早是512字节，很多的软件（包括操作系统和文件系统）已经默认了512这个数字，因此后来的硬件虽然物理上可能支持更大的扇区，但是实际上一般还是兼容512字节扇区这种操作方法。 (3)一个扇区可以看成是一个块block（块的概念就是：不是一个字节，是多个字节组成一个共同的操作单元块），所以就把这一类的设备称为块设备。常见的块设备有：磁存储设备硬盘、软盘、DVD和Flash设备（U盘、SSD、SD卡、NandFlash、Norflash、eMMC、iNand） (4)linux里有个mtd驱动，就是用来管理这类块设备的。 (5)磁盘和Flash以块为单位来读写，就决定了我们启动时device copy function只能以整块为单位来读取SD卡。 用函数指针方式调用device copy function (1)第一种方法：宏定义方式来调用。好处是简单方便，坏处是编译器不能帮我们做参数的静态类型检查。 (2)第二种方法：用函数指针方式来调用（注意要解引用，因为函数地址里面也是一个地址）。 分散加载 (1)将代码分为2部分：第一部分BL1小于等于16KB，第二部分为任意大小，iROM代码执行完成后从SD卡启动会自动读取BL1到SRAM中执行；BL1执行时负责初始化DDR，然后手动将BL2从SD卡copy到DDR中正确位置，然后BL1远跳转到BL2中执行BL2. (2)代码分为2部分，这种技术叫分散加载。这种分散加载的方法可以解决问题，但是比较麻烦。分散加载的缺陷：第一，代码完全分2部分，完全独立，代码编写和组织上麻烦；第二，无法让工程项目兼容SD卡启动和Nand启动、NorFlash启动等各种启动方式。 (3)细节1：程序整个分为2个文件夹BL1和BL2，各自管理各自的项目。 (4)细节2：BL1中要完成：关看门狗、设置栈、开iCache、初始化DDR、从SD卡复制BL2到DDR中特定位置，跳转执行BL2。 (5)细节3：BL1在SD卡中必须从Block1开始（Block0不能用，这个是三星官方规定的），长度为16KB内，我们就定为16KB（也就是32个block）；BL2理论上可以从33扇区开始，但是实际上为了安全都会留一些空扇区作为隔离，譬如可以从45扇区开始，长度由自己定（实际根据自己的BL2大小来分配长度，我们实验时BL2非常小，因此我们定义BL2长度为16KB，也就是32扇区）。 (6)细节4：DDR初始化好之后，整个DDR都可以使用了，这时在其中选择一段长度足够BL2的DDR空间即可。我们选0x23E00000（因为我们BL1中只初始化了DDR1，地址空间范围是0x20000000～0x2FFFFFFF）。 uboot： (1)第二种思路：程序代码仍然包括BL1和BL2两部分，但是组织形式上不分为2部分而是作为一个整体来组织。它的实现方式是：iROM启动然后从SD卡的扇区1开始读取16KB的BL1然后去执行BL1，BL1负责初始化DDR，然后从SD卡中读取整个程序（BL1+BL2）到DDR中，然后从DDR中执行（利用ldr pc, =main这种方式以远跳转从SRAM中运行的BL1跳转到DDR中运行的BL2）。 uboot的SD卡启动细节 (1)uboot编译好之后有200多KB，超出了16KB。uboot的组织方式就是前面16KB为BL1，剩下的部分为BL2. (2)uboot在烧录到SD卡的时候，先截取uboot.bin的前16KB（实际脚本截取的是8KB）烧录到SD卡的block1～bolck32；然后将整个uboot烧录到SD卡的某个扇区中（譬如49扇区） (3)实际uboot从SD卡启动时是这样的：iROM先执行，根据OMpin判断出启动设备是SD卡，然后从S卡的block1开始读取16KB（8KB）到SRAM中执行BL1，BL1执行时负责初始化DDR，并且从SD卡的49扇区开始复制整个uboot到DDR中指定位置（0x23E00000）去备用；然后BL1继续执行直到ldr pc, =main时BL1跳转到DDR上的BL2中接着执行uboot的第二阶段。 总结：uboot中的这种启动方式比上节讲的分散加载的好处在于：能够兼容各种启动方式。 x210开发板的软开关按键问题 X210开发板的软启动电路详解 (1)210供电需要的电压比较稳定，而外部适配器的输出电压不一定那么稳定，因此板载了一个文稳压器件MP1482.这个稳压芯片的作用就是外部适配器电压在一定范围内变化时稳压芯片的输出电压都是5V。 (2)MP1482芯片有一个EN（Enable）引脚，这个引脚可以让稳压芯片输出或关闭输出。EN为高电平时有输出电压，EN引脚为低电平时稳压芯片无输出。 (3)两个因素可以影响EN引脚的电平：第一个是POWER按键（SW1），POWER按键按下时EN为高电平，POWER按键弹起时EN为低电平；第二个是POWER_LOCK（EINT0）引脚，这个引脚为POWER_LOCK模式下高电平，则EN为高；若这个引脚为EINT0模式或者为POWER_LOCK模式但输出为低电平，则EN为低。 (4)图中还有EINT1引脚，这个引脚的作用是用来做中断，提供给CPU用来唤醒的。 软启动 (1)一般的电路设计都是用拨码开关来做电源开关的（打到一侧则接通，打到另一侧则关闭）。这种方式的优点是设计简单，缺点是电路太简单，整个主板要么有电要么没电无法做休眠模式、低功耗模式等。 (2)软启动电路是比较接近于实际产品的，其他开发板的硬开关其实是简化版的，和实际产品还有差异。 开发板供电置锁原理和分析 (1)软开关在设计时有一个置锁电路，用EINT0（也就是GPH0_2）引脚来控制的。 (2)EINT0这个引脚是有复用设计（两个完全不相干的功能挤在同一个引脚上，同时我们只能让这个引脚用于其中一种功能，这就叫复用）的，一个是GPIO（也就是GPH0_2引脚）、一个是PS_HOLD_CONTROL。（注意：EINT0功能算是GPIO下的一个子功能） (3)PS_HOLD在Section2.4 Power Management章节下的4.10.5.8节下。 (4)PS_HOLD_CONTROL寄存器（0xE010E81C），共有3个位有用。 bit0, 0表示这个引脚为GPIO功能，1表示这个引脚为PS_HOLD功能 bit9，0表示这个引脚方向为输入，1表示这个引脚方向为输出 bit8，0表示这个引脚输出为低电平，1表示输出为高电平。分析：我们要使用软启动置锁，则需要将bit0、8、9都置为1即可。 写代码+实验验证 (1)要想让开发板和普通的开发板一样，一按下按键程序运行后即可松手不会断电，则只要在程序的开头部分添加代码去置锁开关板即可。 (2)置锁代码的方法是：给PS_HOLD_CONTROL寄存器的bit0、8、9均写入1即可。 (3)注意：此时开发板已经置锁，POWER按键已经失效，关机时需要按下复位按键。 实验项目sd卡启动-01-分散加载 步骤： 创建两个文件夹：BL1、BL2 创建write2sd文件，目的是将BL1.bin和BL2.bin写进sd卡的扇区1和扇区45，内容为： 123#!/bin/shsudo dd iflag=dsync oflag=dsync if=./BL1/BL1_SD.bin of=/dev/sdb seek=1sudo dd iflag=dsync oflag=dsync if=./BL2/BL2_SD.bin of=/dev/sdb seek=45 创建Makefile，目的是进入BL1、BL2文件夹调用里面的Makefile，内容是： 1234567all: make -C ./BL1 make -C ./BL2clean: make clean -C ./BL1 make clean -C ./BL2 在BL1文件夹下，修改start.S文件（基于led灯实验），使其初始化ddr后跳转到重定位的C语言代码 创建sd_relocate.c文件，由start.S跳转，完成两个任务，第一个是读取sd卡的BL2到ddr（因为不能直接用地址访问sd卡，所以只能调用函数来执行这个功能），第二个是跳转到ddr的BL2位置并执行BL2（方法：调用不传参的函数，地址为BL2） 创建Makefile文件，目的为编译连接 修改link.lds文件，使其连接地址为iram的地址（0xd0020010） 在BL2文件夹下，创建start.S文件，目的是跳转到C语言代码里面 添加led.c文件（led灯实验） 修改Makefile文件，目的为编译连接，并去掉添加校验头的部分（因为校验头已经在BL1里面加过） 创建link.lds文件，使其连接地址为iram的地址（0x23E00000） 进入linux虚拟机，使用make指令编译连接，然后插入sd卡，执行wirte2sd文件，将镜像文件写进sd卡 实验07-nandnand基本概念nandflash接口 Nand的型号与命名 (1)Nand的型号命名都有含义，K9F2G08：K9F表示是三星公司的NandFlash系列。2G表示Nand的大小是2Gbit（256MB）。08表示Nand是8位的（8位就是数据线有8根） (2)Nand命名中可以看出：厂家、系列型号、容量大小、数据位数。 Nand的数据位 (1)Nand有8位数据位、16位数据位的。做电路时/写软件时应该根据自己实际采购的Nnad的位数来设计电路/写软件。 (2)说明Nand是并行接口的（8/16位） (3)Nand的数据线上传递的不一定全部是有效数据，也可能有命令、地址等。 Nand的功能框图 (1)Nand的结构可以看成是一个矩阵式存储器，其中被分成一个一个的小块，每一小块可以存储一个bit位，然后彼此以一定单位组合成整个Nand。 (2)Nand中可以被单次访问的最小单元（就是说对Nand进行一次读写至少要读写这么多，或者是这么多的整数倍）叫做Page（页），在K9F2G08芯片中，Page的大小是2KB+64B。也就是说我们要读写K9F2G08，每次至少要读写2KB或者n X 2KB，即使我们只是想要其中的一个字节。这就是我们说的典型的块设备（现在有些块设备为了方便，提供了一种random read模式，可以只读取1个字节）。 (3)页往上还有个Block（块）的概念，1个块等于若干个页（譬如在K9F2G08中1个块等于64页）。 (4)块往上就是整个Nand芯片了，叫做Device。一个Device是若干个Block，譬如K9F2F08一个Device有2028个block。所以整个Device大小为：2048×64×2K = 256MB (5)块设备分page、block有什么意义？首先要明白，块设备不能完全按字节访问而必须块访问是物理上的限制，而不是人为设置的障碍。其次，Page和Block各有各的意义，譬如Nand中：Page是读写Nand的最小单位；Block是擦除Nand的最小单位。（这些规则都是Nand的物理原理和限制要求的）。 (6)Nand芯片中主要包含2部分：Nand存储颗粒+Nand接口电路。存储颗粒就是纯粹的Nand原理的存储单元，类似于仓库；Nand接口电路是用来管理存储颗粒，并且给外界提供一个统一的Nand接口规格的访问接口的。 (7)Nand中有多个存储单元，每个单元都有自己的地址（地址是精确到字节的）。所以Nand是地址编排精确到字节，但是实际读写却只能精确到页（所以Nand的很多操作都要求给的地址是页对齐的，譬如2K、4K、512K等这样的地址，不能给3000B这样的地址）。Nand读写时地址传递是通过IO线发送的，因为地址有30位而IO只有8位，所以需要多个cycle才能发送完毕。一般的Nand都是4cycle或者5cycle发送地址（从这里把Nand分为了4cycle Nand和5cycle Nand）。 总结：Nand芯片内部有存储空间，并且有电路来管理这些存储空间，向外部提供统一的Nand接口的访问规则，然后外部的SoC可以使用Nand接口时序来读写这个Nand存储芯片。Nand接口是一种公用接口，是一种标准，理论上来说外部SoC可以直接模拟Nand接口来读写Nand芯片，但是实际上因为nand接口对时序要求非常严格，而且时序很复杂，所以一般的SoC都是通过专用的硬件的Nand控制器（这些控制器一般是作为SoC的内部外设来存在的）来操控Nand芯片的。 NandFlash的结构 Nand的单元组织：block与page（大页Nand与小页Nand） (1)Nand的页和以前讲过的块设备（尤其是硬盘）的扇区是类似的。扇区最早在磁盘中是512字节，后来也有些高级硬盘扇区不是512字节而是1024字节/2048字节/4096字节等。Nand也是一样，不同的Nand的页的大小是不同的，也有512字节/1024字节/2048字节/4096字节等。 (2)一个block等于多少page也是不定的，不同的Nand也不同。一个Nand芯片有多少block也是不定的，不同的Nand芯片也不同。 带内数据和带外数据（ECC与坏块标记） (1)Nand的每个页由2部分组成，这2部分各自都有一定的存储空间。譬如K9F2G08中为2K+64字节。其中的2K字节属于带内数据，是我们真正的存储空间，将来存储在Nand中的有效数据就是存在这2K范围内的（我们平时计算nand的容量时也是只考虑这2KB）；64字节的带外数据不能用来存储有效数据，是作为别的附加用途的（譬如用来存储ECC数据、用来存储坏块标志等） (2)什么是ECC：（error correction code，错误校验码）。因为Nand存储本身出错（位反转）概率高（Nand较Nor最大的缺点就是稳定性），所以当我们将有效信息存储到Nand中时都会同时按照一定算法计算一个ECC信息（譬如CRC16等校验算法），将ECC信息同时存储到Nand这个页的带外数据区。然后等将来读取数据时，对数据用同样的算法再计算一次ECC，并且和从带外数据区读出的ECC进行校验。如果校验通过则证明Nand的有效数据可信，如果校验不通过则证明这个数据已经被损坏（只能丢弃或者尝试修复）。 (3)坏块标志：Nand芯片用一段时间后，可能某些块会坏掉（这些块无法擦除了，或者无法读写了），nand的坏块非常类似于硬盘的坏道。坏块是不可避免的，而且随着Nand的使用坏块会越来越多。当坏块还不算太多时这个Nand都是可以用的，除非坏块太多了不划算使用了才会换新的。所以我们为了管理Nand发明了一种坏块标志机制。Nand的每个页的64字节的带外数据中，我们（一般是文件系统）定义一个固定位置（譬如定位第24字节）来标记这个块是好的还是坏的。文件系统在发现这个块已经坏了没法用了时会将这个块标记为坏块，以后访问nand时直接跳过这个块即可。 Nand的地址时序 (1)nand的地址有多位，分4/5周期通过IO引脚发送给Nand芯片来对Nand进行寻址。寻址的最小单位是字节，但是读写的最小单位是页。 (2)nand的地址在写代码时要按照Nand要求的时序和顺序去依次写入。 Nand的命令码 (1)外部SoC要想通过Nand控制器来访问Nand（实质就是通过Nand接口），就必须按照Nand接口给nand发送命令、地址、数据等信息来读写Nand。 (2)Nand芯片内部的管理电路本身可以接收外部发送的命令，然后根据这些命令来读写Nand内容与外部SoC交互。所以我们对nand进行的所有操作（擦除、读、写···）都要有命令、地址、数据的参与才能完成，而且必须按照Nand芯片规定的流程来做。 NandFlash的常见操作及流程分析 坏块检查(1)Flash使用之前要先统一擦除（擦除的单位是块）。Flash类设备一般将数据都擦除为1，所以擦干净之后读出来的值是0xff。 (2)检查坏块的思路就是：先块擦除，然后将整块读出来，依次检测各自节是否为0xff，如果是则表明不是坏块，如果不是则表明是坏块。 页写（program）操作(1)写之前确保这个页是被擦除干净的。如果不是擦除过的页，写进去的值有可能是错的。 (2)写操作（write）在flash的操作中就叫编程（program） (3)SoC写Flash时通过命令线、IO线依次发送写命令、写页地址、写数据等进入NandFlash。 (4)写的过程：SOC通过Nand控制器和Nand芯片完成顺序对接，然后按照时序要求将一页数据发给Nand芯片内部的接口电路。接口电路先接收收据到自己的缓冲区，然后再集中写入Nand芯片的存储区域中。Nand接口电路将一页数据从缓冲区中写入Nand存储系统中需要一定的时间，这段时间Nand芯片不能再响应SOC发过来的其他命令，所以SoC要等待Nand接口电路忙完。等待方法是SoC不断读取状态寄存器（这个状态寄存器有2种情况：一种是SoC的Nand控制器自带的，另一种是SoC通过发命令得到命令响应得到的），然后通过检查这个状态寄存器的状态位就能知道Nand接口电路刚才写的那一页数据写完了没、写好了没。直到SoC收到正确的状态寄存器响应才能认为刚才要写的那一页数据已经ok。（如果SoC收到的状态一直不对，可以考虑重写或者认为这一页所在的块已经是坏块，或者整个Nand芯片已经死机了）。 (5)正常情况下到了第四步就已经完了。但是因为Nand的读写有不靠谱情况，因此我们为了安全会去做ECC校验。ECC校验有硬件式校验和软件式校验2种。软件式校验可以采用的策略有很多，其中之一（Nand芯片手册上推荐的方式）：将刚才写入的1页数据读出来，和写入的内容进行逐一对比。如果读出的和写入的完全一样，说明刚才的写入过程正确完成了；如果读出来的和写入的不完全一样那就说明刚才的写入有问题。 (6)硬件式ECC：SoC的Nand控制器可以提供硬件式ECC（这个也是比较普遍的情况）。硬件式ECC就是在Nand的控制器中有个硬件模块专门做ECC操作。当我们操作Nand芯片时，只要按照SoC的要求按时打开ECC生成开关，则当我们写入Nand芯片时SoC的Nand控制器的ECC模块会自动生成ECC数据放在相应的寄存器中，然后我们只需要将这生成的ECC数据写入Nand芯片的带外数据区即可；在将来读取这块Nand芯片时，同样要打开硬件ECC开关，然后开始读，在读的过程当中硬件ECC会自动计算读进来的一页数据的ECC值并将之放到相应的寄存器中。然后我们再读取带外数据区中原来写入时存入的ECC值，和我们刚才读的时候得到的ECC值进行校验。校验通过则说明读写正确，校验不通过则说明不正确（放弃数据或者尝试修复）。 擦除（erase）操作(1)擦除时必须给块对齐的地址。如果给了不对齐的地址，结果是不可知的（有些Nand芯片没关系，它内部会自动将其对齐，而有些Nand会返回地址错误）。 (2)读写时给的地址也是一样，要求是页对齐地址。如果给了不对齐的，也是有可能对有可能错。 页读（read）操作 nandflash控制器 SoC的Nand控制器的作用 （1）Nand芯片本身通过Nand接口电路来存取数据，Nand接口电路和soc之间通过Nand接口时序来通信。Nand接口时序相对复杂，如果要Soc完全用软件来实现Nand接口时序有一些不好（主要是：第一很难保证时序能满足、容易不稳定；第二代码很难写）。解决方案是：在SoC内部集成一个Nand控制器（实质就是块硬件电路，这个硬件电路完全满足Nand接口时序的操作，然后将接口时序的操作寄存器化）。 （2）soc和Nand芯片之间通信，在soc没有Nand控制器时需要soc自己来处理接口时序，编程很麻烦，需要程序员看Nand芯片的接口时序图，严格按照接口时序图中编程（尤其要注意各个时间参数）；在Soc有Nand控制器时soc只需要编程操控Nand控制器的寄存器即可，Nand控制器内部硬件会根据寄存器值来生成合适的Nand接口时序和Nand芯片通信。所以在有Nand控制器时编程要简单很多，我们读写Nand芯片时再也不用关注Nand接口时序了，只要关注soc的Nand控制器的寄存器即可。 （3）扩展来讲，现在的技术趋势就是：几乎所有的外设在soc内部都有对应的控制器来与其通信，那么SoC内部集成的各种控制器（也就是各种内部外设）越多，则Soc硬件能完成的功能越多，将来用这个Soc来完成相应任务时软件编程越简单。譬如说图形处理和图像处理领域，2D图像编码（jpeg编码）、视频编码（h.264编码），现在大部分的application级别的soc都有集成的内部编码器（像s5Pv210就有、更复杂的譬如4418、6818就更不用说了，只会更多更先进），我们可以利用这些硬件编码器来进行快速编解码，这样软件工作量和难度降低了很多（这就是所谓的硬件加速）。 结构框图分析（1）结构框图中关键点：SFR（编程时就是通过读写SFR来产生Nand接口时序以读写Nand芯片的）+ Nand interface（硬件接口，将来和Nand芯片的相应引脚进行连接）+ECC生成器 S5PV210的Nand控制器的主要寄存器NECONE、NECONT、NECMMD、NEADDR、NEDATA、NEMECCDO&amp;NEMECCD1、NESECCD、NESTAT Nand操作代码解析 总结（1）像 NandFlash这类芯片，通过专用的接口时序和soc内部的控制器相连（这种连接方式是非常普遍的像LCD、DDR等都是类似的连接）.这种接法和设计对我们编程来说，关键在于两点：SoC的控制器的寄存器理解和Nand芯片本身的文档、流程图等信息。（2）对于我们来说，学习 Nand1ash，要注意的是：要结合SoC的数据手册、Nand芯片的数据手册、示例代码三者来理解。 inand基本概念 iNand/eMc/ SDCard/ MMcCard的关联（1）最早出现的是MAC卡，卡片式结构，按照MC协议设计。（相较于 NandE1ash芯片来说，MAC卡有2个优势：第一是卡片化，便于拆装；第二是统一了协议接口，兼容性好。）（2）后来出现SD卡，兼容MMC协议。SD卡较MC有一些改进，譬如写保护、速率、容量等。（3）SD卡遵守SD协议，有多个版本。多个版本之间向前兼容。（4） iNand/eMMC在$D卡的基础上发展起来，较SD卡的区别就是将sD卡芯片化了（解决卡的接触不良问题，便于设备迷你化）（5） iNand和eMMC的关联：eMMc是协议， iNand是Sandisk公司符合eMMc协议的一种芯片系列名称。 iNand/eMMC的结构框图及其与 Nandflash的区别 （1）iNand内部也是由存储系统和接口电路构成，和Nand结构特性类似，不同之处在于接口电路功能不同 （2）iNand的接口电路挺复杂，功能很健全。譬如：第一，提供eMMc接口协议，和soc的eMMc接口控制器通信对接。第二，提供块的ECC校验相关的逻辑，也就是说 iNand本身自己完成存储系统的ECC功能，soc使用iNand时自己不用写代码来进行ECC相关操作，大大简化了soc的编程难度。（ Nandflash分2种：SLC和MLC，sLc更稳定，但是容量小价格高；MLC容易出错，但是容量大价格低）第三，iNand芯片内部使用MLC Nand颗粒，所以性价比很高。第四，iNand接口电路还提供了 cache机制，所以inand的操作速度很快。 iNand/ec的物理接口和sD卡物理接口的对比 （1）S5PV210芯片本身支持4通道的SD/MMC，在X210中实际是在sd/MMC0通道接了 iNand芯片，而SD/MMC2接了SD卡（SD/MMC3也接了SD卡）. （2）对比 inand和sD卡接线，发现：这两个接线几乎是一样的，唯一的区别就是SD卡IO线有4根，而 iNand的IO线有8根。 （3）这个告诉我们，我们在实际操作iNand芯片时和操作SD卡时几乎是一样的（物理接线几乎一样，软件操作协议几乎一样） 结论： iNand/eMMc其实就是芯片化的sD/MMC卡，软件操作和sD卡相同。分析iNand芯片的操作代码时，其实就是以前的SD卡的操作代码。一些细节的区别就是为了区分各种不同版本的SD卡、iNand的细节差异。 sd卡-inand操作 硬件接口：DATA、CLK、CMD （1） iNand的io线有8根，支持1、4、8线并行传输模式；SD卡io线有4根，支持1、4线并行传输模式 （2）CMD线用来传输命令、CLK线用来传输时钟信号。 （3）接口有CLK线，工作时主机soc通过CLK线传输时钟信号给SD卡/ iNand芯片，说明：SD/ iNand是同步的SD/ iNand的工作速率是由主机给它的CLK频率决定的。 命令响应的操作模式（1）SD协议事先定义了很多标准命令（CMD0、CMD1………），每个命令都有它的作用和使用条件和对应的响应。SD卡工作的时候就是一个一个的命令周期组合起来的，在一个命令周期中，主机先发送CMD给SD卡然后SD卡解析这个命令并且执行这个命令，然后SD卡根据结果回发给主机SoC一个响应。（有些命令是不需要响应的，这时SD卡不会给主机回发响应，主机也不用等待响应） 。标准的命令+响应的周期中，主机发完一个命令后应该等待SD卡的响应而不是接着发下一条命令。 SD/iNand的体系结构图（1）SD卡内部有一个接口控制器这个控制器类似于一个单片机，这个单片机的程序功能就是通过CMD线接收外部主机soc发给SD卡的命令码，然后执行这个命令并且回发响应给主机soc。这个单片机处理命令及回发响应遵循的就是SD协议。这个单片机同时可以控制SD卡内部的存储单元，可以读写存储单元。 SD/iNand的寄存器（重点是RCA寄存器） （1）注意这里说的是SD卡内部的寄存器，而不是主机Soc的SD控制器的寄存器。（很多外置芯片内部都是有寄存器的，这些寄存器可以按照一定的规则访问，访问这些寄存器可以得知芯片的一些信息） （2）RCA （relative address，相对地址寄存器）.我们在访问SD卡时，实际上SD卡内部每个存储单元的地址没有绝对数字，都是使用相对地址。相对地址由SD卡自己决定的，存放在RCA寄存器中。 Soc的sD/MMc/ iNand控制器简介 （1）不同的sσC可能在SD/MMC/iNand等支持方面有差异，但是如果支持都是通过内部提供SD控制器来支持的 （2）S5PV210的SD卡控制器在Section8.7部分 sd-inand代码分析 命令码CMD和ACMD （1）SD卡工作在命令+响应的模式下 （2）SD协议的命令分2种：CMDx和 ACMDX.CMD是单命令命令，就是单独发一个CMD即可表示一个意思。ACMD是一种扩展，就是发2个cMD加起来表示一个意思。可以认为ACMDX=cMDy+cMDz（y一般是55） 卡类型识别SD or MMC （1）MMC协议、SD协议、eMMC协议本身是一脉相承的，所以造成了一定的兼容性，所以当我们SoC控制器工作时连接到SoC上的可能是一个MC卡、也可能是SD卡、也可能是iNand芯片。主机SoC需要去识别这个卡到底是什么版本的卡 （2）SoC如何区分卡种类？因为不同版本的卡内部协议不同的，所以对卡识别命令的响应也是不同的。SoC通过发送一些命令、听取响应就可以根据不同的响应判定卡的版本 卡状态 （1）SD卡内部的接口控制器类似于一个单片机，这个单片机其实是一个状态机。所以SD卡任何时候都属于某一种状态（空闲状态、准备好状态、读写状态、出错状态··都是事先定义好的），在这种状态下能够接受的命令是一定的，接受到命令之后执行一定的操作然后根据操作结果会跳转为其他状态。如果主机发过来的命令和当前状态不符状态机就不响应，如果收到命令和当前状态相符就会执行相应操作，执行完之后根据结果跳转为其他状态。 卡回复类型 （1）一般来说，SD卡的命令都属于：命令+响应的模式。也有极少数的SD卡命令是不需要回复的 （2）卡回复有R1、R7、R1B等8种类型，每种卡回复类型都有自己的解析规则。然后卡在特定状态下响应特定命令时有可能回复哪种响应都是sD协议事先规定好的，详细细节要查阅协议文档。 SD/iNand相关的GPIo初始化GPG0相关的GPIo初始化，参考LED部分的设置技术 SD/ iNand相关的时钟系统设置 （1）SD卡本身工作需要时钟，但是自己又没有时钟发生单元，依靠主机soc的控制器通过SD接口中的CLK线传一个时钟过来给$D卡内部使用。所以主机SD卡控制器先初始化好自己的时钟，然后将自己的时钟传给SD卡 （2）因为此时刚开始和SD卡通信，主机不清楚SD卡属于哪个版本（高版本和低版本的SD卡的读写速率不同，高版本的可以工作在低版本的速率下，低版本的SD卡不能工作在高版本速率下），所以先给SD卡发400KHz的低速率时钟，SD卡拿到这个时钟后就能工作了。然后在后面和SD卡进行进一步通信时去识别SD卡的版本号，识别后再根据SD卡的版本进一步给它更合适的时钟。 命令发送函数解析 卡类型识别操作时序 卡读写时序 实验08-i2c基本概念内部集成电路(Inter－Integrated Circuit,I2C) i2c通信-芯片间通信 物理接口：SCL + SDA (1)SCL(serial clock)：时钟线，传输CLK信号，一般是I2C主设备向从设备提供时钟的通道（有时钟线，大部分都是同步传输） (2)SDA(serial data): 数据线，通信数据都通过SDA线传输（一根线，串行） 通信特征：串行、同步、非差分、低速率 (1)I2C属于串行通信，所有的数据以位为单位在SDA线上串行传输。 (2)同步通信就是通信双方工作在同一个时钟下，一般是通信的A方通过一根CLK信号线传输A自己的时钟给B，B工作在A传输的时钟下。所以同步通信的显著特征就是：有CLK通信线。 (3)非差分。因为I2C通信速率不高，而且通信双方距离很近，所以使用电平信号通信。 (4)低速率。I2C一般是用在同一个板子上的2个IC之间的通信，而且用来传输的数据量不大，所以本身通信速率很低（一般几百KHz，不同的I2C芯片的通信速率可能不同，具体在编程的时候要看自己所使用的设备允许的I2C通信最高速率，不能超过这个速率） 突出特征1：主设备+从设备 (1)I2C通信的时候，通信双方地位是不对等的，而是分主设备和从设备。通信由主设备发起，由主设备主导，从设备只是按照I2C协议被动的接受主设备的通信，并及时响应。 (2)谁是主设备、谁是从设备是由通信双方来定的（I2C协议并无规定），一般来说一个芯片可以只能做主设备、也可以只能做从设备、也可以既能当主设备又能当从设备（软件配置）。 突出特征2：可以多个设备挂在一条总线上（从设备地址） (1)I2C通信可以一对一（1个主设备对1个从设备），也可以一对多（1个主设备对多个从设备）。 (2)主设备来负责调度总线，决定某一时间和哪个从设备通信。注意：同一时间内，I2C的总线上只能传输一对设备的通信信息，所以同一时间只能有一个从设备和主设备通信，其他从设备处于“冬眠”状态，不能出来捣乱，否则通信就乱套了。 (3)每一个I2C从设备在通信中都有一个I2C从设备地址，这个设备地址是从设备本身固有的属性，然后通信时主设备需要知道自己将要通信的那个从设备的地址，然后在通信中通过地址来甄别是不是自己要找的那个从设备。（这个地址是一个电路板上唯一的，不是全球唯一的） 主要用途：SoC和周边外设之间的通信（典型的如EEPROM、电容触摸IC、各种sensor等） i2c通信时序时序：字面意思，时序就是时间顺序，实际上在通信中时序就是通信线上按照时间顺序发生的电平变化，以及这些变化对通信的意义就叫时序。 I2C的总线空闲状态、起始位、结束位 (1)I2C总线上有1个主设备，n（n&gt;=1）个从设备。I2C总线上有2种状态；空闲态（所有从设备都未和主设备通信，此时总线空闲）和忙态（其中一个从设备在和主设备通信，此时总线被这一对占用，其他从设备必须歇着）。 (2)整个通信分为一个周期一个周期的，两个相邻的通信周期是空闲态。每一个通信周期由一个起始位开始，一个结束位结束，中间是本周期的通信数据。 (3)起始位并不是一个时间点，起始位是一个时间段，在这段时间内总线状态变化情况是：SCL线维持高电平，同时SDA线发生一个从高到低的下降沿。 (4)与起始位相似，结束位也是一个时间段。在这段时间内总线状态变化情况是：SCL线维持高电平，同时SDA线发生一个从低到高的上升沿。 I2C数据传输格式（数据位&amp;ACK） (1)每一个通信周期的发起和结束都是由主设备来做的，从设备只有被动的响应主设备，没法自己自发的去做任何事情。 (2)主设备在每个通信周期会先发8位的从设备地址（其实8位中只有7位是从设备地址，还有1位表示主设备下面要写入还是读出）到总线（主设备是以广播的形式发送的，只要是总线上的所有从设备其实都能收到这个信息）。然后总线上的每个从设备都能收到这个地址，并且收到地址后和自己的设备地址比较看是否相等。如果相等说明主设备本次通信就是给我说话，如果不想等说明这次通信与我无关，不用听了不管了。 (3)发送方发送一段数据后，接收方需要回应一个ACK。这个响应本身只有1个bit位，不能携带有效信息，只能表示2个意思（要么表示收到数据，即有效响应；要么表示未收到数据，无效响应） (4)在某一个通信时刻，主设备和从设备只能有一个在发（占用总线，也就是向总线写），另一个在收（从总线读）。如果在某个时间主设备和从设备都试图向总线写那就完蛋了，通信就乱套了。 数据在总线上的传输协议 (1)I2C通信时的基本数据单位也是以字节为单位的，每次传输的有效数据都是1个字节（8位）。 (2)起始位及其后的8个clk中都是主设备在发送（主设备掌控总线），此时从设备只能读取总线，通过读总线来得知主设备发给从设备的信息；然后到了第9周期，按照协议规定从设备需要发送ACK给主设备，所以此时主设备必须释放总线（主设备把总线置为高电平然后不要动，其实就类似于总线空闲状态），同时从设备试图拉低总线发出ACK。如果从设备拉低总线失败，或者从设备根本就没有拉低总线，则主设备看到的现象就是总线在第9周期仍然一直保持高，这对主设备来说，意味着我没收到ACK，主设备就认为刚才给从设备发送的8字节不对（接收失败） s5pv210的i2c控制器通信双方本质上是通过时序在工作，但是时序会比较复杂不利于SoC软件完成，于是乎解决方案是SoC内部内置了硬件的控制器来产生通信时序。这样我们写软件时只需要向控制器的寄存器中写入配置值即可，控制器会产生适当的时序在通信线上和对方通信。 结构框图 (1)时钟部分，时钟来源是PCLK_PSYS，经过内部分频最终得到I2C控制器的CLK，通信中这个CLK会通过SCL线传给从设备。 (2)I2C总线控制逻辑（前台代表是I2CCON、I2CSTAT这两个寄存器），主要负责产生I2C通信时序。实际编程中要发送起始位、停止位、接收ACK等都是通过这两个寄存器（背后所代表的电路模块）实现的。 (3)移位寄存器（shift register），将代码中要发送的字节数据，通过移位寄存器变成1个位一个位的丢给SDA线上去发送/接收。学过数字电路的同学应该对移位寄存器不陌生。 (4)地址寄存器+比较器。本I2C控制器做从设备的时候用。(我没用过，理论分析) 系统分析I2C的时钟 (1)I2C时钟源头来源于PCLK（PCLK_PSYS，等于65MHz），经过了2级分频后得到的。 (2)第一级分频是I2CCON的bit6，可以得到一个中间时钟I2CCLK（等于PCLK/16或者PCLK/512） (3)第二级分频是得到最终I2C控制器工作的时钟，以I2CCLK这个中间时钟为来源，分频系数为[1,16] (4)最终要得到时钟是2级分频后的时钟，譬如一个可用的设置是：65000KHz/512/4=31KHz 主要寄存器I2CCON、I2CSTAT、I2CADD、I2CDS I2CCON + I2CSTAT：主要用来产生通信时序和I2C接口配置。 I2CADD：用来写自己的slave address I2CDS：发送/接收的数据都放在这里 x210板载gsensor介绍 原理图查阅 (1)gsensor的供电由PWMTOUT3引脚控制。当PWMTOUT3输出低电平时gsensor无电不工作；当输出高电平时gsensor才会工作。 (2)gsensor的SDA和SCL接的是S5PV210的I2C端口0 (3)将来编程时在gsensor_init函数中要去初始化相关的GPIO。要把相应的GPIO设置为正确的模式和输入输出值。 重力加速度传感器简介 (1)用在手机、平板、智能手表等设备上，用来感受人的手的移动，获取一些运动的方向性信息用来给系统作为输入参量。 (2)可以用来设计智能手表的计步器功能。 (3)重力加速度传感器、地磁传感器、陀螺仪等三个传感器结合起来，都是用来感谢运动的速度、方位等信息的，所以现在最新的有9轴传感器，就是把三者结合起来，并且用一定的算法进行综合得出结论，目的是更加准确。 (4)一般传感器的接口有2种：模拟接口和数字接口。模拟接口是用接口电平变化来作为输出的（譬如模拟接口的压力传感器，在压力不同时输出电平在0～3.3V范围内变化，每一个电压对应一个压力。），SOC需要用AD接口来对接这种传感器对它输出的数据进行AD转换，转换得到数字电压值，再用数字电压值去校准得到压力值；数字接口是后来发展出来的，数字接口的sensor是在模拟接口的sensor基础上，内部集成了AD，直接（通过一定的总线接口协议，一般是i2C）输出一个数字值的参数，这样SoC直接通过总线接口初始化、读取传感器输出的参数即可（譬如gsensor、电容触摸屏IC）。 I2C从设备的设备地址 (1)KXTE9的I2C地址固定为0b0001111（0x0f） (2)I2C从设备地址本身是7位的，但是在I2C通信中发送I2C从设备地址时实际发送的是8位，这8位中高7位（bit7-bit1）对应I2C从设备的7位地址，最低一位（LSB）存放的是R/W信息（就是说下一个数据是主设备写从设备读（对应0），还是主设备读从设备写（对应1）） (3)基于上面讲的，对于KXTE9来说，主设备（SoC）发给gsensor信息时，SAD应该是：0b00011110(0x1E)如果是主设备读取gsensor信息时，SAD应该是：0b00011111（0x1F） I2C从设备的通信速率 (1)I2C协议本身属于低速协议，通信速率不能太高。 (2)实际上通信的主设备和从设备本身都有最高的通信速率限制（属于各个芯片本身的参数），实际编程时怎么确定最终的通信速率？只要小于两个即可。 (3)一般来说只能做从设备的sensor芯片本身i2c通信速率偏低，像KXTE9最高支持400KHz的频率。 I2C总线的通信流程 S5PV210的主发送流程图 S5PV210的主接收流程图 gsensor的写寄存器流程图 gsensor的读寄存器流程图 I2C通信代码分析1 (1)控制器初始化：s3c24xx_i2c_init,初始化GPIO，设置IRQEN和ACKEN，初始化I2C时钟,I2C控制器主模式开始一次读写：s3c24xx_i2c_message_start (2)I2C控制器主模式结束一次读写：s3c24xx_i2c_stop I2C通信代码分析2 框架分析：我们最终目的是通过读写gsensor芯片的内部寄存器来得到一些信息。为了完成这个目的，我们需要能够读写gsensor的寄存器，根据gsensor的规定我们需要按照一定的操作流程来读写gsensor的内部寄存器，这是一个层次（姑且叫做传输层、协议层、应用层）；我们要按照操作流程去读写寄存器，就需要考虑I2C接口协议（这就是所谓的物理层，本质就是那些时序）。此时主机SoC有或者没有控制器，有控制器时考虑控制器的寄存器，没控制器时要自己软件模拟时序。 协议层的代码主要取决于gsensor芯片；物理层代码主要取决于主机SoC。 gsensor写寄存器：gsensor_i2c_write_reg gsensor读寄存器：gsensor_i2c_read_reg gsensor编程：gsensor_initial等 实验09-adc基本概念(1)ADC:analog digital converter,AD转换，模数转换，模拟转数字(2)CPU本身是数字的，而外部世界变量（如电压、温度、高度、压力···）都是模拟的，所以需要用CPU来处理这些外部的模拟变量的时候就需要做AD转换。 模拟量和数字量(1)模拟的就是连续的，现实生活当中的时间、电压、高度等都是模拟的（连续分布的，划分的话可以无限的更小划分）。模拟量反映在数学里面就是无限小数位（从0到1之间有无数个数） (2)数字的就是离散的，离线的就是不连续的。这种离散处理实际上是从数学上对现实中的模拟量的一种有限精度的描述。数字化就是离散化，就是把连续分布的模拟量按照一定精度进行取点（采样）变成有限多个不连续分布的数字值，就叫数字量。 (3)数字化的意义就在于可以用（离散）数学来简化描述模拟量，这东西是计算机技术的基础。 (4)计算机处理参量的时候都是数字化的，计算机需要数字化的值来参与运算。如果系统输入参数中有模拟量，就需要外加AD转换器将模拟量转成数字量再给计算机。 (5)纯粹用cpu是不可能实现数字转模拟，因为cpu本身就是数字的。使用一些（具有一些积分或微分效果的）物理器件就可实现数字转模拟。 (6)数字转模拟的作用。譬如可以用来做波形发生器。 adc主要相关概念 量程（模拟量输入范围） (1)AD转换器是一个电子器件，所以他只能输入电压信号。其他种类的模拟信号要先经过传感器（Sensor）的转换变成模拟的电压信号然后才能给AD。 (2)AD输入端的模拟电压要求有一个范围，一般是0～3.3V或0～5V或者是0～12V等等。模拟电压的范围是AD芯片本身的一个参数。实际工作时给AD的电压信号不能超过这个电压范围。 精度（分辨率resolution） (1)AD转换输出的数字值是有一定的位数的（譬如说10位，意思就是输出的数字值是用10个二进制位来表示的，这种就叫10位AD）。这个位数就表示了转换精度。 (2)10位AD就相当于把整个范围分成了1024个格子，每个格子之间的间隔就是电压的表示精度。加入AD芯片的量程是0～3.3V，则每个格子代表的电压值是3.3V/1024=0.0032265V。如果此时AD转换后得到的数字量是447，则这个数字量代表的模拟值是：447×0.0032265V=1.44V。 (3)AD的位数越多，则每个格子表示的电压值越小，将来算出来的模拟电压值就越精确。 (4)AD的模拟量程一样的情况下，AD精度位数越多精度越高，测出来的值越准。但是如果AD的量程不一样。譬如2个AD，A的量程是0～50V，B的量程是0～0.5V，A是12位的，B是10位的，可能B的精度比A的还要高。（A的精度：50/1024=0.04883，B的精度：0.5/4096=0.000122） 转换速率（MSPS与conventor clock的不同） (1)首先要明白：AD芯片进行AD转换是要耗费时间的。这个时间需要多久，不同的芯片是不一样的，同一颗芯片在配置不一样（譬如说精度配置为10位时时间比精度配置为12位时要小，譬如说有些AD可以配转换时钟，时钟频率高则转换时间短）时转换时间也不一样。 (2)详细的需要时间可以参考数据手册。一般数据手册中描述转换速率用的单位是MSPS（第一个M是兆，S是sample，就是采样；PS就是per second，总的意思就是兆样本每秒，每秒种转出来多少M个数字值） (3)AD工作都需要一个时钟，这个时钟有一个范围，我们实际给他配置时不要超出这个范围就可以了。AD转换是在这个时钟下进行的，时钟的频率控制着AD转换的速率。注意：时钟频率和MSPS不是一回事，只是成正比不是完全相等。譬如S5PV210中的AD转换器，MSPS = 时钟频率/5 通道数 (1)AD芯片有多少路analog input通道，代表了将来可以同时进行多少路模拟信号的输入。 s5pv210的adc控制器 ADC和（电阻式）触摸屏的关系 (1)ADC在210的数据手册的Section10.7 (2)电阻式触摸屏本身工作时依赖于AD转换，所以在210的SoC中电阻触摸屏接口本身和ADC接口是合二为一的。或者说电阻触摸屏接口使用了（复用了）ADC的接口。 ADC的工作时钟框图 (1)ADCCLK是ADC控制器工作的时钟，也就是1.13.2.3节中讲到的conventor clock。从时钟框图可以看出，它是PCLK（当然是PCLK_PSYS）经过了一次分频后得到的。所以将来初始化ADC控制器时一定有一个步骤是初始化这里的分频器。 210的10个ADC通道（注意ADC引脚和GPIO的区别） (1)210一共支持10个ADC通道，分别叫AIN[0] ~ AIN[9]。理论上可以同时做10路AD转换。 (2)SoC的引脚至少分2种：digit数字引脚和analog模拟引脚。我们以前接触的GPIO都属于数字引脚，ADC channel通道引脚属于模拟引脚。数字引脚和模拟引脚一般是不能混用的。 ADC控制器的主要寄存器 TSADCCON0 TSDATX0 TSDATY0 转出来的AD值存在这里，我们读也是读这里 CLRINTADC0 清中断 ADCMUX 选择当前正在操作的AD通道 (1)等待触摸屏转换完毕的方法有2种：一种是检查标志位，第二种是中断。第一种方式下我们先开启一次转换然后循环不停检查标志位直到标志位为1表明已经转换完可以去读了；第二种方式下就是设置好中断，写好中断isr来读取AD转换数据。然后开启中断后CPU就不用管了，等AD转换完成后会生成一个中断信号给CPU，就会进入中断处理流程。第一种方法是同步的，第二种方式是异步的。 (2)AD转换都是需要反复进行的，那么转完一次一般要立即开启下一次转换，所以需要有一种机制能够在一次转完时自动开启下一次。这个机制就叫start by read，这个机制的工作方法是：当我们读取本次AD转换的AD值后，硬件自动开启下一次AD转换。 ad转换的编程 AD控制器初始化 循环进行AD采样 AD转换的编程实践2 编译运行调试 start by read模式介绍 (1)应用方法：开启start by read模式，第一次先读一次丢掉，这次读就能开启下一次AD转换，然后以后就可以不停的读取AD值了。 DAC的应用简介 实验10-lcd显示器基本概念 LCD简介 (1)LCD(Liquid Crystal Display)俗称液晶。 (2)液晶是一种材料，液晶这种材料具有一种特点：可以在电信号的驱动下液晶分子进行旋转，旋转时会影响透光性，因此我们可以在整个液晶面板后面用白光照（称为背光），可以通过不同电信号让液晶分子进行选择性的透光，此时在液晶面板前面看到的就是各种各样不同的颜色，这就是LCD显示。 (3)被动发光和主动发光。有些显示器（譬如LED显示器、CRT显示器）自己本身会发光称为主动发光，有些（LCD）本身不会发光只会透光，需要背光的协助才能看起来是发光的，称为被动发光。 (4)液晶应用领域：电视机、电脑显示屏、手机显示屏、工业显示屏等···· 其他主流显示设备（LED、CRT、等离子、OLED） (1)CRT：阴极摄像管显示器。 (2)等离子显示：未成为主流 (3)OLED：目前未成为主流，但是很有市场潜力 (4)LED：主要用在户外大屏幕 (5)LCD：目前是主流显示器 LCD的显示原理和特点(液晶分子透光+背光) (1)白光其实是由各种不同颜色的光组成的，所以白光被选择性透光之后可以产生各种不同颜色的光。 LCD的发展史和种类(TN/STN/TFT) (1)TN最早。坏处是响应性不够好，有拖尾现象。 (2)STN是TN的升级版。有效解决拖尾现象，显示更清晰。 (3)TFT的最大特点就是超薄。 (4)TFT技术之上发展出来很多更新的技术。 参考资料一 参考资料二 lcd的接口技术从电平角度来讲本质上都是TTL信号 (1)什么是TTL接口。+5V表示逻辑1，0V表示逻辑0.这种就叫TTL电平，和CMOS电平相对比。 (2)SoC的LCD控制器硬件接口是TTL电平的，LCD这边硬件接口也是TTL电平的。所以他们俩本来是可以直接对接的，手机、平板、开发板都是这样直接对接的（一般用软排线连接）。 (3)TTL电平的缺陷就是不能传递太远，如果LCD屏幕和主板控制器太远（1米甚至更远）就不能直接TTL连接了，要进行转换。转换方式：主机SoC(TTL) -&gt;VGA-&gt; LCD屏幕(TTL) 各种接口（TTL、LVDS、EDP、MIPI、）在传输速率、距离、适配性方面不同参考资料 RGB接口详解(参考数据手册P1207页时序图) (1)VD[23:0]：24根数据线，用来传输图像信息。可见LCD是并行接口，速率才够快。 (2)HSYNC(水平同步信号) (3)VSYNC(垂直同步信号)：时序信号线，为了让LCD能够正常显示给的控制信号。 (4)VCLK(像素时钟)：LCD工作时需要主板控制器给LCD模组一个工作时钟信号，就是VCLK。 (5)VDEN(数据有效标志)：时序信号，和HSYNC、VSYNC结合使用。 (6)LEND(行结束标志，不是必须的)：时序信号，非必须，譬如X210接口就没有。 lcd显示图像 像素(pixel) (1)像素就是组成图像的最基本元素，或者说显示中可以被控制的最小单位，整个图像就是由很多个像素组成的。 (2)像素可以被单独控制，或控制其亮或不亮（单色屏）、或控制其亮度强弱（譬如亮50%，35%，这样叫灰度屏，以前的黑白电视机）、或控制其显示一定的颜色（这就是我们现在最常用的彩色显示屏）。 总结：像素很重要，整个显示图像是由一个个的像素组成的。我们要在显示器上显示一个图像，就是把这个图像离散化成一个一个的点，然后把各个点的颜色对应在显示器的像素上。 扫描 (1)扫描是一个动作而不是一个名字，扫描就是依次将颜色数值放入屏幕中所有的像素的这个过程。 (2)扫描这个词是由最早的CRT显示器遗留下来的，到LCD显示器的年代本来已经失去意义了，但是我们还是延续着这么叫。 (3)显示器的扫描显示原理依赖于人眼的视觉暂留。只要显示器扫描频率大于人眼的发现频率，人眼看到的图像就是恒定的。如果扫描频率偏小人眼就会看到闪动。（扫描频率的概念就叫做刷新率） 驱动器&amp;控制器 (1)LCD驱动器一般和LCD显示面板集成在一起（本来是分开的，做面板的是只做面板的，譬如说三星、LG、台湾的友达、奇美都是做面板的；驱动器也由专门的IC厂商生产；集成厂商买来面板和驱动器后集成在一起做成LCD屏幕），面板只负责里面的液晶分子旋转透光，面板需要一定的模拟电信号来控制液晶分子；LCD驱动器芯片负责给面板提供控制液晶分子的模拟电信号，驱动器的控制信号（数字信号）来自于自己的数字接口，这个接口就是LCD屏幕的外部接口（第二节中讲到的接口） (2)LCD控制器一般集成在SoC内部，他负责通过数字接口向远端的LCD驱动器提供控制像素显示的数字信号。LCD控制器的关键在于时序，它必须按照一定的时序和LCD驱动器通信；LCD控制器受SoC控制，SoC会从内存中拿像素数据给LCD控制器并最终传给LCD驱动器。 显示内存(简称：显存) (1)SoC在内存中挑选一段内存（一般来说是程序员随便挑选的，但是挑选的时候必须符合一定规矩），然后通过配置将LCD控制器和这一段内存（以后称为显存）连接起来构成一个映射关系。一旦这个关系建立之后，LCD控制器就会自动从显存中读取像素数据传输给LCD驱动器。这个显示的过程不需要CPU的参与。 (2)显示体系建立起来后，CPU就不用再管LCD控制器、驱动器、面板这些东西了；以后CPU就只关心显存了，因为我只要把要显示的图像的像素数据丢到显存中，硬件就会自动响应（屏幕上就能自动看到显示的图像了）。 总结：LCD显示是分为2个阶段的：第一个阶段就是建立显示体系的过程，目的就是CPU初始化LCD控制器使其和显存联系起来构成映射；第二个阶段就是映射建立之后，此阶段主要任务是将要显示的图像丢到显存中去。 lcd的六个主要时序参数 LCD显示单位：帧（frame） (1)显示器上一整个画面的内容成为一个帧(frame)，整个显示器工作时是一帧一帧的在显示。 (2)电影实际就是以每秒种24帧的速度在播放图片。 (3)帧内数据：一帧分为多行，一行分为多像素，因此一帧图像其实就是多个像素组成的矩阵。 (4)帧外数据：整个视频由很多个帧构成，最终播放视频时逐个播放各个图像帧即可。 LCD显示一帧图像的过程 (1)首先把帧分为行，然后再把行分为像素，然后逐个像素去显示。（显示像素：其实就是LCD驱动器按照接收到的LCD控制器给的显示数据，驱动一个像素的液晶分子旋转，让这个像素显示出相应的颜色值的过程） (2)关键点：LCD控制器和驱动器之间一次只能传一个像素点的显示数据。所以一帧图像在屏幕上其实是串行的依次被显示上去的，不是同一时间显示出来的。 为了向前兼容出现的六个时序参数HSPW 水平同步信号脉宽HBPD 水平同步信号前肩HFPD 水平同步信号后肩VSPW 垂直同步信号脉宽VBPD 垂直同步信号前肩VFPD 垂直同步信号后肩 (1)一行的通信过程是这样的：LCD控制器先发送一个HSYNC高电平脉冲（脉冲宽度是HSPW），脉冲告诉驱动器下面的信息是一行信息。然后开始这一行信息，这一行信息包括3部分：HBPD+有效行信息+HFPD。其中前肩和后肩都属于时序信息（和LCD屏幕具体有关），有效行信息就是横向分辨率。所以你可以认为一行总共包含4部分：HSPW+HBPD+有效行信息+HFPD。 (2)一帧图像其实就是一列，一列图像由多个行组成，每行都是上面讲的这个时序。 (3)一帧图像的通信过程是这样的：整个帧图像信号分为4部分：VSPW+VBPD+帧有效信号+VFPD。VSPW是帧同步信号宽度，用来告诉驱动器一帧图像要开始了；VBPD和VFPD分别是垂直同步信号前后肩。 (4)必须说明：这6个参数对于LCD显示器其实本来是没用的，这些信号其实是老式的CRT显示器才需要的，LCD本身不需要，但是出于历史兼容性要求，LCD选择了兼容CRT显示器的这些时序要求，所以理解LCD显示器时序和编程时，用CRT的方式来理解不会错。 (5)要注意，这几个时序参数本身是LCD屏幕本身的参数，与LCD控制器无关。所以同一个主板如果接的屏幕不一样则时序参数设置也会不同。这些参数的来源一般是：第一，厂家会直接给出，一般以实例代码的形式给出；第二，来自于LCD的数据手册。 第一种方式，查看九鼎的210裸机教程（x210v3裸机开发教程\src\template-framebuffer-font\source\hardware\s5pv210-fb.c的第774行） .h_fp = 210, // 160-210-354 .h_bp = 38, // 46 .h_sw = 10, // 1-40 .v_fp = 22, // 7-22-147 .v_fpe = 1, .v_bp = 18, // 23 .v_bpe = 1, .v_sw = 7, // 1-20第二种方式，查看LCD数据手册（X210光盘资料\A盘\DataSheet\AT070TN92.pdf） 补充： 1、注意这些数字的单位。H开头的三个单位都是DCLK(像素时钟),V开头的三个单位是TH。这样设置的好处是我们改变了像素时钟的设置时，不用改变这里的时序参数。 2、这些时序参数如果没设置好会影响什么？屏幕会跑偏。 lcd显示的主要相关概念 像素（pixel） (1)整个图像是由一个个的像素组成的，像素就是一个显示点。1.14.7.2、像素间距（pitch） (1)pitch是连续2个像素的像素中心的距离。一般的像素是方形的，所以横向pitch和纵向的pitch一样的。但是也有不一样的。 (2)像素间距会影响屏幕的最佳观看距离。像素间距大的适合远距离看，像素间距小的适合近距离看。 分辨率（resolution） (1)整个屏幕的横向和纵向的像素个数就叫分辨率，譬如X210开发板用的屏幕是800×480. (2)屏幕尺寸和分辨率无关的，像开发板的屏幕尺寸是7寸的（纯屏幕对角线尺寸是7英寸）。 (3)屏幕尺寸和分辨率和像素间距三者之间有关联。 清晰度 (1)清晰度是一个主观概念，是人眼对显示效果的一个主观判断。说白了就是人看起来感觉清晰不清晰。 (2)客观来讲，清晰度由分辨率和像素间距共同决定。一般的，屏幕尺寸固定时分辨率越高越清晰，分辨率越低就越不清晰；分辨率固定下，屏幕尺寸越小越清晰，越大越不清晰。 (3)清晰度还由其他很多因素共同决定。 像素深度（bits per pixel，简称bpp） (1)一个像素在计算机中由多少个字节数据来描述。 (2)计算机中用二进制位来表示一个像素的数据，用来表示一个像素的数据位越多，则这个像素的颜色值更加丰富、分的更细，颜色深度就更深。 (3)一般来说像素深度有这么几种：1位、8位、16位、24位、32位。 颜色在计算机中的表示 (1)颜色是主观存在，颜色其实是自然光在人的眼睛中和大脑中产生的一种映像。 (2)颜色的本质决定于光的波长。 自然光的颜色是连续的 (1)光的波长是连续的，导致颜色也是连续的。理论上，只要你的眼睛分辨能力足够好，可以在自然界中发现无数中颜色。 计算机中的颜色是离散的 (1)计算机中不可能存储无数种颜色，所以必须将颜色有限化，所以就用有限种颜色来代表自然界中的无限种颜色。这个理论非常类似于之前学过的AD转换。 (2)这种离散化表达颜色的缺点是不够真实，漏掉了很多种颜色。因此计算机中所能表达的颜色没有自然界中丰富（计算机屏幕上显示的图像和真实图像有差别） (3)计算机所能表达的颜色种类个数，这个参数叫：像素深度bpp。 常见像素深度：1位、8位、16位、24位、32位 1位：用1个二进制位来表示颜色，这种就叫单色显示。示例就是小饭店、理发店门口的LED屏。 8位：用8个二进制位来表示颜色，此时能表示256种颜色。这种叫灰度显示。这时候是黑白的，没有彩色，我们把纯白到纯黑分别对应255到0，中间的数值对应不同的灰。示例就是以前的黑白电视机。 16位：用16个二进制位表示颜色，此时能表示65536种颜色。这时候就可以彩色显示了，一般是RGB565的颜色分布（用5位二进制表示红色、用6位二进制表示绿色、用5位二进制表示蓝色）。这种红绿蓝都有的颜色表示法就是一种模拟自然界中所有颜色的表示方式。但是因为RGB的颜色表达本身二进制位数不够多（导致红绿蓝三种颜色本身分的都不够细致），所以这样显示的彩色失真比较重，人眼能明显看到显示的不真实。 24位：用24个二进制位来表示颜色，此时能表示16777216种颜色。这种表示方式和16位色原理是一样的，只是RGB三种颜色各自的精度都更高了（RGB各8位），叫RGB888。此时颜色比RGB565更加真实细腻，虽然说比自然界无数种颜色还是少了很多，不过由于人眼的不理想性所以人眼几乎不能区分1677万种颜色和无数种颜色的差别了。于是乎就把这种RGB888的表示方法叫做真彩色。（RGB565就是假彩色） 32位：总共用32位二进制来表示颜色，其中24位表示红绿蓝三元色（还是RGB888分布），剩下8位表示透明度。这种显色方式就叫ARGB（A是阿尔法，表示透明度），现在PC机中一般都用ARGB表示颜色。 补充：颜色的组成，三元色（三基色）是RGB，也就是说所有的颜色都可以由红绿蓝三种颜色组成。 s5pv210的lcd控制器 FIMD结构框图 (1)210的LCD控制器叫FIMD，FIMD是210内部和图像处理相关的一些部件，在摄像头等和图像处理有关的部分都可以有关联。 (2)FIMD在内部与AHB总线等相连接，在外部提供RGB接口、I80接口、YUV接口与外部相连接，我们实际使用的是RGB接口。 虚拟屏幕叠加（数据手册P1194） (1)虚拟屏幕的意思是，我们平时看到的屏幕上显示出来的场景实际是很多个屏幕显示叠加在一起的效果（譬如新闻图像、电视台台标、下方飘动的字幕新闻） (2)像S5PV210的LCD控制器中有5个虚拟屏幕Window0到Window4，虚拟屏幕不存在于真实而存在于内存中。（之前讲过，LCd显示时实际是显示的是对应的内存中的显存区域的数值）虚拟屏幕其实就是一个内存中的显存区域，有几个显存区域就有几个虚拟屏幕，但是这些虚拟屏幕都被映射到一个真实的显示屏上面，所以将来真实的现实效果实际是这几个虚拟屏幕的显示内容的叠加。（叠加时要注意上面一层会覆盖下面一层，所以要注意谁在前谁在后，设置寄存器时有这个选项） (3)使用虚拟屏幕而不是整个LCD使用一个显存是有一定好处的：第一，可以保证不污染源图像，方便程序处理；第二，可以减少屏幕刷新，提高显示效率，减少CPU工作量。 虚拟显示（数据手册P1206） (1)如何实现在小分辨率的屏幕上（真实）显示大分辨率的图像 (2)细节上，我们需要屏幕上看到不同图像时，需要对显存区域进行刷新。即使我们只需要屏幕显示移动一点点，整个屏幕对应的显存空间也需要整个重新刷新，工作量和完全重新显示一幅图像是一样的。这个显然不好，这样CPU刷新屏幕的工作量太大了，效率很低。 (3)如何能够在显示一个大图片的不同区域时让CPU刷新屏幕工作量减少？有，方法就是虚拟显示。具体做法就是在内存中建立显示缓存的时候实际建立一个很大的区域，然后让LCD去对应其中的一部分区域作为有效的显示区域。将来要显示大图像时，直接将大图像全部一次性加载入显示缓存区，然后通过移动有效显示区域就可以显示大图像的不同区域了。 主要寄存器简介 实验项目lcd显示器-01-控制器初始化 LCD编程实战1-LCD控制器初始化 参考代码lcd_init函数详解 (1)要想LCD工作，必须给LCD屏幕和显存之间建立一个映射（映射是在CPU初始化LCD控制器来完成的）。本部分就是在完成这个过程（这也是LCD显示的2个阶段的第一阶段，第二阶段中我们只需要给显存中丢入相应的数据，LCD屏幕就会自动显示相应内容）。 lcd显示器-02-显示像素 LCD编程实战2-显示像素&amp;刷背景 (1)显示像素 (2)刷背景色 lcd显示器-03-画线 LCD编程实战3-横线竖线斜线&amp;画圆 (1)画横线&amp;竖线 (2)斜线 lcd显示器-04-显示字符 LCD编程实战4-写英文中文字符 lcd显示器-05-画图 LCD编程实战5-画图 图片显示分析 (1)图像是彩色的，而之前的文字、图形都是单色的。之前的图形文字绘制函数都有个color参数，就是传给显存告诉它这个像素的显示颜色。 (2)一副分辨率是800×480，BPP是24的图片，实际上就是800×480×3字节的数据。将来写代码将图片显示到LCD中时，图片将会以 unsigned char pic_data[800×480×3]的形式出现。 Image2LCD使用简介 (1)如何由一副图片得到它对应的数据的数组？要用取模工具，如Image2LCD。1.14.14.3、画图函数的编写 画图函数的显示效果测试 RGB的像素顺序调整 (1)图片中红色的变成了蓝色、蓝色的变成了红色，这就说明RGB顺序反了。 (2)解决方案一：重新使用Image2LCD来取模，取模时RGB顺序对调。 (3)解决方案二：不重新取模，改代码，在color形成的时候调换顺序。 小分辨率图片显示 (1)本质上大小分辨率的图像显示都是一样的，都是：都是在图像的每个像素点对应的显存中填入相应的颜色值即可。 lcd显示器-06-未完成事项 RGB565和RGB888 (1)单片机等性能和资源有限的平台会用RGB565，嵌入式平台习惯用RGB888. (2)有时候手头只有RGB888的颜色值，但是显示部分却只接受RGB565的（有时候反过来），这时候就需要在2种颜色之间做转换。 不同分辨率、不同起点坐标下的显示 (1)屏幕分辨率和图像分辨率不同时的显示。我们现在写的代码都是没有考虑的。 (2)图像起点坐标（左上角坐标）不一定在屏幕左上角，也可能在屏幕的任何其他区域，这种情况下画图的函数要做处理来支持。 (3)分辨率不同而且起始坐标不同下，这两个问题组合起来也对画图函数提出了更高要求。 bmp图片格式解析及显示 (1)我们当前的图像数据是用Image2LCD工具转过来的。实践中是不可能手工用工具来转的（你想一下Image2LCD也是一个软件，既然它能转，我们也应该可以用软件来转） (2)bmp格式的图片本身遵照一定的格式来存储的，我们只需按照bmp的解析格式来读取文件就可得到这幅图片的图像数据的二进制，直接拿去显示。（这就是图片文件的本质） jgp、png、gif等压缩图片的解码和显示 (1)对于以上压缩格式的图片是不能直接解析的，必须用相应的库来解压缩图片之后才能拿来显示。 (2)不同的格式的图片其压缩算法不同，解压缩算法自然也不同。开源社区中每种压缩格式都有个对应的库，库里提供了这种格式的压缩和解压缩函数，我们只需要移植这个库并且调用它来压缩或解压缩即可。 图片缩小和放大显示 (1)图片数据源本来是400×200的，但是显示时我希望显示成100×50的，这时候就要显示函数后台对源图像进行先缩小，然后再显示。这时候就需要一个缩小算法。（譬如最简单的算法就是抽点采样） (2)图片数据源是100×50的，但是显示时希望全屏显示（800×480），这时候就需要对源图像进行放大然后再显示（当然了显示出来图像清晰度肯定比较低），这时候就需要一种放大算法（譬如插点方式） 显示动画 (1)动态刷屏形成动画 (2)立体3D图像显示（伪3D） 实验11-触摸屏基本概念输入类设备简介 input/output (1)IO输入输出，是计算机系统中的一个概念。计算机的主要功能就是从外部获取数据然后进行计算加工得到输出数据并输出给外部（计算机可以看成数据处理器）。计算机和外部交互就是通过IO。每一台计算机都有个标准输入和标准输出。 常见输入类设备 (1)键盘、鼠标、触摸屏、游戏摇杆、传感器、（摄像头并不是一个典型的输入类设备） 触摸屏的特点 (1)触摸屏和人的关系很紧密，尤其是电容式触摸屏。 (2)触摸屏和显示器关系很紧密。 (3)典型应用：手机、平板电脑、收银机、工业领域。 触摸屏的分类 (1)常见的触摸屏分为2种：电阻式触摸屏和电容式触摸屏。早期用电阻式触摸屏，后来发明了电容式触摸屏。 (2)这两种的特性不同、接口不同、编程方法不同、原理不同。 触摸屏和显示屏的联系与区别 (1)首先要搞清楚：触摸屏是触摸屏，用来响应人的触摸事件的；显示屏是显示屏，用来显示的。现在用的显示屏一般都是LCD。 (2)为什么很多人会搞混这两个概念，主要是因为一般产品上触摸屏和显示屏是做在一起的。一般外层是一层触摸屏，触摸屏是透明的，很薄；底下是显示屏用来显示图像，平时看到的图像是显示屏显示并且透过触摸屏让人看到的。 电阻式触摸屏的原理 薄膜+玻璃（需要尖锐硬物点击） (1)要点是薄、透明。前面板硬度稍弱，可以被硬物按下弯曲，后面板硬度很高，不会弯曲。 (2)前面板和后面板在平时没有挨住，在外力按下之下，前面板发生（局部）形变，在这一点上前后面板会挨住。 ITO（导电+透明+均匀压降） (1)ITO是一种材料，其实是一种涂料，特点就是透明、导电、均匀涂抹。 (2)本来玻璃和塑料都是不导电的，但是涂上ITO之后就变成导电了（同时还保持着原来透明的特性）。 (3)ITO不但导电而且有电阻，所以中间均匀涂抹了ITO之后就相当于在x1和y1之间接了一个电阻，在x2和y2之间也接了一个电阻。因为ITO形成的等效电阻在整个板上是均匀分布的，所在在板子上某一点的电压值和这一点的位置值成正比。 (4)触摸屏经过操作，按下之后要的就是按下的坐标，坐标其实就是位置信息，这个位置信息和电压成正比了，而这一点的电压可以通过AD转换得到。这就是整个电阻式触摸屏的工作原理。 X/Y轴分时AD转换 (1)下面要研究如何得到按下的这点的电压。 (2)在第一个面板的一对电极上加电压，然后在另一个面板的一个电极和第一个面板的地之间去测量。在没有按下时测试无结果，但是在有人按下时在按下的那一点2个面板接触，接触会导致第二个面板上整体的电压值和接触处的电压值相等，所以此时测量到的电压就是接触处在第一个面板上的电压值。 (3)以上过程在一个方向进行一次即可测得该方向的坐标值，进行完之后撤掉电压然后在另一个方向的电极上加电压，故伎重施，即可得到另一个方向的坐标。至此一次触摸事件结束。 电压值对应坐标值（校准） (1)电压值和坐标值成正比的，所以需要去校准它。校准就是去计算(0, 0)坐标点的电压值是多少。 s5pv210的电阻触摸屏控制器 ADC与触摸屏控制器结构框图 (1)S5PV210一共支持10路模拟输入，分别为AIN0-AIN9.其中AIN0和AIN1是只做模拟输入的，AIN2-AIN9分别可以支持2个电阻式触摸屏。所以4个模拟输入引脚负责一个电阻式触摸屏。 (2)AD转换和触摸屏控制部分有2个附属单元。其中一个是反向控制AINn引脚的逻辑，主要作用是在触摸屏获取坐标的过程中分时给xy方向供电和测量；第二个是中断产生部件，如果AD转换完成（主要针对AIN0和AIN1这两路的）或者触摸屏被人按下/弹起时，中断产生部件会产生一个中断通知CPU来处理事件，这样就不用轮询监测触摸屏事件了。 Normal Operation Mode &amp; Separate X/Y Position Convertion Mode (1)AD转换器有2种工作模式：正常操作模式和分时X/Y位置转换模式。 (2)正常操作模式用作普通的AD转换，分时X/Y位置转换模式用作电阻式触摸屏。正常AD转换下将AD转换值放在TSDATX中，在分时X/Y模式下会将X/Y坐标分别放在TSDATX和TSDATY中。 (3)对于AIN0和AIN1来说没有这么多模式，他们只能工作在普通模式；对于AIN2-AIN9来说，因为被复用，所以才有2种模式。如果我们将这几个引脚用作普通AD转换则配置为普通模式，如果用作电阻式触摸屏检测，则配置成分时X/Y模式。 中断参与 (1)其实普通AD转换和触摸屏AD转换本身都可以不在中断参与下完成。 (2)普通AD转换如果不要中断，那就去查询。开启一次转换后然后不断查询标志位，直到AD转换完硬件自动置位标志位后我们才去读取转换值就不会错。当然也可以用中断，控制器提供了一个相应的中断给普通AD转换。 (3)触摸屏也可以用或者不用中断。对于SoC来说永远不知道人会什么时候按下或者弹起触摸屏，所以触摸屏的按下/弹起对SoC来说是纯粹的异步事件。对于这种情况SOC只有2种解决方案：轮询和中断。1.15.3.4、主要寄存器 电容触摸屏的原理 人体电流感应 (1)利用人体电流感应现象，在手指和屏幕之间形成一个电容，手指触摸时吸走一个微小电流，这个电流会导致触摸板上4个电极上发生电流流动，控制器通过计算这4个电流的比例就能算出触摸点的坐标（这个计算过程中涉及到AD转换）。 专用电路计算坐标 (1)电阻式触摸屏本身是一个完全被动器件，里面没有任何IC和电路，它的工作逻辑完全在SoC控制器上；但是电容式触摸屏不同，电容式触摸屏需要自带一个IC进行坐标计算。因此电容式触摸屏工作时不需要主机SoC控制器参与。 (2)为什么这样设计？主要原因是因为电容式触摸屏的坐标计算太复杂，普通程序员无法写出合适的代码解决这个问题，因此在电容式触摸屏中除了触摸板之外还附加了一个IC进行专门的坐标点计算和统计。这个IC全权负责操控触摸板得到触摸操作信息，然后再通过数字接口和主机SoC进行通信。 多个区块支持多点触摸 (1)电阻触摸屏不支持多点触摸，这是它本身的原理所限制，无法改变无法提升。 (2)电容式触摸屏可以支持多点触摸（也可以单点触摸）。按照之前讲的电容式触摸屏的原理，单个电容式触摸屏面板也无法支持多点触摸，但是可以将一个大的触摸面板分成多个小的区块，每个区块相当于是一个独立的小的电容式触摸屏面板。 (3)多个区块支持多点触摸让电容触摸屏坐标计算变复杂了，但是这个复杂性被电容触摸IC吸收了，还是通过数字接口和主机SoC通信报告触摸信息（触摸点数、每个触摸点的坐标等）。 对外提供I2C的访问接口 (1)整个电容触摸屏包含2部分：触摸板和电容触摸IC。触摸板就是一个物理器件，电容触摸IC一般做到触摸屏的软排线（FPC）上面，电容触摸IC负责操控触摸板、通过AD转换和分析得到触摸点个数、触摸坐标等信息，然后以特定的数字接口与SoC通信。这个数字接口就是I2C。 (2)对于我们主机SoC来说，电容式触摸屏其实就是一个I2C从设备。主机只需要通过I2C总线对这个从设备进行访问即可（从设备有自己特定的从设备地址）。从这里来讲，其实电容式触摸屏和其他的传感器（gsensor等）并没有任何区别。 ft5x06电容触摸IC简介 电阻式触摸屏和电容式触摸屏的特点对比 (1)耐久性 电容式触摸屏不容易坏，电阻式触摸屏易坏 (2)抗干扰性 电容式触摸屏差一些，电阻式触摸屏要好一些 (3)精准度 电容式触摸屏差一些，电阻式触摸屏好一些 (4)用户体验 电容式触摸屏要好一些，电阻式触摸屏要差一些 (5)价格 电容式触摸屏贵一些，电阻式触摸屏便宜很多 工业应用中用电阻式触摸屏 (1)消费电子产品（手机、平板电脑）用电容式触摸屏。但是在工业领域都是用电阻式触摸屏，就是因为工业领域环境比较恶劣，电容式触摸屏容易受干扰，所以不合适。 触摸屏的发展方向 (1)更薄、更透明、更精准、支持点数更多。 (2)把电容触摸屏和LCD做在一起。可以做到更薄、更透明、价格更低。但是面临的困难是抗干扰性要求更高。 ft5x06的数据手册浏览(1)软件工程师并不关心触摸屏的工艺问题，只关心软件编程接口（物理层是I2C）。 实验12-shell基本概念 壳与封装 (1)shell就是壳的意思，在计算机中经常提到shell是用户操作接口的意思。 (2)因为计算机程序本身很复杂，里面的实现和外面的调用必须分开。接口本身就是对内部复杂的实现的一种封装，外部只需要通过接口就可以很容易的实现效果，但是却不用理会内部实现的复杂性和原理。 程序或操作系统的用户接口(1)操作系统运行起来后都会给用户提供一个操作界面，这个操作界面就叫shell。用户可以通过shell来调用操作系统内部的复杂实现。 (2)shell编程就是在shell层次上进行编程。譬如linux中的脚本编程、windows中的批处理。 两种shell：GUI和cmdline (1)GUI（图形用户界面），特点是操作简单、易学易用，适合使用电脑来工作的人。 (2)cmdline(命令行界面)，譬如linux的终端和windows的cmd，特点是不易用易学，优点是可以进行方便的shell编程，适合做开发的人。 (3)展望：将来的shell应该是声音图像等接口的。 shell的运行原理：由消息接收、解析、执行构成的死循环 (1)我们主要分析命令行shell的运行原理。 (2)命令行shell其实就是一个死循环。这个死循环包含3个模块，这3个模块是串联的，分别是命令接收、命令解析、命令执行。 (3)命令行有一个标准命令集，用户在操作的时候必须知道自己想要的操作用通过哪个命令来实现，不能随便输入命令。如果用户输入了一个不是标准命令的命令（不能识别的命令），提示用户这不是一个合法命令，然后重新回到命令行让用户输入下一个命令。 (4)用户输入命令的界面是一个命令行，命令行的意思就是用户输入的命令是以行为单位的，更好理解的说用户输入的命令在用户按下回车键之后就算是结束了，shell可以开始接收了。 shell举例：uboot、linux终端、Windows图形界面等 (1)常见的shell，uboot就是一个裸机程序构成的shell（本课程要完成的shell也是裸机的），linux终端和windows的cmd是操作系统下的命令行shell。windows图形界面、ubuntu图形界面、android的图形界面这些都是图形界面的shell，网页类型的shell，典型代表就是路由器。 实验项目shell-01-输入回显 shell实战1-从零写最简单shell 使用printf和scanf做输入回显，定义简单命令集 shell-02-移植 shell实战2-将简易shell移植到开发板中 工程选定、文件复制、Makefile书写 printf和scanf函数（本质是putc和getc函数）的移植 (1)puts和putchar函数比较简单，注意的地方就是windows和linux中的回车键定义的不同。 所以在putchar函数中如果用户要输出’\n’时，实际输出”\r\n” (2)gets和getchar是从Windows中的SecureCRT终端输入字符串到裸机程序中。这里面至少有2个问题：用户输入回显问题、用户按回车键问题、用户按BackSpace退格键问题 (3)自己实现回显 (4)用户按回车键问题，在getchar中解决。方法是碰到’\r’时直接返回’\n’ 编译下载和调试验证 shell-03-标准命令集 shell实战3-定义标准命令集及解析 添加cmd_parser和cmd_exec 实现简单的cmd_parser 实现对应的cmd_exec shell-04-添加命令 shell实战4-添加第一个命令 命令任务分析 (1)第一个命令：led，实现的功能是控制板载LED的亮和灭 (2)命令定义：led on 表示点亮led，led off 熄灭led (3)扩展：led 1 on 表示点亮第一个led。 命令解析 (1)命令解析其实就是把一个类似 led on这种命令解析成led和on两个字符串，放在一个字符串数组中。 shell-05-其他命令 shell实战5-添加其他命令 shell-06-开机倒计时 shell实战6-实现开机倒计时自动执行命令 (1)计时功能。要用计时的部件（定时器）来完成。 (2)主程序 注意：C语言中声明全局变量时不能加初始化，如果加了编译器就会把这个声明当作定义 shell-07-环境变量 shell实战7-初步实现环境变量 环境变量就好象程序的全局变量一样，整个程序中唯一。可以影响程序的执行，环境变量可以支持一些命令来查询环境变量、设置环境变量、保存环境变量（必须借助flash才能完成。本节只在内存中实现环境变量所以无法保存）。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[嵌入式知识]]></title>
    <url>%2Fpassages%2F2020-01-31-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[嵌入式基础知识（概念） 嵌入式系统 特点 组成 内存的访问方式 io的访问方式 冯诺依曼结构与哈佛结构 寄存器 电子器件的发展方向 可编程器件的特点 编程语言 编程及运行过程 交叉编译 指令集 arm arm的内核版本号-soc版本号-芯片型号 寄存器 特殊功能寄存器 通用寄存器 存储器 arm的基本设定 arm处理器工作模式 arm异常 指令-伪指令 指令 伪指令 立即数 协处理器 arm汇编特点 嵌入式系统特点 专用、软硬件可裁剪可配置 低功耗、高可靠性、高稳定性 软件代码短小精悍 代码可固化 实时性 弱交互性 专用开发工具及开发环境 专业开发人员 组成 硬件：微处理器存储器（寄存器、内存、外存）I/O接口、输入输出设备等等 软件：嵌入式操作系统BSP——board support package板级支持包应用软件 内存的访问方式 内存通过CPU的地址总线来寻址定位，然后通过CPU数据总线来读写。 CPU的地址总线的位数是CPU设计时确定的，因此一款CPU所能寻址的范围是一定的，而内存是需要占用CPU的寻址空间的。 内存与CPU的这种总线式连接方式是一种直接连接，优点是效率高访问快，缺点是资源有限，扩展性差。 io的访问方式 IO指的是与CPU连接的各种外设。 CPU访问各种外设有2种方式：一种是类似于访问内存的方式，即把外设的寄存器当作一个内存地址来读写，从而以访问内存相同的方式来操作外设，叫IO与内存统一编址方式；另一种是使用专用的CPU指令来访问某种特定外设，叫IO与内存独立编址。 冯诺依曼结构与哈佛结构 程序和数据都放在内存中，且不彼此分离的结构称为冯诺依曼结构。譬如Intel的CPU均采用冯诺依曼结构。冯诺依曼结构中程序和数据不区分的放在一起，因此安全和稳定性是个问题，好处是处理起来简单。 程序和数据分开独立放在不同的内存块中，彼此完全分离的结构称为哈佛结构。譬如大部分的单片机（MCS51、ARM9等）均采用哈佛结构。哈佛结构中程序（一般放在ROM、flash中）和数据（一般放在RAM中）独立分开存放，因此好处是安全和稳定性高，缺点是软件处理复杂一些（需要统一规划链接地址等） 寄存器 SoC中有2类寄存器：通用寄存器和SFR 1.通用寄存器（ARM中有37个）是CPU的组成部分，CPU的很多活动都需要通用寄存器的支持和参与。2.SFR（special function register，特殊功能寄存器）不在CPU中，而存在于CPU的外设中，我们通过访问外设的SFR来编程操控这个外设，这就是硬件编程控制的方法。 CPU可以像访问内存一样访问寄存器 寄存器是CPU的硬件设计者制定的，目的是留作外设被编程控制的“活动开关” 正如汇编指令集是CPU的编程接口API一样，寄存器是外设硬件的软件编程接口API。使用软件编程控制某一硬件，其实就是编程读写该硬件的寄存器。 寄存器中每个bit位都有特定含义，因此编程操作时需要位操作。 单个寄存器的位宽一般和CPU的位宽一样，以实现最佳访问效率 3.编程访问寄存器的方法 1234567//汇编ldr r1, =0xE0200280str r0, [r1]mov r0, #0//C语言int *p = (int *)0x30008000;*p = 16; 电子器件的发展方向 模拟器件 -&gt; 数字器件 ASIC（专用集成电路） -&gt; 可编程器件 可编程器件的特点 CPU在固定频率的时钟控制下节奏运行。 CPU可以通过总线读取外部存储设备中的二进制指令集，然后解码执行。 这些可以被CPU解码执行的二进制指令集是CPU设计的时候确定的，是CPU的设计者定义的，本质上是一串由1和0组成的数字。这就是CPU的汇编指令集。 编程语言 编程语言发展过程：纯机器码编程汇编语言编程C语言编程C++语言编程Java C#等语言编程脚本语言编程 汇编语言就是CPU的机器指令集的助记符，是一款CPU的本质特征。 不同CPU的机器指令集设计不同，因此汇编程序不能在不同CPU间互相移植。（C语言可移植性高，但是不同cpu需要不同的编译器编译） 使用汇编编程可以充分发挥CPU的设计特点，所以汇编编程效率最高，因此在操作系统内核中效率极其重要处都需要用汇编处理。 编程及运行过程 程序员用汇编指令编程 –&gt;经汇编器汇编成二进制可执行程序文件–&gt;二进制文件被CPU读取进去–&gt;CPU内部电路对二进制文件解码–&gt;解码通过则CPU执行指令、完成指令动作。 如果程序员用C语言等高级语言编程，则编译器先将C语言程序编译为汇编程序，再进行上面的后续部分。 交叉编译 A(类)机编写（源代码）、编译得到可执行程序，发布给B(类)机运行。 嵌入式开发的CPU比较简单，本身无法搭建开发环境，有些甚至操作系统都没有。交叉编译可以用高性能机器为低性能机器开发软件（包括裸机软件、系统级和应用级软件） 必须使用专用的交叉编译工具链（toolschain）。 由于可执行程序不能本地运行调试，因此必须配合一定手段（专用调试器、JTAG调试器、USB下载、串口下载、SD启动、网络共享等）将可执行程序加载到目标嵌入式设备上运行及调试。 指令集 CISC:complex instruction set computer——复杂指令集CPUCISC体系的设计理念是用最少的指令来完成任务（譬如计算乘法只需要一条MUL指令即可，但是越复杂的算法使用的指令就越多，算法越多指令也越多），因此CISC的CPU本身设计复杂、工艺复杂，但好处是编译器好设计。CISC出现较早，至今Intel还一直采用CISC设计。 Reduced Instruction-Set Computer——精简指令集CPURISC的设计理念是让软件来完成具体的任务，CPU本身仅提供基本功能指令集。因此RISC的CPU的指令集中只有很少的指令，这种设计相对于CISC，CPU的设计和工艺简单了，但是编译器的设计变难了。 armarm的内核版本号-soc版本号-芯片型号 概念：SoC = System on Chip（在芯片上做系统）v versionm microcontroller微控制器就是单片机STM32a application应用级处理器就是手机、平板、电脑的CPUr realtime 实时处理器响应速度快，主要用在工业、航天等领域外设：Peripheral实时操作系统：RTOS非实时操作系统：linux windows androidARM内核是一种CPU的内核设计方案（一种方案一种指令集）,以这个设计为核心、在CPU的周围添加其他外围模块,比如串口、IIC、LCD控制器等模块,就成为一个以该ARM内核为核心、加上自己的外围设备组成的一块芯片。ARM内核版本号和SoC版本号是由ARM确定的，而SoC型号是由半导体公司确定的。Cortex系列后ARM产品线分割成3个系列，这个是市场细分的需要和选择。 ARM是RISC架构常用ARM汇编指令只有二三十条ARM是低功耗CPUARM的架构非常适合单片机、嵌入式，尤其是物联网领域；而服务器等高性能领域目前主导还是Intel ARM是统一编址的大部分ARM（M3 M4 M7 M0 ARM9 ARM11 A8 A9等）都是32位架构32位ARM CPU支持的内存少于4G，通过CPU地址总线来访问SoC中的各种内部外设通过各自的SFR编程访问，这些SFR的访问方式类似于访问普通内存，这叫IO与内存统一编址。 ARM是哈佛结构的常见ARM（除ARM7外）都是哈佛结构的哈佛结构保证了ARM CPU运行的稳定性和安全性，因此ARM适用于嵌入式领域哈佛结构也决定了ARM裸机程序（使用实地址即物理地址）的链接比较麻烦，必须使用复杂的链接脚本告知链接器如何组织程序；对于OS之上的应用（工作在虚拟地址之中）则不需考虑这么多 寄存器特殊功能寄存器 SFR：special function register 通用寄存器 General register,ARM共有37个寄存器，都是32位长度,每种模式下最多只能使用18个寄存器。37个寄存器中30个为“通用”型，其余的1个固定用作PC，1个固定用作CPSR，5个固定用作5种异常模式下的SPSR。在ARM中共有6个名叫r13（又叫sp）的寄存器，但是在每种特定处理器模式下，只有一个r13是当前可见的，其他的r13必须切换到他的对应模式下才能看到。这种设计叫影子寄存器（banked register） 存储器 名称 英文全称 说明 备注 ROM read only memory 只读存储器 任何时候都可以读取，但不能直接通过地址总线、数据总线写，要通过专用io接口去写 RAM ramdom access memory 随机访问存储器 可以不按顺序，随机访问 RAM种类 英文全称 说明 备注 DRAM dynamic ram 动态RAM DRAM分为很多种，常见的主要有FPRAM/FastPage、EDORAM、SDRAM、DDR RAM、RDRAM、SGRAM以及WRAM等，适合手机电脑 SRAM static ram 静态RAM 速度最快，最昂贵，所以适合单片机 IRAM internal ram 内部RAM 内部RAM，指的是集成到SoC内部的RAM 补充： 1.动态内存中所谓的”动态”，指的是当我们将数据写入DRAM后，经过一段时间，数据会丢失，因此需要一个额外设电路进行内存刷新操作。 具体的工作过程是这样的：一个DRAM的存储单元存储的是0还是1取决于电容是否有电荷，有电荷代表1，无电荷代表0。但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，这就是数据丢失的原因。 刷新操作定期对电容进行检查，若电量大于满电量的1／2，则认为其代表1，并把电容充满电；若电量小于1／2，则认为其代表0，并把电容放电，藉此来保持数据的连续性。 2.DDR RAM：double data rate ram 双通道的ram （可以在一个时钟读写两次数据，目前电脑内存用得最多） ROM种类 英文全称 说明 备注 SROM static rom 静态ROM 静态只读存储器 IROM internal rom 内部ROM 指的是集成到SoC内部的ROM PROM programmable rom 可编程的ROM 一次性的，软件灌入后无法修改 EPROM erasable programmable rom 可擦除可编程ROM 通过紫外光的照射擦除原先的程序，是一种通用的存储器 EEPROM electrically erasable programmable rom 带电可擦可编程ROM 通过电子擦出，价格很高，写入时间很长，写入很慢 FLASH flash memory 闪存/电子式可擦除可编程只读存储器 主要用于一般性数据存储和在计算机与其他数字产品间交换传输数据，如储存卡与U盘。闪存是一种特殊的、以宏块抹写的EPROM，同时具备快速读取数据的优势 NOR Flash not or flash 单元按照或非的方式连起来 使用随机读取技术，用户可以直接运行装载在NOR FLASH里面的代码，这样可以减少SRAM的容量从而节约了成本 NAND Flash not and flash 单元按照与非的方式连起来 NAND Flash没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的Flash比较廉价 ONENAND nandflash的一种 既实现NOR Flash的高速读取速度，又保留了NAND Flash的大容量数据存储的优点 eMMC embedded multi media card 嵌入式多媒体控制器 采用统一的MMC标准接口，自身集成MMC Controller，存储单元与NANDFLASH相同。 补充： 0、手机软件一般放在EEPROM中；我们打电话，有些最后拨打的号码，暂时是存在SRAM中的，不是马上写入通过记录（通话记录保存在EEPROM中），因为当时有很重要工作（通话）要做，如果写入，漫长的等待是让用户忍无可忍的。 l、NOR的读速度比NAND稍快一些。 2、 NAND的写入速度比NOR快很多。 3、NAND的4ms擦除速度远比NOR的5s快。 4、大多数写入操作需要先进行擦除操作。 5、NAND的擦除单元更小，相应的擦除电路更少。 6、一般小容量的用NOR Flash，因为其读取速度快、价格高，可以与CPU进行总线式相连，多用来存储操作系统等重要信息，而大容量的用NAND FLASH（也因为容量大，进行总线式相连浪费寻址空间），最常见的NAND FLASH应用是嵌入式系统采用的DOC（Disk On Chip）。此外，NAND的实际应用方式要比NOR复杂的多。NOR可以直接使用，并可在上面直接运行代码；而NAND需要I/O接口，因此使用时需要驱动程序（或者用一小块NOR Flash来启动）。不过当今流行的操作系统对NAND结构的Flash都有支持。此外，Linux内核也提供了对NAND结构的Flash的支持。 7、OneNAND器件有两种类型：muxed和demuxed。对于muxed型，地址引脚和数据引脚结合在一起，而demuxed型芯片这两个引脚是分开的。当关注的是减少引脚数时，选择muxed OneNAND可能好一些。 8、eMMC简化手机存储器的设计，更新速度快，加速产品研发速度。iNand和moviNand遵循eMMC标准。 9、NAND Flash的类型有SLC(Single-Level Cell，单层单元，在每个单元中存储一个Bit，这种设计提高了耐久性、准确性和性能，它的价格最高)、MLC(Multi-Level Cell，多层单元，架构可以为每个单元存储2个Bit。尽管在存储单元中存储多个Bit似乎能够很好地利用空间，在相同空间内获得更大容量，但它的代价是使用寿命降低，可靠性降低，MLC SSD使得在PC和笔记本电脑上增加闪存成为可能)、eMLC(Enterprise Multi-Level Cell，企业多级单元，是MLC NAND 闪存的一个“增强型”的版本，它在一定程度上弥补了SLC和MLC之间的性能和耐久差距)和TLC(Triple-Level Cell，三层单元，最便宜，每个单元存储3比特，通常用于性能和耐久性要求相对较低的消费级电子产品) 10、一般PC机都是：很小容量的BIOS（NorFlash）+ 大容量的硬盘（类似于NandFlash）+ 大容量的DRAM 一般的单片机：很小容量的NorFlash + 很小容量的SRAM 嵌入式系统：因为NorFlash很贵，随意现在很多嵌入式系统倾向于不用NorFlash， 直接用：外接的大容量Nand + 外接大容量DRAM + SoC内置SRAM 11、SD和microSD(TF)卡区别:SD卡 比TF卡的尺寸要大;SD卡一般都用在大一些的电子设备,如电脑，相机，AV等器材，而TF一般用在手机上。TF卡插入适配器（adapter）可以转换成SD卡，但SD卡一般无法转换成TF卡。SD卡上有一个（lock）开关，即写保护开关，TF卡没有。 12、硬盘按照访问方式分机械硬盘(HDD:Hard Disk Drive)、固态硬盘(SSD:Solid State Drive，Nand-MLC)、混合硬盘(HH:Dhybrid hard drive);按接口可分为IDE、SATA、PATA、SCSI arm的基本设定 现在ARM一般采用的是32位架构. ARM约定（与vc等可能不同，word为16bits）:byte ：8 bitsHalfword ：16 bits (2 byte)Word :32 bits (4 byte) 大部分ARM core 提供：ARM指令集（32-bit）Thumb指令集（16-bit ）Thumb2指令集（16 &amp; 32bit）Jazelle cores 支持 Java bytecode arm处理器工作模式 ARM 有7个基本工作模式:User : 非特权模式，大部分任务执行在这种模式 FIQ : 当一个高优先级（fast) 中断产生时将会进入这种模式IRQ : 当一个低优先级（normal) 中断产生时将会进入这种模式Supervisor :当复位或软中断指令执行时将会进入这种模式Abort : 当存取异常时将会进入这种模式Undef : 当执行未定义指令时会进入这种模式 System : 使用和User模式相同寄存器集的特权模式 注意：除User（用户模式）是Normal（普通模式）外，其他6种都是Privilege（特权模式）。Privilege中除Sys模式外，其余5种为异常模式。各种模式的切换，可以是程序员通过代码主动切换（通过写CPSR寄存器）；也可以是CPU在某些情况下自动切换。各种模式下权限和可以访问的寄存器不同。 arm异常 正常工作之外的流程都叫异常;异常会打断正在执行的工作，并且一般我们希望异常处理完成后继续回来执行原来的工作;中断是异常的一种。 异常向量表所有的CPU都有异常向量表，这是CPU设计时就设定好的，是硬件决定的；当异常发生时，CPU会自动动作（PC跳转到异常向量处处理异常，有时伴有一些辅助动作）；异常向量表是硬件向软件提供的处理异常的支持。 ARM的异常处理机制当异常产生时：ARM core拷贝 CPSR 到 SPSR_设置适当的 CPSR 位：改变处理器状态进入 ARM 态（以下操作只能在 ARM 态执行）改变处理器模式进入相应的异常模式设置中断禁止位禁止相应中断 (如果需要)保存返回地址到 LR_设置 PC 为相应的异常向量返回时, 异常处理需要:从 SPSR_恢复CPSR从LR_恢复PC以下操作只能在 ARM 态执行. 异常向量表（Vector Table）以下是CPU设计时提供的异常向量表，一般成为一级向量表。有些CPU为了支持多个中断，还会提供二级中断向量表，处理思路类似于这里说的一级中断向量表。 地址 内容 … … 0x1C FIQ 0x18 IRQ 0x14 （Reserved) 0x10 Data Abort 0x0C Prefetch Abort 0x08 Software Interrupt 0x04 Undefined Instruction 0x00 Reset 指令-伪指令 （汇编）指令是CPU机器指令的助记符，经过编译后会得到一串10组成的机器码，可以由CPU读取执行。（汇编）伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码。 指令 两种不同风格的ARM指令ARM官方的ARM汇编风格：指令一般用大写、Windows中IDE开发环境（如ADS、MDK等）常用。如： LDR R0, [R1]GNU风格的ARM汇编：指令一般用小写字母、linux中常用。如：ldr r0, [r1] 常用ARM指令1：数据处理指令数据传输指令 mov mvn算术指令 add sub rsb adc sbc rsc逻辑指令 and orr eor bic比较指令 cmp cmn tst teq乘法指令 mvl mla umull umlal smull smlal前导零计数 clz 常用ARM指令2：cpsr访问指令mrs &amp; msrmrs用来读psr，msr用来写psrCPSR寄存器比较特殊，需要专门的指令访问，这就是mrs和msr。 常用ARM指令3：跳转(分支)指令b &amp; bl &amp; bxb 直接跳转（就没打开算返回）bl branch and link，跳转前把返回地址放入lr中，以便返回，以便用于函数调用bx跳转同时切换到ARM模式，一般用于异常处理的跳转。 常用ARM指令4：访存指令ldr/str &amp; ldm/stm &amp; swp单个字/半字/字节访问 ldr/str多字批量访问 ldm(load register mutiple)/stm（store register mutiple）swp r1, r2, [r0]swp r1, r1, [r0] 1234567891011121314151617//8种后缀ia（increment after） @先传输，再地址+4ib（increment before） @先地ascending传输da（decrement after） @先传输，再地址-4db（decrement before） @先地址-4，再传输fd（full descending） @满递减堆栈ed（empty descending） @空递减堆栈fa（full ascending） @满递增堆栈ea（empty ascending） @空递增堆栈@感叹号的作用就是r0的值在ldm过程中发生的增加或者减少最后写回到r0去，也就是说ldm时会改变r0的值。ldmia r0, &#123;r2 - r3&#125;ldmia r0！, &#123;r2 - r3&#125;@^的作用：在目标寄存器中有pc时，会同时将spsr写入到cpsr，一般用于从异常模式返回。ldmfd sp!, &#123;r0 - r6, pc&#125;ldmfd sp!, &#123;r0 - r6, pc&#125;^ 常用ARM指令5：软中断指令swi（software interrupt）软中断指令用来实现操作系统中系统调用 arm指令 协处理器cp15操作指令mcr &amp; mrcmrc用于读取CP15中的寄存器mcr用于写入CP15中的寄存器1234567891011@opcode_1：对于cp15永远为0@Rd：ARM的普通寄存器@Crn：cp15的寄存器，合法值是c0～c15@Crm：cp15的寄存器，一般均设为c0@opcode_2：一般省略或为0mcr&#123;&lt;cond&gt;&#125; p15, &lt;opcode_1&gt;, &lt;Rd&gt;, &lt;Crn&gt;, &lt;Crm&gt;, &#123;&lt;opcode_2&gt;&#125;@例子，其他见uboot源码start.S中相关代码mrc p15, 0, r0, c1, c0, 0orr r0, r0, #1mcr p15, 0, r0, c1, c0, 0 伪指令 伪指令的意义伪指令不是指令，伪指令和指令的根本区别是经过编译后会不会生成机器码。伪指令的意义在于指导编译过程。伪指令是和具体的编译器相关的，我们使用gnu工具链，因此学习gnu环境下的汇编伪指令。 gnu汇编中的一些符号@用来做注释。可以在行首也可以在代码后面同一行直接跟，和C语言中//类似#做注释，一般放在行首，表示这一行都是注释而不是代码。：以冒号结尾的是标号. 点号在gnu汇编中表示当前指令的地址#立即数前面要加#或$，表示这是个立即数 常用gnu伪指令 1234567.global _start @ 给_start外部链接属性.section .text @ 指定当前段为代码段.ascii .byte .short .long .word .quad .float .string @ 定义数据.align 4 @ 以16字节对齐.balignl 16 0xabcdefgh @ 16字节对齐填充.equ @ 类似于C中宏定义 如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。 偶尔会用到的gnu伪指令 1234.end @标识文件结束.include @ 头文件包含.arm / .code32 @声明以下为arm指令.thumb / .code16 @声明以下为thubm指令 最重要的几个伪指令ldr 大范围的地址加载指令adr 小范围的地址加载指令adrl 中等范围的地址加载指令nop 空操作ARM中有一个ldr指令，还有一个ldr伪指令,一般都使用ldr伪指令而不用ldr指令。adr编译时会被1条sub或add指令替代，而ldr编译时会被一条mov指令替代或者文字池方式处理。adr总是以PC为基准来表示地址，因此指令本身和运行地址有关，可以用来检测程序当前的运行地址在哪里。ldr加载的地址和链接时给定的地址有关，由链接脚本决定。 123ldr r0, #0xff @ldr指令ldr r0, =0xfffl @伪指令,涉及到合法/非法立即数，涉及到ARM文字池@adr和ldr的差别：ldr加载的地址在链接时确定，而adr加载的地址在运行时确定；所以我们可以通过adr和ldr加载的地址比较来判断当前程序是否在链接时指定的地址运行。 立即数 立即数有合法立即数与非法立即数，ARM指令都是32位，除了指令标记和操作标记外，本身只能附带很少位数的立即数。因此立即数有合法和非法之分。合法立即数：经过任意位数的移位后非零部分可以用8位表示的即为合法立即数 协处理器 SoC内部另一处理核心，协助主CPU实现某些功能，被主CPU调用执行一定任务。ARM设计上支持多达16个协处理器，但是一般SoC只实现其中的CP15.（cp：coprocessor）协处理器和MMU、cache、TLB等处理有关，功能上和操作系统的虚拟地址映射、cache管理等有关。 arm汇编特点 ARM汇编特点1：LDR/STR架构ARM采用RISC架构，CPU本身不能直接读取内存，而需要先将内存中内容加载入CPU中通用寄存器中才能被CPU处理。ldr（load register）指令将内存内容加载入通用寄存器。str（store register）指令将寄存器内容存入内存空间中。ldr/str组合用来实现 ARM CPU和内存数据交换 ARM汇编特点2：8种寻址方式寄存器寻址 mov r1, r2立即寻址 mov r0, #0xFF00寄存器移位寻址 mov r0, r1, lsl #3寄存器间接寻址 ldr r1, [r2]基址变址寻址 ldr r1, [r2, #4]多寄存器寻址 ldmia r1!, {r2-r7, r12}堆栈寻址 stmfd sp!, {r2-r7, lr}相对寻址 beq flagflag: ARM汇编特点3：指令后缀同一指令经常附带不同后缀，变成不同的指令。经常使用的后缀有：B（byte）功能不变，操作长度变为8位H（half word）功能不变，长度变为16位S（signed）功能不变，操作数变为有符号如 ldr ldrb ldrh ldrsb ldrshS（S标志）功能不变，影响CPSR标志位如 mov和movs movs r0, #0 ARM汇编特点4：条件执行后缀 123mov r0, r1//相当于C语言中的r0 = r1;moveq r0, r1//如果eq后缀成立，则直接执行mov r0, r1；如果eq不成立则本句代码直接作废，相当于没有//类似于C语言中 if (eq)&#123;r0 = r1;&#125; 条件后缀执行注意2点：1、条件后缀是否成立，不是取决于本句代码，而是取决于这句代码之前的代码运行后的结果。2、条件后缀决定了本句代码是否被执行，而不会影响上一句和下一句代码是否被执行。 GT greater thanLT less than ARM汇编特点5：多级指令流水线]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c语言知识2]]></title>
    <url>%2Fpassages%2F2020-01-26-c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%862%2F</url>
    <content type="text"><![CDATA[C语言基础知识2 常量 #define定义的常量 const关键字 变量 局部变量 普通局部变量(auto) 静态局部变量(static) reqister变量 全局变量 普通全局变量 静态全局变量 局部变量和全局变量的对比： 基本概念： 多文件C语言项目 头文件的引入 常量常量，程序运行过程中不会改变的量。常量的值在程序运行之前初始化的时候给定义一次，以后不会变。 #define定义的常量12#define N20//符号常量int a[N]； const关键字123456const inti=14;//const和指针结合，共有4种形式const int *p; //p是一个指钍，指钍指向一个int型数据。p所指向的是个常量。int sonat*p; //p是一个指钍，指钍指向一个int型数据。p所指向的是个常量。int *const p; //p是一个指钍，指钍指向一个int型数据。p本身是常量，p所指向的是个变量const int *const p; //p是一个指钍，指钍指向一个int型数据。p本身是常量，指向的也是常量 结论和记忆方法： const在*前面，就表示const作用于p所指向的量。所以这时候p所指向的是个常量。 const在*后面，表示p本身是常量，但是p指向的不一定是常量。Ichar *strspy(char *dst,const char *src); 变量变量，指的是在程序运行过程中，可以通过代码使它的值改变。 局部变量 定义在函数中的变量，就叫局部变量。 普通局部变量(auto) 普通的局部变量定义时直接定义，或者在定义前加auto关键字，auto关键字可省略。 静态局部变量(static) 静态局部变量定义时前面加static关键字. 静态局部变量和普通局部变量不同。静态局部变量也是定义在函数内部的，静态局部变量定义时前面要加static关键字来标识，静态局部变量所在的函数在多调用多次时，只有第一次才经历变量定义和初始化，以后多次在调用时不再定义和初始化，而是维持之前上一次调用时执行后的变量的值。本次接着来使用。 静态局部变量在第一次函数被调用时创造并初始化，但在函数退出时它不死亡，而是保持其值等待函数下一次被调用。下次调用时不再重新创造和初始化该变量，而是直接用上一次留下的值为基础来进行操作。 静态局部变量的这种特性，和全局变量非常类似。它们的相同点是都创造和初始化一次，以后调用时值保持上次的不变。 reqister变量 register(寄存器），C语言的一个关键字:register inti=3; register类型的局部变量表现上和auto是一样的，基本没用。c语言的运行时环境承诺，会尽量将register类型的变量放到寄存器中去运行（普通的变量是在内存中），所以register类型的变量访问速度会快很多。但是有限制的：首先寄存器数目是有限的，所以register类型的变量不能太多；其次register类型变量在数据类型上有限制，譬如你就不能定义double类型的register变量。一般只在内核或者启动代码中，需要反复使用同一个变量这种情况下才会使用register类型变量。 全局变量定义在函数处面的变量，就叫全局变量。 普通全局变量 普通全局变量定义前不加任何修饰词。普通全局变量可以在各个文件中使用，可以在项且内别的.c文件中被看到，所以要确保不能重名。 静态全局变量 静态全局变量就是用来解决重名问题的。静态全局变量定义时在定义前加static关键字，告诉编译器这个变量只在当前本文件内使用，在别的文件中绝对不会使用。这样就不用担心重名问题。 局部变量和全局变量的对比： 定义同时没有初始化，则局部变量的值是随机的，而全局变量的值是默认为0。 使用范围上：全局变量具有文件作用域，而局部变量只有代码块作用域。 生命周期上：全局变量是在程序开始运行之前的初始化阶段就诞生，到整个程序结束退出的。时候才死亡；而局部变量在进入局部变量所在的代码块时诞生，在该代码块退出的时候死亡（{}内，比如while(1){int a = 1;}a在外面是随机值）。 变量分配位置：全局变量分配在数据段上，而局部变量分配在栈上。从局部变量声明的时候，它就在堆栈空间了，而不是调用函数的时候，才让它入栈的。调用函数的时候是参数进栈。 基本概念： 作用域：起作用的区域，也就是可以工作的范围。 代码块：所谓代码块，就是用{}括起来的一段代码。 数据段：数据段存的是数，像全局变量就是存在数据段的 代码段（代码区）：存放函数体的二进制代码，一般是只读的。 全局区（静态区）（static）全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。 栈（stack）：先进后出。c语言中局部变量就分配在栈中，在函数中一个局部变量，就会由系统自动分配在栈中。在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆：是一种结构，从全局区分配一段区间，然后由一种内存分配算法进行管理。文字常量：常量字符串就是放在这里的。程序结束后由系统释放。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;int main()&#123; //定义变量的时候必须是在&#123;开始的位置 ---------栈区变量 int a; int b; //a ,b都是局部变量 在栈区//看到不是变量的时候开始分配空间 printf("%p\n",&amp;a); printf("%p\n",&amp;b); system("pause"); return 0;&#125;//结果分析：先定义的先入栈（在栈内不分配空间），因此a在栈底 b在栈顶。出栈的时候地址先分配给b,后分配给a，因而a的地址比b的大------------------------------------------------------------------int main()&#123; int a; int b; //a ,b都是局部变量 在栈区 printf("%p\n",&amp;a); printf("%p\n",&amp;b); &#123; int c;//变量定义的时候必须在大括号 &#123;开始的位置 printf("%p\n",&amp;c); &#125; system("pause"); return 0;&#125;------------------------------------------------------------------ int main() &#123; int a=20; int *p=&amp;a; printf("%d\n",a); //20的十进制 printf("%o\n",a); //20的八进制 printf("%x\n",a); //20的十六进制 printf("%p\n",a); //20的十六进制 printf("%d\n",p); //变量p里面存放a的地址，输出结果是十进制 printf("%d\n",&amp;a); //&amp;a里面存放a的地址，输出结果是十进制 printf("%p\n",p); //变量p里面存放a的地址，输出结果是十六进制 system("pause"); return 0; &#125;//在%后面加#会提示进制，如果是八进制，在输出结果前面加0，如果是十进制，不加任何字符，如果是十六进制，会加上0x 多文件C语言项目 简单的c语言程序（项目）只有一个c文件（a.c），编译的时候gcc a.c -o a,执行./a 复杂的c语言程序（项目）是由多个c文件构成的。譬如一个项目中包含2个c文件（a.c,b.c），编译的时候gsc a.c b.c-o ab，执行的时候./ab。跨文件调用函数，在调用函数前，要先声明该被调用函数的原型。 实验：在a.c和2.c中分别定义main函数，各自单独编译时没问题：但是两个文件作为一个项目来编译gsc a.c b.c-o ab的时候，就会报错。multiple definition of main’.因为a.s和b.c这时候组成了一个程序，而一个程序必须有且只能有一个main函数。 跨文件的变量引用全局变量间接使用方式：在a.c中写一个函数，然后函数fa();中使用a.c中定义的全局变量ga，然后在b.c中先声明函数fa();，再使用函数fa();,即可在b.c中使用ga。全局变量直接使用方法：想在b.c中直接引用a.c中定义的全局变量ga，则必须在b.c中引用前先声明ga：extern int g_a；局部变量（不管是普通还是静态局部变量）不能跨文件使用，因为局部变量属于代码块作用域。 头文件的引入 #include包含头文件时，用&lt;&gt;和””的区别&lt;&gt;用来包含系统自带的头文件，系统自带，是编译器或者库函数或者操作系统提供的头文件。“”用来包含项目目录中的头文件，程序员写的。（.h文件） 防止重复包含头文件 1234#ifndef AH#define A H//c语言头文件中的声明#endif 写程序时，最好不要在头文件中定义和初始化变量。因为这时该头文件被多个源文件包含时，就会出现重复定义问题。全局变量的定义就应该放在某个源文件（.c文件）中，然后在别的源文件中使用前extern声明。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo博客文章常用写法]]></title>
    <url>%2Fpassages%2F2020-01-17-hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写作介绍 字体介绍 分级标题 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 3超链接 4列表 无序列表： 有序列表： 5插入图片 绝对路径本地引用 相对路径本地引用 文章封面图片 HTML语法引用 6表格 7引用块 8代码 9字体格式 10本文章的代码 写作介绍字体介绍这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线水平分割线1 水平分割线2 分级标题一级标题二级标题三级标题四级标题五级标题六级标题3超链接写法： 行内形式：我的博客参考形式：[我的博客]https://xuefeng0324.github.io/自动链接：我的博客地址https://xuefeng0324.github.io/ 4列表无序列表：写法： 无序列表项1 无序列表项2 无序列表项3 有序列表：写法：1.有序列表项12.有序列表项23.有序列表项3 5插入图片绝对路径本地引用当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。 相对路径本地引用图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过站点配置文件_config.yml来生成。post_asset_folder: true 将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name 在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。 文章封面图片在文章最开始加入(此为本主题的功能，其他主题不一定有)：cover: &quot;/images/0.jpg&quot; # 文章封面图片URL HTML语法引用 6表格 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 7引用块 你写的内容都在里面。 8代码普通代码 1代码块 语言名 关键字 Bash bash CoffeeScript coffeescript C++ cpp C# cs CSS css Diff diff HTTP http Ini ini Java java JavaScript javascript JSON json Makefile makefile Markdown markdown Objective-C objectivec Perl perl Python python Ruby ruby SQL sql XML xml ARM汇编 armasm AVR汇编 avrasm MIPS汇编 mipsasm x86汇编 x86asm Elixir elixir Elm elm Erlang erlang F# fsharp Haskell haskell GLSL glsl Clojure clojure Lisp lisp 9字体格式我是黑体字我是微软雅黑我是华文彩云我是红色我是绿色我是蓝色我是尺寸我是黑体，绿色，尺寸为5 背景色yellow 参考链接 10本文章的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144---title: hexo博客文章常用写法date: 2020-01-17 14:55:51categories: Hexo博客cover: "/images/0.jpg" # 文章封面图片URL---&lt;!-- more --&gt;&lt;!-- toc --&gt;# 写作介绍## 字体介绍*这是斜体* 或 _这也是斜体_**这是粗体*****这是加粗斜体***~~这是删除线~~水平分割线1---水平分割线2***## 分级标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题## 3超链接写法：行内形式：[我的博客](https://xuefeng0324.github.io/)参考形式：[我的博客]https://xuefeng0324.github.io/自动链接：我的博客地址&lt;https://xuefeng0324.github.io/&gt;## 4列表#### 无序列表：写法：* 无序列表项1+ 无序列表项2- 无序列表项3#### 有序列表：写法：1.有序列表项12.有序列表项23.有序列表项3## 5插入图片#### 绝对路径本地引用当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。![](/images/0.jpg)#### 相对路径本地引用图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过站点配置文件_config.yml来生成。`post_asset_folder: true`将_config.yml文件中的配置项post_asset_folder设为true后，执行命令`$ hexo new post_name`在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。#### 文章封面图片在文章最开始加入(此为本主题的功能，其他主题不一定有)：`cover: "/images/0.jpg" # 文章封面图片URL`#### HTML语法引用&#123;% img http://www.viemu.com/vi-vim-cheat-sheet.gif 200 200 "点击查看大图:vi/vim-cheat-sheet" %&#125;&lt;img src="/images/0.jpg" width="50%" height="50%" title="封面图片" alt="封面图片"/&gt;## 6表格| 表头1|表头2|表头3|表头4|-| :- | :-: | -: ||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐|## 7引用块&gt;你写的内容都在里面。## 8代码`普通代码`*```*代码块(去掉星号)*```*|语言名 |关键字|| :-: | :-: ||Bash |bash||CoffeeScript|coffeescript||C++ |cpp||C# |cs||CSS |css||Diff |diff||HTTP |http||Ini |ini||Java |java||JavaScript |javascript||JSON |json||Makefile |makefile||Markdown |markdown||Objective-C|objectivec||Perl |perl||Python |python||Ruby |ruby||SQL |sql||XML |xml||ARM汇编 |armasm||AVR汇编 |avrasm||MIPS汇编 |mipsasm||x86汇编 |x86asm||Elixir |elixir||Elm |elm||Erlang |erlang||F# |fsharp||Haskell |haskell||GLSL |glsl||Clojure |clojure||Lisp |lisp|## 9字体格式&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=red&gt;我是红色&lt;/font&gt;&lt;font color=#008000&gt;我是绿色&lt;/font&gt;&lt;font color=Blue&gt;我是蓝色&lt;/font&gt;&lt;font size=5&gt;我是尺寸&lt;/font&gt;&lt;font face="黑体" color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;背景色yellow&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;[参考链接](https://blog.csdn.net/heimu24/article/details/81189700)]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c语言知识]]></title>
    <url>%2Fpassages%2F2020-01-11-c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[C语言基础知识 main() 命名原则 寻址 基本数据类型 整型 浮点型 字符型 有符号数和无符号数 构造数据类型 数组 结构体 共用体 枚举类型 空类型（关键字void) 指针类型 函数 宏定义 接续符 main() main()括号内的固定写法main(int argc,char *argv[ ])argc为参数个数，argument count，是整数argv为参数指针，argument vector，argv为指针的指针（可理解为：char **argv or: char *argv[] or: char argv[][]argv是一个指针数组他的元素个数是argc，存放的是指向每一个参数的指针） 下面给出一个例子来理解这两个参数的用法： ①假设程序的名称为prog，当只输入prog，则由操作系统传来的参数为(传给main函数)：argc=1,表示只有一程序名称。argc只有一个元素，即argv[0]指向输入的程序路径及名称：./prog。 ②当输入prog para_1，有一个参数，则由操作系统传来的参数为：argc=2，表示除了程序名外还有一个参数。 即argv[0]指向输入的程序路径及名称，argv[1]指向参数para_1字符串。 ③当输入prog para_1 para_2 有2个参数，则由操作系统传来的参数为：argc=3，表示除了程序名外还有2个参数。即argv[0]指向输入的程序路径及名称，argv[1]指向参数para_1字符串，argv[2]指向参数para_2字符串。 命名原则 C语言常用命名法：驼峰命名法linux常用命名法：单词之间加_ C语言语法与Linux命令都是区分大小写的，不过Linux虚拟机的共享文件夹中，Linux命令对于文件名不区分，例如rm DOC与rm doc的效果是一样的。POSIX 兼容文件系统是区分大小写的。也就是说Linux 是区分大小写的。而且也就是说其实NTFS也是区分大小写的。 不过Windows系统不兼容POSIX，所以Windows不区分大小写。结果就是Windows去读写NTFS分区大小写问题Windows会转换。 POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准。POSIX标准意在期望获得源代码级别的软件可移植性。换句话说，为一个POSIX兼容的操作系统编写的程序，应该可以在任何其它的POSIX操作系统（即使是来自另一个厂商）上编译执行。 寻址 CPU最大能查找多大范围的地址叫做寻址能力，CPU的寻址能力以字节为单位,一般32位操作系统就分配4个字节来记录一个地址（32根地址总线），4x8也就是32位。32位寻址的CPU可以寻址2的32次方大小的地址也就是4G（00000000-FFFFFFFF）。事实上CPU寻址能力因每种CPU设计不同而不同，可以用间接寻址获得无限的内存访问（不考虑速度），硬件和操作系统也支持一种36位地址扩展的方法，也叫pae，可以实现最大64GB的内存支持。地址总线的位数决定CPU寻址范围，数据总线的位数决定CPU单次通信能交换的信息数量，32位的CPU和32位的操作系统都是指数据总线为32位。 2^3bit = 1Bype2^10Bype = 1KB2^10KB = 1MB2^10MB = 1GB例：32根地址总线——2^(30+2)——可以寻址4GB内存 总线可以按照CPU内外来分类： 内部总线：在CPU内部，寄存器之间和算术逻辑部件ALU与控制部件之间传输数据所用的总线称为片内部总线。 外部总线：通常所说的总线指片外部总线，是CPU与内存RAM、ROM和输入/输出设备接口之间进行通讯的通路,也称系统总线。 按照计算机所传输的信息种类，计算机的总线可以划分为 数据总线： 数据总线DB是双向三态形式的总线，即它既可以把CPU的数据传送到存储器或输入输出接口等其它部件，也可以将其它部件的数据传送到CPU。数据总线的位数是微型计算机的一个重要指标，通常与cpu微处理的字长（命令）相一致。我们说的32位，64位计算机指的就是数据总线。 地址总线： 地址总线AB是专门用来传送地址的，由于地址只能从CPU传向外部存储器或I/O端口，所以地址总线总是单向三态的，这与数据总线不同。地址总线的位数决定了CPU可直接寻址的内存空间大小。一根地址总线可以控制一个晶体管是否通电，相当于控制一位二进制数，32根就可以控制32个晶体管的通电情况来代表32位二进制数的范围（00000000-FFFFFFFF） 控制总线：控制总线主要用来传送控制信号和时序信号。控制总线的传送方向由具体控制信号而定，一般是双向的，控制总线的位数要根据系统的实际控制需要而定。其实数据总线和控制总线可以共用。 从上述可知，外部总线包括数据总线、地址总线、控制总线。内部总线：在CPU内部，寄存器之间和算术逻辑部件ALU与控制部件之间传输数据所用的总线（的位宽），即本文里说的 min{ALU位宽、通用寄存器位宽｝。而CPU的位宽一般是以 min{ALU位宽、通用寄存器位宽、数据总线位宽}决定的！也就是说CPU由ALU、通用寄存器、数据总线三者之中最少的位宽决定！内部总线和数据总线在一条线上，和地址总线不在一条线上。 参考视频1参考视频2 基本数据类型 整型 C语言中的整型对应数学中的整数，整型变量是用来描述一个整数值的，整形变量经过计算后也只能是整数（整型），不可能出现小数（浮点型），打印变量用%d。 c语言中整型有三种： 关键字 名称 在流行32位编译器的大小(B) int 整型 4 short int（short） 短整型 2 long int（long） 长整型 4或8 C语言并没有硬性规定整型的大小，不同位数的和不同C语言编译器可能不同，但是要遵守以下规则：short&lt;=int&lt;=long。short 至少占用2个字节，int 建议为一个机器字长。(32位环境下机器字长为4字节，64位环境下机器字长为8字节。)在Windows下长整型和整型没有区别，都是4字节，在其他平台，如Linux或Mac下才是8字节。 浮点型 C语言中浮点型对应数学中的小数。浮点型有float和double两种(32位C语言编译器中这两个变量大小一般分别为4字节和8字节)。使用方式相同，不同在于表示范围和精度。float表示的范围小，精度低（小数点后6位）；而double表示范围大，精度高（小数点后16位）。范围是说表示的数有多大，精度是指这个数的分辨率有多细。打印变量用%x.xf。 不带小数：%3.0f表明待打印的浮点数至少占3个字符宽，且不带小数点和小数部分，整数部分至少占3个位宽。带小数：%6.2f表明待打印的数至少占6个字符宽度（包括两位小数和一个小数点），且小数点后面有2位小数，小数点占一位，所以整数部分至少占3位。 字符型 字符型对应ASCII字符。ASCII字符是一种编码，就是用数字编码来表示一个符号的一种方法本质上说，字符型其实也是整形，只是这些整形数被用来表示一些字符的ASCII编码值，所以叫做字符型，打印变量用%c(我尝试过定义整型变量，然后里面存放97，使用%c将其打印，结果是a，两者本质区别只是大小而已)。字符型一般用8位二进制(也就是一个字节)表示，无符号字符型范围是0～255.字符型其实是一种比short还短的整形，并且可以和int相运算(32位C语言编译器字符变量大小一般为1字节)。 有符号数和无符号数 数学中数是有符号的，有整数和负数之分。所以计算机中的数据类型也有符号，分为有符号数和无符号数。 有符号数：整型：signed int（简写为int）signed long，也写作signed long int，（简写为1ong）signed short,也写作signed short int（简写为short)signed（表示signed int）浮点型：signed float(简写为float）signed double(简写为double)字符型：signed char（简写为char) 无符号数：整型：整形有无符号数，用来表示一些编码编号之类的东西。譬如身份证号，房间号unsigned int(没有简写）Iunsigned long int(简写unsigned 1ong)unsigned short int(简写为unsigned short）浮点数：没有无符号浮点数。也就是说，小数一般只用在数学概念中，都是有符号的。字符型：字符型有无符号数unsigned char（没有简写）注意：对于整型和字符型来说，有符号数和无符号数表示的范围是不同的。譬如字符型，有符号数范围是-128~127，无符号数的范围是0～255 构造数据类型数组 数组就是同一种类型的变量放进了一个组里面。数组定义的时候作为整体定义，使用时拆开为各个元素。 定义：数组中元素类型数组名[数组元素个数]； 初始化：基本数据类型关键字 数组中元素类型数组名[数组元素个数]=｛,,,…｝;无初始化的数组里面的元素是随机数，不完全初始化的数组中未初始化的元素编译器自动赋值为0。定义数组同时初始化，则可以省略数组定义时[]中的长度。C语言编译器会自动推论其长度，推论依据是初始化式中初始化元素的个数。由此可知，省略[]中数组元素个数只有一种情况，那就是后面的初始化式必须为完全初始化。 初始化 示例 无初始化 int a[3]; 完全初始化 int a[3]={1,2,3};int a[]={1,2,3}; 不完全初始化 int a[3]={};int a[3] = {1};gcc支持int a[10]={1, 2, 3, [5] = 6, [9] = 10}; 字符数组及它的两种初始化12345//字符0的十进制数为48，字符A的十进制数为65，字符a的十进制数为97。char a[5]=&#123;'a','b','c','d','e'&#125;;//定义并初始化一个字数组char a[5]=&#123;97,98,99,100,101&#125;;//与上面效果一样char a[]=&#123;97,98,99,100,101&#125;;//与上面效果一样char a[]="abcde";//字符串方式来初始化字数 基础知识：1、在C语言中引用一个单个字符时，应该用单引号括起来。2、在c语言中引用一个字符串时，应该用””括起来，譬如”abcde”，”abcde”实际上有6个字符，分别是’a’’b’’c’’d’’e’’\0’,\0是ASCII码表中的第一个字符，它的编码值是0，对应的字符是空字符（不可见字符，在屏幕上看不见，没法显示，一般要用转义字符方式来显示。譬如’\n’表示回车符，’\t’表示Tab，’\0’代表空字符） 结构体 结构体是一个集合，集合中包含很多个元素，这些元素的数据类型可以相同，也可以不相同。所以结构体是一种数据封装的方法。结构体存在的意义就在于，把很多数据类型不相同的变量封装在一起，组成一个太的新的数据类型。 使用结构体的步骤： 第一步：声明结构体类型。结构体类型的声明是在函数前面（函数最前面==全局）的，就好比int类型，定义出来的MyStruct就相当于是一个数据类型。struct MyStruct{int a;char b;};结构体类型的声明的写法就像是定义函数，并且使用也有所不同，函数的定义可以放在调用处的后面，只需在前面声明一下即可。但是结构体类型的声明必须放在使用结构体类型定义结构体变量的前面。第二步：使用第一步定义的类型来定义结构体变量。可以定义全局变量和局部变量。结构体变量的定义的写法和普通类型的定义差不多，但是前面必须加上struct关键字。 12struct MyStruct&#123;int a;char b;&#125;s1,s2,s3;//在所有函数前面，定义全局变量,struct MyStruct s1;//在某个函数内，定义局部变量 第三步：使用变量。通常所说的结构体变量，实际上使用的是结构体变量中封装的各个子元素，而不是结构体变量本身。结构体变量不能相加、不能相减，也不能相互乘除，但结构体变量可以相互赋值，但前提是这两个结构体变量的结构体类型必须相同。不能将一个结构体变量作为一个整体进行引用，只能分别单独引用它内部的成员，引用方式为：结构体变量名.成员名例如s1.a。“.”是“成员运算符”，它在所有运算符中优先级最高，如果结构体类型中的成员也是一个结构体类型，则要用若干个“.”，一级一级地找到最低一级的成员。 12345678910111213141516171819202122232425struct Age&#123; int year; int month; int day;&#125;;//出生年月日struct Student&#123; char name[20]; int num; struct Age birthday; float score;&#125;;//学生信息int main(int argc, char const *argv[])&#123; struct Student s1; s1.name = "pxf"; s1.num = 20170310441； s1.birthday.year = 1998; s1.birthday.month = 3; s1.birthday.day = 24; s1.score = 100; struct Student s2 = &#123;"小明", 1207041, &#123;1989, 3, 29&#125;, 100&#125;; return 0;&#125; 结构体变量的引用方式决定了：“结构体变量名”可以与“结构体类型名”同名。“结构体变量名”可以与“结构体成员名”同名。“两个结构体类型定义的结构体变量中的成员可以同名”。就比如定义了一个结构体类型用于存放学生的信息，里面有成员“char name[20]；”，那么如果又定义了一个结构体类型用于存放老师的信息，那么里面也可以有成员“char name[20]；”。 12345678struct 结构体类型名 结构体变量名&#123; 数据类型名 结构体成员名;&#125;;struct S&#123; int S;&#125;S; 结构体的初始化 作为全局变量初始化 1234567struct MyStruct&#123; int a; char c; float f; double d;&#125;s1 = &#123;100,'d',12.445,111.111111111111&#125;,s2 = &#123;100,'d',12.445,111.111111111111&#125;; 结构体变量和普通变量一样，作为局部变量初始化时，如果定义的时候无初始化也无显式赋值，则结构体变量中的子元素的值是随机的。正确示例 123456789101112131415struct MyStruct s = &#123;100,'d',12.445,111.111111111111&#125;;//ok，完全初始化struct MyStruct s =&#123; s.a=1444， s.c='k' s.f=3.13， s.d=32.222222，&#125;;//只能从前到后依次初始化，中间不能空，但是不报错，容易出错struct MyStruct s =&#123; //.a=1444， .c='k'， .f=3.13， .d=32.222222，&#125;;//可以，并且可以不按顺序赋值,实现部分初始化 错误示例 12345678910111213141516171819202122struct MyStruct s =&#123;100;'d';12.445;111.111111111111&#125;;//不行struct MyStruct s =&#123;s.a=1444； S.c='k'; S.f=3.13； s.d=32.222222；&#125;;//赋值规则和数组类似，不能用分号struct MyStruct s =&#123; a=1444， c='k'， f=3.13， d=32.222222，）；//错误，.是不能省略的struct MyStruct s =&#123; .=1444， .='k'， .=3.13， .=32.222222，&#125;；//不行，.后面的元素名不可省略。 共用体 共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值,修改一个成员会影响其余所有成员。共用体提供了一种使用相同的内存位置的有效方式,占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。和结构体类似，共用体的使用也是分为声明、定义、初始化和使用共用体成员变量（具体参考结构体）。 共用体的使用 经常使用到的一个实例是： 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。结合结构体和共用体能简化代码和节省空间。一般是结构体里面放共用体，如果是共用体里面放结构体的话，一次性需要多个变量的话，就要在每个结构体里面定义多个结构体成员。 1234567891011121314151617181920212223242526272829303132333435#define TOTAL 4 //人员总数struct&#123; char name[20]; int num; char sex; char profession; union&#123; float score; char course[20]; &#125; sc;&#125; bodys[TOTAL];int main()&#123; int i; //输入人员信息 for(i=0; i&lt;TOTAL; i++)&#123; printf("Input info: "); scanf("%s %d %c %c", bodys[i].name, &amp;(bodys[i].num), &amp;(bodys[i].sex), &amp;(bodys[i].profession)); if(bodys[i].profession == 's')&#123; //如果是学生 scanf("%f", &amp;bodys[i].sc.score); &#125;else&#123; //如果是老师 scanf("%s", bodys[i].sc.course); &#125; fflush(stdin); &#125; //输出人员信息 printf("\nName\t\tNum\tSex\tProfession\tScore / Course\n"); for(i=0; i&lt;TOTAL; i++)&#123; if(bodys[i].profession == 's')&#123; //如果是学生 printf("%s\t%d\t%c\t%c\t\t%f\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score); &#125;else&#123; //如果是老师 printf("%s\t%d\t%c\t%c\t\t%s\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course); &#125; &#125; return 0;&#125; 枚举类型 #define命令虽然能解决问题，但也带来了不小的副作用，导致宏名过多，代码松散，看起来总有点不舒服。C语言提供了一种枚举（Enum）类型，能够列出所有可能的取值，并给它们取一个名字。C语言没有bool类型，C++才有，可以用宏定义来定义TRUE和FALSE。 枚举类型的定义形式（定义一个类型）：enum typeName{ valueName1, valueName2, valueName3, ...... }; 枚举类型的初始化（定义的时候初始化）： 12enum WEEK&#123; Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 &#125;; //完全初始化enum WEEK&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125;; //部分初始化 定义枚举变量enum WEEK a, b, c; 定义类型、初始化、定义枚举变量enum WEEK{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } a, b, c; 赋值给枚举变量a = Mon; b = Wed; c = Sat; 定义枚举类型、初始化、定义枚举变量并赋值 1enum week&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125; a = Mon, b = Wed, c = Sat; 注意： 枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。 Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。 枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。Mon、Tues、Wed 这些名字都会被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用&amp;取得它们的地址，长度和 int类型相同。这就是枚举的本质。 空类型（关键字void) 在函数的参数列表和返回值中，void代表的含义是：一个函数形参列表为void，表示这个函数调用时不需要传参。返回值类型是void，表示这个函数不会返回一个有意义的返回值。所以不使用该返回值。 void *是void类型的指针。void类型的指针的含义是：这是一个指针变量，该指针指向一个void类型的数。void类型的数就是说这个数有可能是int、float、结构体，只有清楚是哪个类型才能准确调用指针。 指针类型 通常说的指针其实是指针变量，里面存放的是地址，因此指针大小是固定的，打印指针对应地址的内容用%p。 基础知识&amp;:取地址符，将它加在某个变量前面，则组合后的符号代表这个变量的地址值。 ：指针符号。指针符号在指针定义和指针操作的时候，解析方法是不同的。int p；定义指针变量p，这里的``含义不是代表指针变量p所指向的那个变量，在定义时这里的*含义是告诉编译器p是一个指针。 指针的定义和初始化 第一种：先定义再赋值 123456int *p1；//定义指针变量pint* p2；//可以int *p3;//可以，而且三种写法效果一样p1 = &amp;a;//给p赋值p2 = &amp;b;p3 = &amp;c; 第二种：定义的同时初始化 1int *p=&amp;a;//效果等同于上面的两句 不同类型的指针指针变量本质上是一个变量，指针变量的类型属于指针类型。int *p；定义了一个指针类型的变量p，这个p所指向的那个变量是int型。各种指针类型和它们所指向的变量类型必须匹配，否则结果不可预知。 1234int *pInt;//pInt是指针变量，指向的变量是int类型char *pchar;//pchar是指针类型，指向的变量是char类型float *pFloat;double *pDouble; 前面说到指针都是4字节的，都是存放地址的，不管是int类型的指针还是char类型的都一样，那么为什么还是要有各种类型的指针？一个原因是方便设置指针的增量，比如说int类型在某个编译器是4个字节的，指针p指向int类型的变量a，那p++指向的是&amp;a+4这个地址的变量。另一个原因是为了类型安全，定义指针的类型帮助编译器发现你是否用了错误的类型，这也是C为什么要有类型的最初原因。 12345678910int main()&#123; double b = 13; double *p_b = &amp;b; int a = 9; int *p_a = &amp;a; printf("int类型变量a的地址：%p，指针+1后的地址：%p",p_a,p_a+1); printf("double类型变量a的地址：%p，指针+1后的地址：%p",p_b,p_b+1); return 0;&#125; 指针与数组的初步结合数组名：做右值时，数组名表示数组的首元素首地址，因此可以直接赋值给指针。如果有int a[5]；则a和&amp;a[0]都表示数组首元素a[0]的首地址。&amp;a则表示数组的首地址。如果用int类型指针p指向&amp;a，编译器会警告，但不会报错，结果也是正确的。但是最好是将&amp;a赋值给数组类型的指针。 函数 函数有助于让人看懂代码，理清逻辑。 函数类型：主函数（main）、库函数、自定义函数C语言中所谓的主函数就是一种特别的函数。一个c语言程序只能有且必须有一个main函数。c语言规定，一个c语言程序从主函数开始执行，到主函数执行完结束。库函数，例如：printf函数的作用是用来在标准输出中打印信息。这个函数是c语言标准库提供的一个库函数。在c语言中写代码时可以引用库函数，但是必须使用#include引用这个库函数所在的头文件。自己写的函数需要有三要素：定义、声明、调用。 函数三要素函数定义：函数定义中包含了函数体，函数体中的代码段，决定了这个函数的功能。函数声明：函数声明实际上是叫函数原型声明。函数的原型包含三部分：函数名，返回值类型，函数参数列表。函数调用：函数调用就是使用函数名来调用函数完成功能。调用时必须参照原型给函数传参，然后从函数得到适当的返回值作为结果。| 函数的参数形参：形式参数的简称。在函数定义和函数声明中的参数列表中的参数，都是形参。实参：实际参数的简称。函数调用中，实际传递的参数才是实参。函数调用的过程，其实就是实参传递给形参的一个过程。这个传递实际是一次拷贝。实际参数的时候，实参（本质是一个变量）本身并没有进入到函数内，而是把自己的值复制了一份传给了函数中的形参，在函数中参与运算。这种传参方法，就叫做传值调用，当参数是指针的时候是传址调用。 返回值：（关键字return)当函数执行完之后，会给调用该函数的地方返回一个值。这个值的类型就是函数声明中返回值类型，这个值就是函数体中最后一句return xxx；返回的那个值。 宏定义 #define 叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。一般形式：#define 宏名 字符串 #define N 100就是宏定义，N为宏名，100是宏的内容（宏所表示的字符串）。在预处理阶段，对程序中所有出现的“宏名”，预处理器都会用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。宏定义是由源程序中的宏定义命令#define完成的，宏替换是由预处理程序完成的。#表示这是一条预处理命令，所有的预处理命令都以 # ,它不需要双引号。 程序中反复使用的表达式就可以使用宏定义，例如：#define M (n*n+3*n)的地方都可以用 M 来表示，而对源程序编译时，将先由预处理程序进行宏代替，即用 (yy+3y) 去替换所有的宏名 M，然后再进行编译。需要注意的是，在宏定义中表达式(nn+3n)两边的括号不能少，否则在宏展开以后可能会产生歧义。 12#define S(r) (PI*r*r)//过算园面积的宏#define L(r) (2*PI*r)//过篡圆的周长的宏 注意： 使用宏定义最好将整个表达式和里面不确定的值用括号括起来。 1234#define PI (3.14)#define S(r) (PI*(r)*(r))#define L(r) (2* PI*(r))#define FEC PER_YEAR (365*24*60*60)UL //使用宏定义定义一个宏，表示一年中的秒数，UL表示无符号长整型 习惯上宏名用大写字母表示，以便于与变量区别。但也允许用小写字母。 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序（main函数）结束。如要终止其作用域可使用#undef命令。 代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替,例如在printf要打印的内容里面。 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。 可用宏定义表示数据类型，使书写方便。#define UINT unsigned int 应注意用宏定义表示数据类型和用 typedef 定义数据说明符的区别。宏定义只是简单的字符串替换，由预处理器来处理；而 typedef 是在编译阶段由编译器处理的，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。 1234#define PIN1 (int *）typedef int *PIN2; //也可以写作typedef int (*PIN2);从形式上看这两者相似， 但在实际使用中却不相同。PIN1 a, b; //在宏代换后变成：int * a, b;表示 a 是指向整型的指针变量，而 b 是整型变量。PIN2 a,b; //表示 a、b 都是指向整型的指针变量。因为 PIN2 是一个新的、完整的数据类型。 接续符 c语言中的反斜杠()同时具有接续符与转义符的作用，但是当接续符或转义符是有限定条件的。 作为接续符使用时可直接出现在程序中 作为转义符使用时需出现在单引号或双引号之间 12345678910#include &lt;stdio.h&gt;int main(int argc,char **argv)&#123; printf(" * \ \n *** \ \n ***** \ \n *** \ \n * \ \n");&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux高阶命令]]></title>
    <url>%2Fpassages%2F2020-01-02-Linux%E9%AB%98%E9%98%B6%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux系统的高阶命令，有的不是很常用 高阶命令 虚拟机上网 vmware中虚拟机网络的三种设置 虚拟机上网方式1 虚拟机上网方式2 总结 高阶命令 命令 全称，功能 常用命令 find 查找 [find path -name”name”] grep Global Regular Expression Print，全局正则表达式版本 [grep -nr “要查找的符号” 目录/文件集合/*] [cd ../../] which 查找二进制文件路径 [which 指令] whereis 显示二进制文件的路径，源码，man手册位置 [mkdir 文件夹名] [whereis 指令] uname 系统信息 [uname -r] [uname -a] shutdown 关机 [shutdown -h now] [shutdown -r now] init 关机/重启 [init 0] [init 2] reboot 重启 [reboot] tree 显示文件和目录的树形结构 [tree] mount/umount 挂载/卸载磁盘到文件系统中 [mount -t nfs -o nolock 192.168.1.141:/root/rootfs /mnt] [umount /mnt] df 显示已挂载的分区列表 [df -h] du 列出文件或文件夹的大小 [du -h 文件夹/文件名/*] useradd 添加用户 [uesradd 用户名] userdel 删除用户 [userdel 用户名] passwd 设置用户密码 [passwd 用户名] chmod 修改文件权限 [chmod 编码 文件名] [chmod u/g/o+/-r/w/x] chown change owner,修改属主 [chown 用户名 文件名] chgrp change group,修改文件的组 [chgrp 组名 文件名] tar 解压/压缩 [tar -czvf xxx.gz/.bz2 path] [tar -zxvf xxx.gz] [tar -jxvf xxx.bz2] ifconfig 网络配置 [ifconfig eth0 ip地址] [ifconfig eth0 up/down] [ifup/ifdown eth0 ] [ifconfig eth0 ip地址 netmask 子网掩码] mkfs 格式化文件系统 [mkfs /dev/hdl] [mkfs -t vfat 32 -F /dev/hdl] sed/awk 匹配/替换 [] 虚拟机上网vmware中虚拟机网络的三种设置第一种：桥接（bridged）第二种：NAT第三种：Host only，该模式下仅主机可以上网，虚拟机不能上网。 虚拟机上网方式1NAT方式设置步骤：第一步：在菜单栏虚拟机-&gt;设置-&gt;硬件-&gt;网络适配器，右侧选择NAT模式第一步：vi /etc/network/interfaces,打开该文件，将内容编辑成为：auto loiface lo inet loopback auto eth0iface etho inet dhcgaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1 虚拟机上网方式2桥接方式设置步骤：第一步：桥接，在菜单栏 虚拟机-&gt;设置-&gt;硬件-&gt;网络适配器，右侧选择桥接模式。第二步：桥接到可以上网的网卡，在菜单栏 编辑-&gt;虚拟网络编辑器，选择桥接到自己Windows中可以上网的网卡上（一般就是Wifi网络或者有线网络）第三步：设置dhcp并重启网卡。vi /etc/network/interfaces,打开该文件，将内容编辑成为：auto loiface lo inet loopback auto eth0iface eth0 inet dhcpaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1保存退出，然后命令行执行/etc/init.d/networking restart重启网卡 总结第一，NAT方式设置上网比较简单，但是不能用在嵌入式开发中。第二，桥接方式设置上网较繁琐，但是在嵌入式开发中比较有用。]]></content>
      <categories>
        <category>嵌入式软件开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux基本知识与操作]]></title>
    <url>%2Fpassages%2F2019-12-31-Linux%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[学习嵌入式的核心之————Linux操作系统（操作&amp;基本概念） 基本知识 隐藏文件 相对路径与绝对路径 linux内核和发行版 gui和命令行 虚拟机的安装-linux 常用linux命令 安装交叉编译工具链 文件类型标记方法 vim基础使用 符号含义 makefile shell 基本知识隐藏文件Linux隐藏文件是在文件名开头加上一个“.”，在终端使用ls命令就无法看到隐藏文件，要用ls -a命令才能看见，并且图形界面的文件管理里面可以直接看到文件，没有隐藏效果。 相对路径与绝对路径绝对路径由/开始，/就是根目录。相对路径可以用../xxx来代表所处目录上一个文件夹的xxx文件夹里面的东西。 linux内核和发行版单独的Linux就是一个内核，包含内核和一些应用程序的版本就是发行版，不同版本包含的应用程序可能不一样。常见的有Ubuntu、Redhat。 gui和命令行人机交互的两种方式（图形用户界面GUI、命令行command line） 虚拟机的安装-linux 安装VMware 下载linux镜像文件（ubuntu-16.04.6-desktop-amd64.iso） 加载镜像：打开VMvare，创建新虚拟机-稍后安装操作系统-选择操作系统和版本-设置安装位置-设置磁盘大小和是否拆分文件-完成，在VMware的虚拟机设置-硬件-CD/DVD-使用ISO映像文件-选择下载的iso文件地址。 关于设置密码，记得打开键盘再输入。 安装VMware Tools（以至于可以使用windows和虚拟机之间的交互，比如两个系统之间复制粘贴）：Player-管理-安装VMware Tools-在打开的光驱里面复制vmware-tools-distrib到某个目录并解压，使用终端执行里面的vmware-install.pl来安装。 安装搜狗输入法：官网下载sogoupinyin_2.3.1.0112_amd64.deb-Ubuntu apt更换国内源-终端进入下载的文件夹安装搜狗输入法：sudo dpkg -i sogoupinyin_2.3.1.0112_amd64.deb-搜索并补全依赖关系：sudo apt-get install -f-重启 123456789101112131415Ubuntu apt默认的下载源是cn.archive.ubuntu.com/ubuntu/，这是一个国外的网站，下载速度比较慢，我们将下载源更换为国内镜像站，提高下载速度和连接的稳定性。apt下载源的配置文件是/etc/apt/sources.list,使用命令 cat /etc/apt/sources.list 可以看到其中的内容。欲更换下载源，替换该文件中的默认源为国内源即可，这里采用的是清华tuna源。为保险起见，修改文件前，先备份一下文件cp /etc/apt/sources.list /etc/apt/sources_bak.list然后sudo gedit /etc/apt/sources.list 或者 sudo vim /etc/apt/sources.list将文件内容替换为（以清华源ipv6镜像站为例，其他国内镜像站类似）deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse最后更新源sudo apt-get update 安装arm-linux-gcc：下载并解压arm-linux-gcc-5.4.0.tar.gz到/home/bin/arm-修改配置文件gedit /home/pxf/.bashrc文件末尾加上export PATH=$PATH:/home/pxf/bin/arm/5.4.0/bin并保存-使配置文件生效source /home/pxf/.bashrc-测试是否生效arm-linux-gcc -v-安装32位支持库apt-get install ia32-libs-安装替代软件包apt-get install lib32ncurses5 lib32z1-安装软件包apt-get install lib32stdc++6 apt-get install lib32z1和apt-get install lib32stdc++6 apt-get install lib32z1 将安装操作系统的文件夹复制到U盘保存 常用linux命令 命令 全称，功能 常用命令 ls list,列表 [ls -a] [ls -l] cd change directory，改变目录 [cd ..] [cd ../../] pwd print work directory，打印工作目录 [pwd] mkdir make directory，创建文件夹 [mkdir 文件夹名] [mkdir -p 文件夹名/文件夹名] mv move，移动 [mv pathname pathname] [mv name name] touch 触摸/创建 [touch pathname] cp cope，复制 [cp pathname pathname] [cp -r ] [cp -f] rm remove，去除 [rm pathname] [rm -r pathname] cat catch，抓住/显示 [cat] rmdir remove directory，去除空文件夹 [rmdir path] ln link，连接 [ln -s 源文件名 符号连接文件名] [ln 源文件名 连接文件名] su superuser，超级用户 [su root/空] [su 用户名] apt-get Ubuntu里面在线安装、卸载软件的程序 [sudo apt-get install 软件名] [sudo apt-get remove 软件名] uname 打印操作系统信息 [uname -a] man manual，手册 [man 1/2/3 Linux命令/Linux api/c库函数] 安装交叉编译工具链 Windows中装软件的特点Windows中装软件使用安装包，安装包解压后有2种情况：一种是一个安装文件（.exe .msi），双击进行安装，下一步直到安装完毕。安装完毕后会在桌面上生成快捷方式，我们平时使用快捷方式来启动这些程序；另一种是所谓的绿色软件、免安装软件。这种不用安装，直接解压开里面就有exe可以直接双击执行。 linux中装软件的特点第一种：在线安装。譬如ubuntu中使用apt-get install vim来安装vim软件。第二种：自己下载安装包来安装。这种方式的缺陷就是不知道下载的安装包和你的系统是否匹配。第三种：源代码安装，使用编译器直接编译运行程序。安装交叉编译工具链（arm-linux-gcc）实际多采用第二种安装方式。 交叉编译工具链的安装步骤1：打开虚拟机，在/usr/local/下创建/usr/local/arm文件夹步骤2：先将安装包从Windows中放进linux中去。可以用共享文件夹、Samba、cuteftp。步骤3：解压tar -jxvf arm-2009q3.tar.bz2到此相当于程序已经安装完毕，真正的应用程序安装在/usr/local/arm/arm-2009q3/bin目录下 安装后的测试到真正的应用程序的安装目录下（也就是/usr/local/arm/arm-2009q3/bin），去执行arm-linux-gcc -v执行方法是：./arm-none-linux-gnueabi-gcc -v执行后可以得到一长串输出，其中有“gcc version 4.4.1 ”字样，即表示安装成功。 将工具链导出到环境变量 环境变量就是操作系统的全局变量。每一个环境变量对操作系统来说都是唯一的，名字和所代表的意义都是唯一的。linux系统可以有很多个环境变量。其中有一部分是linux系统自带的，还有一些是用户扩充的。我们这里涉及到的一个环境变量是PATH。PATH这个环境变量是系统自带的，它的含义就是系统在查找可执行程序时会搜索的路径范围。每次打开linux终端，系统都会自动运行~/.bashrc这个文件，里面存放环境变量PATH ①执行export PATH=/usr/local/arm/arm-2009q3/bin:$PATH命令，意义是将PATH变量前加上/usr/local/arm/arm-2009q3/bin:之后的变量保存到PATH（也可以直接在.bashrc文件最后加上export PATH=/usr/local/arm/arm-2009q3/bin:）。②运行改变之后的.bashrc文件，source .bashrc（或者直接关掉终端重新打开，因为系统会自动运行）注意：我们导出这个环境变量是在当前用户，如果你登录时在其他用户下是没用的。③具体操作可以参考这篇文章④为工具链创建arm-linux-xxx符号链接（可以理解为快捷方式）ln arm-none-linux-gnueabi-addr2line -s arm-linux-addr2line 文件类型标记方法ls -l 显示详细信息中，第1个字符表示文件类型，后面9个字符表示文件权限-rw-r- -r- -drwxr-xr-x 第1个字符 文件类型 - 普通文件 d 文件夹 l 符号连接文件 s socket文件 p pipe管道文件 后面9个字符分三组（rwx-read-write-execute）前三个表示此文件的属主对文件的权限中间三个表示此文件属主所在的组对文件的权限后面三个表示其他用户对文件的权限 权限的另一种表示方法：r: 4w: 2x: 1-rw-r- -r- -(644) vim基础使用创建/打开文件命令：vi pathname命令模式：默认命令模式，按a/i进入输入模式。输入模式：按a/i进入，按esc进入命令模式。 命令模式下的命令 作用 :q 关闭文件 :w 保存文件 :wq! 强制保存并关闭文件 /abc abc：要查找的内容 :num num：跳转的行数 :set nu/:set nonu 显示行数/隐藏行数 dd 整行删除 numdd num:要连续删除的行数 nyy n:复制的行数 p 粘贴 符号含义 符号 含义 . 代表当前目录 .. 代表上一层目录 - 代表前一个目录 ~ 代表当前用户的宿主目录 / 代表根目录 $ 普通用户的命令行提示符 # root用户的命令行提示符 * 万能匹配符 makefile 为什么需要MakefileMakefile是用来管理工程的。在一个正式的软件项目中，由很多个.c和.h文件构成，此时如果直接在命令行编译，就会像这样：gcc a.c b.c c.c d.c e.c f.c g.c -o exe每次编译都要输入。 Makefile中的一些基本概念目标：目标(target)顶格写，后面是冒号（冒号后面是依赖）依赖：依赖(prerequisites)是用来产生目标的源文件。命令：命令(command)前面是Tab，不能是定格，也不能说多个空格。命令就是要生成那个目标需要做的命令，可以是多个。Makefile 里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 12345678910111213141516171819202122232425262728#target 也就是一个目标文件，可以是 Object File，也可以是执行文件，还可以是一个标签（Label）。#prerequisites 就是要生成那个 target 所需要的文件或是目标。#command 也就是 make 需要执行的命令。（任意的 Shell 命令）target:prerequisites command#这是一个文件的依赖关系，也就是说，target 这一个或多个的目标文件依赖于 prerequisites 中的文件，其生成规则定义在 command 中。说白一点就是说，prerequisites 中如果有一个以上的文件比 target 文件要新的话，command 所定义的命令就会被执行,make 会比较 targets 文件和 prerequisites 文件的修改日期。objects = main.o kbd.o command.o display.o \insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects) main.o : defs.h kbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : -rm edit $(objects) # “.PHONY”来显 示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”命令。# rm 命令前面加了一个小 减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的命令。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。 Makefile的基本工作原理其一，当我们执行 make xx(target) 的时候，Makefile会自动执行xx这个目标下面的命令语句。其二，当我们make xx的时候，是否执行命令是取决于依赖的。依赖如果成立就会执行命令，否则不执行。其三，我们直接执行make和make第一个目标 效果是一样的。（第一个目标其实就是默认目标） shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。shell教程 shell 脚本概念Shell脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但shell 和 shell script 是两个不同的概念。由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。 Shell 环境Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。Linux 的 Shell 种类众多，常见的有：Bourne Shell（/usr/bin/sh或/bin/sh）Bourne Again Shell（/bin/bash）C Shell（/usr/bin/csh）K Shell（/usr/bin/ksh）Shell for Root（/sbin/sh）……本文关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。 shell 脚本编写打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。输入一些代码，第一行一般是这样： 12345#!/bin/bashecho "Hello World!"#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。# echo 命令用于向窗口输出文本。 运行 Shell 脚本的方法：1、作为可执行程序将上面的代码保存为 test.sh，并 cd 到相应目录： 12chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本 注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统就在当前目录找。 2、作为解释器参数这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： 12/bin/sh test.sh/bin/php test.php 这种方式运行的脚本，不需要在脚本文件第一行指定解释器信息，写了也没用。]]></content>
      <categories>
        <category>嵌入式软件开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA文件流]]></title>
    <url>%2Fpassages%2F2019-10-16-JAVA%E6%96%87%E4%BB%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[在计算机系统中，文件是非常重要的存储方式。Java的标准库java.io提供了File对象来操作文件和目录。要构造一个File对象，需要传入文件路径。 File InputStream OutputStream File构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如： 1File f = new File("C:\\Windows\\notepad.exe"); 注意Windows平台使用\和/作为路径分隔符，Linux平台使用/作为路径分隔符，在Java字符串中需要用\表示一个\。 12File f = new File("/usr/bin/javac");File f = new File("C:\\Windows\\notepad.exe"); InputStreamnputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。 要特别注意的一点是，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()。 FileInputStream是InputStream的一个子类。顾名思义，FileInputStream就是从文件流中读取数据。下面的代码演示了如何完整地读取一个FileInputStream的所有字节： 123456789101112public void readFile() throws IOException &#123; // 创建一个FileInputStream对象: InputStream input = new FileInputStream("src/readme.txt"); for (;;) &#123; int n = input.read(); // 反复调用read()方法，直到返回-1 if (n == -1) &#123; break; &#125; System.out.println(n); // 打印byte的值 &#125; input.close(); // 关闭流&#125; 仔细观察上面的代码，会发现一个潜在的问题：如果读取过程中发生了IO错误，InputStream就没法正确地关闭，资源也就没法及时释放。 因此，我们需要用try … finally来保证InputStream在无论是否发生IO错误的时候都能够正确地关闭： 123456789101112public void readFile() throws IOException &#123; InputStream input = null; try &#123; input = new FileInputStream("src/readme.txt"); int n; while ((n = input.read()) != -1) &#123; // 利用while同时读取并判断 System.out.println(n); &#125; &#125; finally &#123; if (input != null) &#123; input.close(); &#125; &#125;&#125; 在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。InputStream提供了两个重载方法来支持读取多个字节： int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数利用上述方法一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。 利用缓冲区一次读取多个字节的代码如下： 12345678910public void readFile() throws IOException &#123; try (InputStream input = new FileInputStream("src/readme.txt")) &#123; // 定义1000个字节大小的缓冲区: byte[] buffer = new byte[1000]; int n; while ((n = input.read(buffer)) != -1) &#123; // 读取到缓冲区 System.out.println("read " + n + " bytes."); &#125; &#125;&#125; OutputStream和InputStream相反，OutputStream是Java标准库提供的最基本的输出流。 和InputStream类似，OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b). 我们以FileOutputStream为例，演示如何将若干个字节写入文件流： 123456789public void writeFile() throws IOException &#123; OutputStream output = new FileOutputStream("out/readme.txt"); output.write(72); // H output.write(101); // e output.write(108); // l output.write(108); // l output.write(111); // o output.close();&#125; 每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用OutputStream提供的重载方法void write(byte[])来实现： 12345public void writeFile() throws IOException &#123; OutputStream output = new FileOutputStream("out/readme.txt"); output.write("Hello".getBytes("UTF-8")); // Hello output.close();&#125; 和InputStream一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用try(resource)来保证OutputStream在无论是否发生IO错误的时候都能够正确地关闭： 12345public void writeFile() throws IOException &#123; try (OutputStream output = new FileOutputStream("out/readme.txt")) &#123; output.write("Hello".getBytes("UTF-8")); // Hello &#125; // 编译器在此自动为我们写入finally并调用close()&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA客户端如何连接服务器]]></title>
    <url>%2Fpassages%2F2019-10-16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[了解基本概念方可知晓如何操作。 Socket Socket构造方法 Socket成员方法 ServerSocket ServerSocket构造方法 ServerSocket成员方法 SocketSocket（套接字），是一个包含IP地址和端口号的网络单元。使用套接字就会在网络中使用tcp协议，实现精确的数据传输。 Socket构造方法在java.net.Socket里有构造方法： 12//host可以是IP地址也可以是服务器名，port即是端口号。创建socket对象就会请求服务器，并经过三次握手进行连接,服务器如果没有启动即会抛出连接异常ConnectException。Socket（String host，int port） Socket成员方法123456//由该方法获取套接字的网络字节输出流的OutputStream对象，然后用该对象的write（byte[] b）方法给服务器发送数据。字符串.getBites()可以将字符串转化为字节数组。OutputStream getOutputStream()//由该方法获取套接字的网络字节输入流的InputStream对象，然后用该对象的read方法读取服务器回写的数据InputStream getInputStream()//释放资源（Socket）Socket.close（） ServerSocketServerSocket（服务器套接字） ServerSocket构造方法在java.net.ServerSocket里有构造方法： 12//port即是端口号ServerSocket（int port） ServerSocket成员方法12345678910//用accept方法来监听，获取客户端套接字的对象（返回Socket）ServerSocket ss = new ServerSocket(TCP_PORT);Socket s = ss.accept();//由该方法获取套接字的网络字节输入流的InputStream对象，然后用该对象的read方法读取客户端发送的数据InputStream getInputStream()//由该方法获取套接字的网络字节输出流的OutputStream对象，然后用该对象的write（byte[] b）方法给客户端回写数据。字符串.getBites()可以将字符串转化为字节数组。OutputStream getOutputStream()//释放资源（Socket、SocketSocket）Socket.close（）SocketSocket.close（）]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo博客的一些变动]]></title>
    <url>%2Fpassages%2F2019-10-14-hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%98%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[问题：博客文章搜索功能用不了去添加搜索功能的官网找到了原因：试用期过期。只能另外找插件，不过目前暂时没空，只能以后解决。 问题：当文章太长，阅读起来非常难想了很多办法，比如把代码折叠、把文章折叠、制作文章目录，最终都制作失败，后来发现hexo有文章目录的功能，然后下载了toc插件，然后改了一下主题的_config.yml配置文件，以后在写文章的时候加上 就行了。但是发现一个问题，标题有大写英文字母或者标点符号的时候点击文章目录没有反应。然后就是返回上一页的话会先返回原本的页面，因为点击文章目录相当于进了另一个页面。]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[表单组件02]]></title>
    <url>%2Fpassages%2F2019-08-31-%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B602%2F</url>
    <content type="text"><![CDATA[input、 input组件（表单） wxml文件代码 js文件代码 组件（表单） wxml文件代码 js文件代码 因为表单组件目前为止是15个，只选取最重要最常用的记录。 input组件（表单）input微信小程序文档 wxml文件代码1234567891011121314151617181920212223242526272829303132333435&lt;!--input.wxml--&gt;&lt;view class="section"&gt; &lt;input placeholder="这是一个可以自动聚焦的input" auto-focus/&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;input placeholder="这个只有在按钮点击的时候才聚焦" focus="&#123;&#123;focus&#125;&#125;" /&gt; &lt;view class="btn-area"&gt; &lt;button bindtap="bindButtonTap"&gt;使得输入框获取焦点&lt;/button&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;input maxlength="10" placeholder="最大输入长度10" /&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;你输入的是：&#123;&#123;inputValue&#125;&#125;&lt;/view&gt; &lt;input bindinput="bindKeyInput" placeholder="输入同步到view中"/&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;input bindinput="bindReplaceInput" placeholder="连续的两个1会变成2" /&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;input password type="number" /&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;input password type="text" /&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;input type="digit" placeholder="带小数点的数字键盘"/&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;input type="idcard" placeholder="身份证输入键盘" /&gt;&lt;/view&gt;&lt;view class="section"&gt; &lt;input placeholder-style="color:red" placeholder="占位符字体是红色的" /&gt;&lt;/view&gt; js文件代码123456789101112131415161718192021222324252627282930313233343536//input.jsPage(&#123; data: &#123; focus: false, inputValue: '' &#125;, bindButtonTap: function() &#123; this.setData(&#123; focus: true &#125;) &#125;, bindKeyInput: function(e) &#123; this.setData(&#123; inputValue: e.detail.value &#125;) &#125;, bindReplaceInput: function(e) &#123; var value = e.detail.value var pos = e.detail.cursor if(pos != -1)&#123; //光标在中间 var left = e.detail.value.slice(0,pos) //计算光标的位置 pos = left.replace(/11/g,'2').length &#125; //直接返回对象，可以对输入进行过滤处理，同时可以控制光标的位置 return &#123; value: value.replace(/11/g,'2'), cursor: pos &#125; //或者直接返回字符串,光标在最后边 //return value.replace(/11/g,'2'), &#125;&#125;) 组件（表单）微信小程序文档 wxml文件代码12 js文件代码12]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之表单组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单组件01]]></title>
    <url>%2Fpassages%2F2019-08-08-%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B601%2F</url>
    <content type="text"><![CDATA[button、checkbox、form button组件（按钮） wxml文件代码 js文件代码 wxss文件代码 checkbox组件（多选） wxml文件代码 js文件代码 form组件 wxml文件代码 js文件代码 因为表单组件目前为止是15个，只选取最重要最常用的记录。 button组件（按钮）button微信小程序文档 wxml文件代码123456789101112131415161718192021//通过函数和数据绑定来改变属性值&lt;button type="default" size="&#123;&#123;defaultSize&#125;&#125;" loading="&#123;&#123;loading&#125;&#125;" plain="&#123;&#123;plain&#125;&#125;" disabled="&#123;&#123;disabled&#125;&#125;" bindtap="default" hover-class="other-button-hover"&gt; default &lt;/button&gt;&lt;button type="primary" size="&#123;&#123;primarySize&#125;&#125;" loading="&#123;&#123;loading&#125;&#125;" plain="&#123;&#123;plain&#125;&#125;" disabled="&#123;&#123;disabled&#125;&#125;" bindtap="primary"&gt; primary &lt;/button&gt;&lt;button type="warn" size="&#123;&#123;warnSize&#125;&#125;" loading="&#123;&#123;loading&#125;&#125;" plain="&#123;&#123;plain&#125;&#125;" disabled="&#123;&#123;disabled&#125;&#125;" bindtap="warn"&gt; warn &lt;/button&gt;&lt;button bindtap="setDisabled"&gt;点击设置以上按钮disabled属性&lt;/button&gt;&lt;button bindtap="setPlain"&gt;点击设置以上按钮plain属性&lt;/button&gt;&lt;button bindtap="setLoading"&gt;点击设置以上按钮loading属性&lt;/button&gt;&lt;button open-type="contact"&gt;进入客服会话&lt;/button&gt;&lt;button open-type="getUserInfo" lang="zh_CN" bindgetuserinfo="onGotUserInfo"&gt;获取用户信息&lt;/button&gt;&lt;button open-type="openSetting"&gt;打开授权设置页&lt;/button&gt; js文件代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var types = ['default', 'primary', 'warn']//pageObject本质应该是代码块，最后的page(pageObject)类似于page(&#123;&#125;)var pageObject = &#123; data: &#123; defaultSize: 'default', primarySize: 'default', warnSize: 'default', disabled: false, plain: false, loading: false &#125;, setDisabled: function(e) &#123; this.setData(&#123; disabled: !this.data.disabled &#125;) &#125;, setPlain: function(e) &#123; this.setData(&#123; plain: !this.data.plain &#125;) &#125;, setLoading: function(e) &#123; this.setData(&#123; loading: !this.data.loading &#125;) &#125;, onGotUserInfo: function(e) &#123; console.log(e.detail.errMsg) console.log(e.detail.userInfo) console.log(e.detail.rawData) &#125;,&#125;//使用for循环遍历函数for (var i = 0; i &lt; types.length; ++i) &#123; //for循环里面两个括号，一个括号放函数，一个括号放数组的元素。不知道是什么结构。 (function(type) &#123; pageObject[type] = function(e) &#123; //这里的key就是上面的按钮名称 var key = type + 'Size' var changedData = &#123;&#125; //改变按钮名称里面的内容 changedData[key] = this.data[key] === 'default' ? 'mini' : 'default' //设置内容 this.setData(changedData) &#125; &#125;)(types[i])&#125;Page(pageObject) wxss文件代码123456.button-hover &#123; background-color: red;&#125;.other-button-hover &#123; background-color: blue;&#125; checkbox组件（多选）checkbox微信小程序文档 wxml文件代码1234567&lt;checkbox-group bindchange="checkboxChange"&gt; &lt;label class="checkbox" wx:for="&#123;&#123;items&#125;&#125;"&gt; //第一个value是标识属性，当选中该选项的时候里面的字符串会被记录下来，打印value的时候会把选中的value全部打印。 //第二个value是数组里面的元素，与第一个value无关。 &lt;checkbox value="&#123;&#123;item.name&#125;&#125;" checked="&#123;&#123;item.checked&#125;&#125;"/&gt;&#123;&#123;item.value&#125;&#125; &lt;/label&gt;&lt;/checkbox-group&gt; js文件代码123456789101112131415Page(&#123; data: &#123; items: [ &#123;name: 'USA', value: '美国'&#125;, &#123;name: 'CHN', value: '中国', checked: 'true'&#125;, &#123;name: 'BRA', value: '巴西'&#125;, &#123;name: 'JPN', value: '日本'&#125;, &#123;name: 'ENG', value: '英国'&#125;, &#123;name: 'TUR', value: '法国'&#125;, ] &#125;, checkboxChange: function(e) &#123; console.log('checkbox发生change事件，携带value值为：', e.detail.value) &#125;&#125;) form组件form微信小程序文档 wxml文件代码123456789101112131415161718192021222324252627282930313233&lt;form bindsubmit="formSubmit" bindreset="formReset"&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;switch&lt;/view&gt; &lt;switch name="switch"/&gt; &lt;/view&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;slider&lt;/view&gt; &lt;slider name="slider" show-value &gt;&lt;/slider&gt; &lt;/view&gt; &lt;view class="section"&gt; &lt;view class="section__title"&gt;input&lt;/view&gt; &lt;input name="input" placeholder="please input here" /&gt; &lt;/view&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;radio&lt;/view&gt; &lt;radio-group name="radio-group"&gt; &lt;label&gt;&lt;radio value="radio1"/&gt;radio1&lt;/label&gt; &lt;label&gt;&lt;radio value="radio2"/&gt;radio2&lt;/label&gt; &lt;/radio-group&gt; &lt;/view&gt; &lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;checkbox&lt;/view&gt; &lt;checkbox-group name="checkbox"&gt; &lt;label&gt;&lt;checkbox value="checkbox1"/&gt;checkbox1&lt;/label&gt; &lt;label&gt;&lt;checkbox value="checkbox2"/&gt;checkbox2&lt;/label&gt; &lt;/checkbox-group&gt; &lt;/view&gt; &lt;view class="btn-area"&gt; &lt;button form-type="submit"&gt;Submit&lt;/button&gt; &lt;button form-type="reset"&gt;Reset&lt;/button&gt; &lt;/view&gt;&lt;/form&gt; js文件代码12345678Page(&#123; formSubmit: function(e) &#123; console.log('form发生了submit事件，携带数据为：', e.detail.value) &#125;, formReset: function() &#123; console.log('form发生了reset事件') &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之表单组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rich-text]]></title>
    <url>%2Fpassages%2F2019-08-06-rich-text%2F</url>
    <content type="text"><![CDATA[text微信小程序文档 rich-text组件 wxml文件代码 js文件代码 rich-text组件使用该组件可设置html的样式。 wxml文件代码1&lt;rich-text nodes="&#123;&#123;nodes&#125;&#125;" bindtap="tap"&gt;&lt;/rich-text&gt; js文件代码123456789101112131415161718Page(&#123; data: &#123; nodes: [&#123; name: 'div', attrs: &#123; class: 'div_class', style: 'line-height: 60px; color: red;' &#125;, children: [&#123; type: 'text', text: 'Hello&amp;nbsp;World!' &#125;] &#125;] &#125;, tap() &#123; console.log('tap') &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之基础组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[progress]]></title>
    <url>%2Fpassages%2F2019-08-06-progress%2F</url>
    <content type="text"><![CDATA[progress微信小程序文档 process组件 wxml文件代码 process组件可设置进度条的进度、宽度、颜色等属性。 wxml文件代码1234&lt;progress percent="20" show-info /&gt;&lt;progress percent="40" stroke-width="12" /&gt;&lt;progress percent="60" color="pink" /&gt;&lt;progress percent="80" active /&gt;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之基础组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text]]></title>
    <url>%2Fpassages%2F2019-08-06-text%2F</url>
    <content type="text"><![CDATA[text微信小程序文档 text组件 wxml文件代码 js文件代码 text组件可以在组件里面添加文本，特点是可以给文本添加属性，比如说可选。 wxml文件代码1234567&lt;view class="btn-area"&gt; &lt;view class="body-view"&gt; &lt;text selectable = "true"&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;button bindtap="add"&gt;add line&lt;/button&gt; &lt;button bindtap="remove"&gt;remove line&lt;/button&gt; &lt;/view&gt;&lt;/view&gt; js文件代码123456789101112131415161718192021var initData = 'this is first line\nthis is second line'var extraLine = [];Page(&#123; data: &#123; text: initData &#125;, add: function (e) &#123; extraLine.push('other line') this.setData(&#123; text: initData + '\n' + extraLine.join('\n') &#125;) &#125;, remove: function (e) &#123; if (extraLine.length &gt; 0) &#123; extraLine.pop() this.setData(&#123; text: initData + '\n' + extraLine.join('\n') &#125;) &#125; &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之基础组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[icon]]></title>
    <url>%2Fpassages%2F2019-08-05-icon%2F</url>
    <content type="text"><![CDATA[icon微信小程序文档 icon组件 wxml文件代码 js文件代码 icon组件图标。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。 有提示、警告、多选、单选等图标。 wxml文件代码1234567891011121314151617&lt;view class="group"&gt; &lt;block wx:for="&#123;&#123;iconSize&#125;&#125;"&gt; &lt;icon type="success" size="&#123;&#123;item&#125;&#125;"/&gt; &lt;/block&gt;&lt;/view&gt;&lt;view class="group"&gt; &lt;block wx:for="&#123;&#123;iconType&#125;&#125;"&gt; &lt;icon type="&#123;&#123;item&#125;&#125;" size="40"/&gt; &lt;/block&gt;&lt;/view&gt;&lt;view class="group"&gt; &lt;block wx:for="&#123;&#123;iconColor&#125;&#125;"&gt; &lt;icon type="success" size="40" color="&#123;&#123;item&#125;&#125;"/&gt; &lt;/block&gt;&lt;/view&gt; js文件代码1234567891011Page(&#123; data: &#123; iconSize: [20, 30, 40, 50, 60, 70], iconColor: [ 'red', 'orange', 'yellow', 'green', 'rgb(0,255,255)', 'blue', 'purple' ], iconType: [ 'success', 'success_no_circle', 'info', 'warn', 'waiting', 'cancel', 'download', 'search', 'clear' ] &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之基础组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cover-view]]></title>
    <url>%2Fpassages%2F2019-08-05-cover-view%2F</url>
    <content type="text"><![CDATA[cover-view微信小程序文档 cover-view组件 cover-image组件 wxml文件代码 js文件代码 wxss文件代码 cover-view组件覆盖在原生组件之上的文本视图。可覆盖的原生组件包括map、video、canvas、camera、live-player、live-pusher。只支持嵌套 cover-view、cover-image，可在 cover-view 中使用 button。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。 意思其实就是可以在视频、地图等上面添加一些按钮、图片或者文字等。 cover-image组件覆盖在原生组件之上的图片视图。可覆盖的原生组件同cover-view，支持嵌套在cover-view里。 意思就是最好放在cover-view的组件里面。 wxml文件代码123456789101112&lt;video id="myVideo" src="http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400" controls="&#123;&#123;false&#125;&#125;" event-model="bubble"&gt;//controls是否显示默认播放控件（播放/暂停按钮、播放进度、时间） &lt;cover-view class="controls"&gt; &lt;cover-view class="play" bindtap="play"&gt; &lt;cover-image class="img" src="/path/to/icon_play" /&gt; &lt;/cover-view&gt; &lt;cover-view class="pause" bindtap="pause"&gt; &lt;cover-image class="img" src="/path/to/icon_pause" /&gt; &lt;/cover-view&gt; &lt;cover-view class="time"&gt;00:00&lt;/cover-view&gt; &lt;/cover-view&gt;&lt;/video&gt; js文件代码123456789101112Page(&#123; onReady() &#123; this.videoCtx = wx.createVideoContext('myVideo') //获取id为myVideo的上下文，方便下面的操作。 &#125;, play() &#123; this.videoCtx.play() &#125;, pause() &#123; this.videoCtx.pause() &#125;&#125;) wxss文件代码12345678910111213141516171819202122.controls &#123; position: relative; top: 50%; height: 50px; margin-top: -25px; display: flex;&#125;.play,.pause,.time &#123; flex: 1; height: 100%;&#125;.time &#123; text-align: center; background-color: rgba(0, 0, 0, .5); color: white; line-height: 50px;&#125;.img &#123; width: 40px; height: 40px; margin: 5px auto;&#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之视图容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客的一些优化]]></title>
    <url>%2Fpassages%2F2019-07-18-hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[使用博客的时候发现了一些问题，尝试解决。 问题1-某个分类的页面显示不了 问题2-友情链接的图片显示不了 问题3-搜索引擎搜索时会加上一串字符串 问题4-设置文章密码 问题1-某个分类的页面显示不了状况：1.目前我的博客只有两个分类，但是有一个打开不了。2.新建新的分类没问题。3.旧分类的文章可以改成新的分类，并且可以打开。 解决办法：将旧分类的所有文章分类修改成新的分类，使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d重新配置，然后再改回来旧的分类，再配置一遍。 猜想：可能是之前配置的时候存在一些问题，只要把分类更新一遍就行。 问题2-友情链接的图片显示不了状况：可以设置图片的路径，但是将图片放进文件夹，配置之后被删除了。 解决办法：将图片放进主题的images文件夹，而不是配置之后生成的images文件夹。 问题3-搜索引擎搜索时会加上一串字符串状况：在搜索引擎搜索框输入问题时，搜索的时候会加上其他的字符串。 解决办法：找到\themes\ad\source\js这个目录下的header.js文件，将里面的keywords变量的前面的多余的字符串删去。 问题4-设置文章密码状况：不知道原作者如何判断文章是否上锁的，估计是这个地方出了问题。 原始功能：1.可以设置全部文章锁定。2.可以设置单篇文章锁定。3.可以输入一次密码后三天内不用重复输入密码。（这个功能很实用，不用重复输入密码） 解决办法①：找到\themes\ad\source\js这个目录下的auth.js文件（auth——授权），将里面的lock===false改成lock===true。 1234567891011121314151617181920212223242526272829const auth = () =&gt; &#123; const day = 60 * 60 * 24 * 1000; const &#123; is_post, lock, passwords, root &#125; = window.AD_CONFIG; //判断是否是文章(是文章的网址is_post是true) //是否锁上了，这里只能当成全部文章锁上了。（lock永远不等于true，所以永远不会return） if(is_post === false || lock === true) &#123; return; &#125; let [password, expires] = atob(window.localStorage.getItem('auth')).split(':'), now = new Date().getTime(); //判断密码是否正确？、判断是否过了有效期(includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。) if(passwords.includes(password) &amp;&amp; now &lt; expires) &#123; return; &#125; password = prompt('输入暗号：博客作者的名称小写全拼 (例如: 李三 =&gt; lisan)'); password = sha256(password || ''); if(passwords.includes(password)) &#123; expires = now + day * 3; window.localStorage.setItem('auth', btoa(`$&#123;password&#125;:$&#123;expires&#125;`)); &#125; else &#123; alert('您没有阅读权限'); window.location.href = root; &#125;&#125;; 现在的功能：1.可以设置全部文章锁定。2.可以输入一次密码后三天内不用重复输入密码。 解决办法②：使用插件，详见链接]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[movable-view]]></title>
    <url>%2Fpassages%2F2019-07-17-movable-view%2F</url>
    <content type="text"><![CDATA[movable-view微信小程序文档 movable-view组件 wxml文件代码 js文件代码 movable-view组件[可移动]的视图容器，在页面中可以拖拽滑动。movable-view必须在movable-area组件中，并且必须是直接子节点，否则不能移动。 wxml文件代码1234567891011121314151617181920212223242526&lt;movable-area style="width: 200px; height: 200px;background: red;margin: 0 auto;"&gt; //x,y为可移动容器初始值，direction设置可移动方向，inertia设置是否有惯性。 &lt;movable-view style="width:20px;height:20px;background:blue" x="0" y="0" direction="all" inertia="true"&gt;&lt;/movable-view&gt;&lt;/movable-area&gt;&lt;view class="section"&gt; &lt;view class="section__title"&gt;movable-view区域小于movable-area&lt;/view&gt; &lt;movable-area style="height: 200px; width: 200px; background: red;"&gt; &lt;movable-view style="height: 50px; width: 50px; background: blue;" x="&#123;&#123;x&#125;&#125;" y="&#123;&#123;y&#125;&#125;" direction="all"&gt; &lt;/movable-view&gt; &lt;/movable-area&gt; &lt;view class="btn-area"&gt; &lt;button size="mini" bindtap="tap"&gt;click me to move to (30px, 30px)&lt;/button&gt; &lt;/view&gt; &lt;view class="section__title"&gt;movable-view区域大于movable-area&lt;/view&gt; &lt;movable-area style="height: 100px; width: 100px; background: red;"&gt; &lt;movable-view style="height: 200px; width: 200px; background: blue;" direction="all"&gt; &lt;/movable-view&gt; &lt;/movable-area&gt; &lt;view class="section__title"&gt;可放缩&lt;/view&gt; &lt;movable-area style="height: 200px; width: 200px; background: red;" scale-area&gt; //scale属性设置可缩放，scale-min和scale-max设置可缩放的范围，scale-value设置当前容器相对最小时的容器倍数。 &lt;movable-view style="height: 50px; width: 50px; background: blue;" direction="all" bindchange="onChange" bindscale="onScale" scale scale-min="0.5" scale-max="4" scale-value="2"&gt; &lt;/movable-view&gt; &lt;/movable-area&gt;&lt;/view&gt; js文件代码123456789101112131415161718Page(&#123; data: &#123; x: 0, y: 0 &#125;, tap: function (e) &#123; this.setData(&#123; x: 30, y: 30 &#125;); &#125;, onChange: function (e) &#123; console.log(e.detail) &#125;, onScale: function (e) &#123; console.log(e.detail) &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之视图容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiper（轮播图）]]></title>
    <url>%2Fpassages%2F2019-07-09-swiper%2F</url>
    <content type="text"><![CDATA[如何使用swiper组件 swiper组件 wxml文件代码 js文件代码 swiper组件wxml文件代码12345678910111213141516&lt;swiper indicator-dots="&#123;&#123;indicatorDots&#125;&#125;" autoplay="&#123;&#123;autoplay&#125;&#125;" interval="&#123;&#123;interval&#125;&#125;" duration="&#123;&#123;duration&#125;&#125;" &gt; &lt;block wx:for="&#123;&#123;imgUrls&#125;&#125;"&gt; &lt;swiper-item&gt; &lt;image src="&#123;&#123;item&#125;&#125;" class="slide-image" width="355" height="150"/&gt; &lt;/swiper-item&gt; &lt;/block&gt;&lt;/swiper&gt;&lt;button bindtap="changeIndicatorDots"&gt; indicator-dots &lt;/button&gt;&lt;button bindtap="changeAutoplay"&gt; autoplay &lt;/button&gt;&lt;slider bindchange="intervalChange" show-value min="500" max="2000"/&gt;&lt;slider bindchange="durationChange" show-value min="1000" max="10000"/&gt; js文件代码123456789101112131415161718192021222324252627282930313233Page(&#123; data: &#123; imgUrls: [ 'https://images.unsplash.com/photo-1551334787-21e6bd3ab135?w=640', 'https://images.unsplash.com/photo-1551214012-84f95e060dee?w=640', 'https://images.unsplash.com/photo-1551446591-142875a901a1?w=640' ], indicatorDots: false, autoplay: false, interval: 500, duration: 1000 &#125;, changeIndicatorDots: function (e) &#123; this.setData(&#123; indicatorDots: !this.data.indicatorDots &#125;) &#125;, changeAutoplay: function (e) &#123; this.setData(&#123; autoplay: !this.data.autoplay &#125;) &#125;, intervalChange: function (e) &#123; this.setData(&#123; interval: e.detail.value &#125;) &#125;, durationChange: function (e) &#123; this.setData(&#123; duration: e.detail.value &#125;) &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之视图容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wx:key]]></title>
    <url>%2Fpassages%2F2019-07-09-wx-key%2F</url>
    <content type="text"><![CDATA[如何使用wx:key属性 wx:key属性 wxml文件代码 js文件代码 wx:key属性如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt; input/&gt; 中的输入内容，&lt; switch/&gt; 的选中状态），需要使用 wx:key来指定列表中项目的唯一的标识符。 wx:key的值以两种形式提供:1.字符串，代表在for循环的array中item的某个property，该property的值需要是列表中唯一的字符串或数字，且不能动态改变。(简单来说就是给有wx:for属性的标签加上wx:key标签：wx:key=”一个字符串”) 2.保留关键字wx:key = *this代表在for循环中的item本身，这种表示需要item本身是一个唯一的字符串或者数字(数组是字符串或者数字)，如：当数据改变触发渲染层重新渲染的时候，会校正带有key的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。如不提供wx:key，会报一个warning，如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 wxml文件代码123456&lt;switch wx:for="&#123;&#123;objectArray&#125;&#125;" wx:key="unique" style="display: block;"&gt; &#123;&#123;item.id&#125;&#125; &lt;/switch&gt;&lt;button bindtap="switch"&gt; Switch &lt;/button&gt;&lt;button bindtap="addToFront"&gt; Add to the front &lt;/button&gt;&lt;switch wx:for="&#123;&#123;numberArray&#125;&#125;" wx:key="*this" style="display: block;"&gt; &#123;&#123;item&#125;&#125; &lt;/switch&gt;&lt;button bindtap="addNumberToFront"&gt; Add to the front &lt;/button&gt; js文件代码123456789101112131415161718192021222324252627282930313233343536373839Page(&#123;data: &#123;objectArray: [&#123; id: 5, unique: 'unique_5' &#125;,&#123; id: 4, unique: 'unique_4' &#125;,&#123; id: 3, unique: 'unique_3' &#125;,&#123; id: 2, unique: 'unique_2' &#125;,&#123; id: 1, unique: 'unique_1' &#125;,&#123; id: 0, unique: 'unique_0' &#125;,],numberArray: [1, 2, 3, 4]&#125;,switch: function (e) &#123;const length = this.data.objectArray.lengthfor (let i = 0; i &lt; length; ++i) &#123;const x = Math.floor(Math.random() * length)const y = Math.floor(Math.random() * length)const temp = this.data.objectArray[x]this.data.objectArray[x] = this.data.objectArray[y]this.data.objectArray[y] = temp&#125;this.setData(&#123;objectArray: this.data.objectArray&#125;)&#125;,addToFront: function (e) &#123;const length = this.data.objectArray.lengththis.data.objectArray = [&#123; id: length, unique: 'unique_' + length &#125;].concat(this.data.objectArray)this.setData(&#123;objectArray: this.data.objectArray&#125;)&#125;,addNumberToFront: function (e) &#123;this.data.numberArray = [this.data.numberArray.length + 1].concat(this.data.numberArray)this.setData(&#123;numberArray: this.data.numberArray&#125;)&#125;&#125;) 以&lt; switch&gt;&lt; /switch&gt;为例，如果没有wx:key，选中其中的某个按钮的时候，改变其顺序或添加选项的时，选中的按钮是不会跟随上个按钮改变顺序的，会一直在固定位子，如果如果有wx:key则相反，适用于列表或其他标签可以改变顺序或添加项目的情况。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wx:for]]></title>
    <url>%2Fpassages%2F2019-07-09-wx-for%2F</url>
    <content type="text"><![CDATA[如何使用wx:for循环 wx:for属性 wxml文件代码 js文件代码 实例-九九乘法表 注意事项 wx:for属性在组件上使用 wx:for 控制属性绑定一个数组（数据绑定），即可使用数组中各项的数据重复渲染该组件（重复使用标签）。默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item。（item[index]）使用数组的数据绑定（比如languages），不能直接使用该变量调用数据，要使用item。index里面存放的是数字，不能改变，只能改变变量名，根据渲染次数递增，从0开始。了解数据绑定 wxml文件代码12345//数据绑定&lt;view wx:for="&#123;&#123;languages&#125;&#125;"&gt; //默认下标变量名index，默认目标变量名item。 下标:&#123;&#123;index&#125;&#125;,ID:&#123;&#123;item.id&#125;&#125;,name:&#123;&#123;item.name&#125;&#125;.&lt;/view&gt; 下标变量名、目标变量名修改方法 123&lt;view wx:for="&#123;&#123;languages&#125;&#125;" wx:for-index="idx" wx:for-item="Name" wx:key="idx"&gt;&#123;&#123;idx&#125;&#125;:&#123;&#123;Name.id&#125;&#125;:&#123;&#123;Name.name&#125;&#125;&lt;/view&gt; js文件代码123456789101112Page(&#123; data: &#123; languages: [ //可以一次定义多个变量，类型可不同。 &#123; id: 1, name: 'php' &#125;, &#123; id: 4, name: 'javascript' &#125;, &#123; id: 3, name: 'golang' &#125;, &#123; id: 2, name: 'python' &#125;, &#123; id: 5, name: 'java' &#125;, ] &#125;&#125;) 实例-九九乘法表123456789&lt;view class='con'&gt;&lt;view wx:for="&#123;&#123;[1,2,3,4,5,6,7,8,9]&#125;&#125;" wx:for-item="i" wx:key="userInfoListId"&gt;&lt;view style='display:inline-block;width:60px' wx:for="&#123;&#123;[1,2,3,4,5,6,7,8,9]&#125;&#125;" wx:for-item="j" wx:key="userInfoListId"&gt;&lt;view wx:if="&#123;&#123;j&lt;=i&#125;&#125;"&gt;&#123;&#123;i&#125;&#125;*&#123;&#123;j&#125;&#125;=&#123;&#123;i*j&#125;&#125;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt; 注意事项当 wx:for的值为字符串时，会将字符串解析成字符串数组。 12345678910111213141516&lt;view wx:for="array"&gt; &#123;&#123;item&#125;&#125;&lt;/view&gt;//等同于&lt;view wx:for="&#123;&#123;['a','r','r','a','y']&#125;&#125;"&gt; &#123;&#123;item&#125;&#125;&lt;/view&gt;注意： 花括号和引号之间如果有空格，将最终被解析成为字符串。&lt;view wx:for="&#123;&#123;[1,2,3]&#125;&#125; "&gt; &#123;&#123;item&#125;&#125;&lt;/view&gt;//等同于&lt;view wx:for="&#123;&#123;[1,2,3] + ' '&#125;&#125;" &gt; &#123;&#123;item&#125;&#125;&lt;/view&gt;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[scroll-view（滚动框）]]></title>
    <url>%2Fpassages%2F2019-07-06-scroll-view%2F</url>
    <content type="text"><![CDATA[如何使用小程序组件scroll-view 使用scroll-veiw制作滚动框 wxml文件代码 wxss文件代码 js文件代码 使用scroll-veiw制作滚动框wxml文件代码12345678910111213141516171819202122232425262728293031&lt;view class="section"&gt; &lt;view class="section__title"&gt;vertical scroll&lt;/view&gt; //首先需要一个scroll-veiw标签，里面需要scroll-y/x属性。 //竖轴滚动需要设置高度，不然只能全局上下滚动。 //接下的三个是为了传回参数：当滑到顶部、底部、滚动时会传一个参数。没有需要时不必设置。 //toView里面放的是id，这个属性的功能是滚动到相应id的位置。 //最后一个属性就是放置一开始滚动框举例顶部的位置。 &lt;scroll-view scroll-y style="height: 200px;" bindscrolltoupper="upper" bindscrolltolower="lower" bindscroll="scroll" scroll-into-view="&#123;&#123;toView&#125;&#125;" scroll-top="&#123;&#123;scrollTop&#125;&#125;"&gt; &lt;view id="green" class="scroll-view-item bc_green"&gt;&lt;/view&gt; &lt;view id="red" class="scroll-view-item bc_red"&gt;&lt;/view&gt; &lt;view id="yellow" class="scroll-view-item bc_yellow"&gt;&lt;/view&gt; &lt;view id="blue" class="scroll-view-item bc_blue"&gt;&lt;/view&gt; &lt;/scroll-view&gt; &lt;view class="btn-area"&gt; //属性分别对应按钮大小和触发的函数。 &lt;button size="mini" bindtap="tap"&gt;click me to scroll into view &lt;/button&gt; &lt;button size="mini" bindtap="tapMove"&gt;click me to scroll&lt;/button&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class="section section_gap"&gt; &lt;view class="section__title"&gt;horizontal scroll&lt;/view&gt; //横轴滚动内联样式需要设置成white-space: nowrap;规定该标签不进行换行，因为小程序veiw标签默认换行。 &lt;scroll-view class="scroll-view_H" scroll-x style=" white-space: nowrap; display: flex" scroll-into-view="&#123;&#123;toView&#125;&#125;" scroll-left ="&#123;&#123;scrollTop&#125;&#125;"&gt; &lt;view id="green" class="scroll-view-item_H bc_green" style="display: inline-block"&gt;&lt;/view&gt; &lt;view id="red" class="scroll-view-item_H bc_red" style="display: inline-block"&gt;&lt;/view&gt; &lt;view id="yellow" class="scroll-view-item_H bc_yellow" style="display: inline-block"&gt;&lt;/view&gt; &lt;view id="blue" class="scroll-view-item_H bc_blue" style="display: inline-block"&gt;&lt;/view&gt; &lt;/scroll-view&gt;&lt;/view&gt; wxss文件代码1234567891011121314151617181920212223242526272829303132333435363738394041424344//css里面要设置有id属性的标签的样式的话需要在id前面加个“#”，在花括号里面加入样式。//如果是设置有class属性的标签的样式的话需要在class前面加个“.”，花括号里面加入样式。//四种颜色占了四块地方，通过颜色变化来看是否进行了滚动。（竖向）#red&#123; background: red; height: 200px; width: 100%;&#125;#yellow&#123; background: yellow; height: 200px; width: 100%;&#125;#blue&#123; background: blue; height: 200px; width: 100%;&#125;#green&#123; background: green; height: 200px; width: 100%;&#125;//下面是横向滚动的四个标签的id与样式。#red_2&#123; background: red; height: 100px; width: 100%;&#125;#yellow_2&#123; background: yellow; height: 100px; width: 100%;&#125;#blue_2&#123; background: blue; height: 100px; width: 100%;&#125;#green_2&#123; background: green; height: 100px; width: 100%;&#125; js文件代码12345678910111213141516171819202122232425262728293031323334//id数组，存放id的顺序。var order = ['red', 'yellow', 'blue', 'green', 'red']Page(&#123; data: &#123; toView: 'red', scrollTop: 0 &#125;, //前三个函数在控制台返回参数，第四个是改变toView里面的id值，第五个改变距离顶部的位置。 upper: function (e) &#123; console.log(e) &#125;, lower: function (e) &#123; console.log(e) &#125;, scroll: function (e) &#123; console.log(e) &#125;, tap: function (e) &#123; for (var i = 0; i &lt; order.length; ++i) &#123; if (order[i] === this.data.toView) &#123; this.setData(&#123; toView: order[i + 1] &#125;) // console.log(1) break &#125; &#125; &#125;, tapMove: function (e) &#123; this.setData(&#123; scrollTop: this.data.scrollTop + 10 &#125;) &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序组件之视图容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo]]></title>
    <url>%2Fpassages%2F2019-07-02-hexo%2F</url>
    <content type="text"><![CDATA[搭建hexo博客的历程 hexo 基本概念 下载安装 遇到的问题 一开始（6.29）我请教一位大佬关于微信小程序的问题，后来解决问题之后他就给我讲起了搭建Hexo博客来写笔记这个点子。一连串的概念我都不懂，但是有百度和大佬，花了三天时间，最终还是搭建好了这个博客。感谢大佬 !! hexo基本概念Hexo博客是一个框架（半成品），可以自己在官网选择主题搭建静态网页。为什么要用博客呢？因为做为一个程序员，需要一个记笔记的地方，然后又能随时翻笔记。使用Hexo还能展示自己的笔记给别人看，方便程序员之间互相学习。搭建Hexo之前需要安装Node.js和Git。并使用Node.js里面的NPM安装Hexo。下载上面那两个东西的时候可以创建一个GitHub账号，以继续后面的绑定域名操作。Node.js是可以运行服务器上的javascript的解析器。但在这里主要是用他里面的NPM来下载安装Hexo。NPM是随同NodeJS一起安装的包管理工具，能解决的NodeJS代码部署上的很多问题，常见的使用场景有以下几种：允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。可以通过输入“npm -v”来测试是否成功安装。Git是分布式版本控制系统，适用多人协作修改文件。下载Git之后需要一个编辑器来查看和编辑内容，我使用的是Sublime Text。Sublime Text是一个代码编辑器。支持多种编程语言的语法高亮、拥有优秀的代码自动完成功能，还拥有代码片段（Snippet）的功能，可以将常用的代码片段保存起来，在需要时随时调用。（Sublime自带Markdown语法规则）Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown语法学习 1234比如这个Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。 下载安装这里我就不多说安装的教程，因为都有一些比较好的教程，就不再重复。Hexo下载安装教程 我的主题是AD，这个主题有很多有趣的功能，但是问题也有一两个。 遇到的问题①控制台安装Git之后，要用Git Bash Here（远程连接）来安装Hexo。②密码拦截功能，按照他中文文档的操作还是不能给文章加密。目前在他的github上面询问。③注册Learn Cloud启动不了评论和访问人数，原因：域名必须填博客的域名。（平台不必实名）④AD主题原版本有站内搜索文章功能，现在的版本没有站内搜索功能，所以只能自己想办法加入搜索功能。 解决方法：1.自己写代码。2.使用类似Swiftype的搜索平台，给自己网站加搜索功能。我采用的是第二种，这里是教程。 加入搜索功能遇到的问题:1.注册Swiftype需要外国的邮箱比如说谷歌邮箱。2.AD主题的百度/谷歌/必应搜索功能不适合拿来做站内搜索功能。大佬教给我的解决办法就是自己创一个搜索按键，替代原本的搜索引擎功能。在搜索引擎的按键位置（header.ejs）添加以下代码。（可以添加很多个） 1234&lt;!-- 搜索按钮就加上 class="st-search-show-outputs" --&gt;&lt;% if (theme.swift_search.enable)&#123; %&gt; &lt;a href="#" title="搜索博客" class="st-search-show-outputs"&gt;搜索&lt;/a&gt;&lt;% &#125; %&gt; 再把样式改改，然后就可以愉快地搜索了！！]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lock]]></title>
    <url>%2Fpassages%2F2019-07-01-lock%2F</url>
    <content type="text"><![CDATA[听说可以锁上一些文章,我试试 Test好吧，不行。]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[start]]></title>
    <url>%2Fpassages%2F2019-07-01-start%2F</url>
    <content type="text"><![CDATA[这是一个没有营养的前言 尝试开始 感想 尝试开始感想第一次尝试搭建博客，原来当程序员也是个体力活。 2333]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpassages%2F2019-06-30-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
